<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Promise源码实现——版本一</title>
    <url>/2020/08/20/Promise/Promise%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B01/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Promise/A+规定的三种状态</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_status</span> = <span class="variable constant_">PENDING</span>     <span class="comment">// Promise状态</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="literal">undefined</span>    <span class="comment">// 储存then回调return的值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_resolveQueue</span> = []    <span class="comment">// 成功队列, resolve时触发</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_rejectQueue</span> = []     <span class="comment">// 失败队列, reject时触发</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">_resolve</span> = (<span class="params">val</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">//把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况</span></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">run</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">_status</span> !== <span class="variable constant_">PENDING</span>) <span class="keyword">return</span>   <span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_status</span> = <span class="variable constant_">FULFILLED</span>              <span class="comment">// 变更状态</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_value</span> = val                     <span class="comment">// 储存当前value</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span></span><br><span class="line">        <span class="comment">// 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">_resolveQueue</span>.<span class="property">length</span>) &#123;    </span><br><span class="line">          <span class="keyword">const</span> callback = <span class="variable language_">this</span>.<span class="property">_resolveQueue</span>.<span class="title function_">shift</span>()</span><br><span class="line">          <span class="title function_">callback</span>(val)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">setTimeout</span>(run)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现同resolve</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">_reject</span> = (<span class="params">val</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">run</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">_status</span> !== <span class="variable constant_">PENDING</span>) <span class="keyword">return</span>   <span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_status</span> = <span class="variable constant_">REJECTED</span>               <span class="comment">// 变更状态</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_value</span> = val                     <span class="comment">// 储存当前value</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">_rejectQueue</span>.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> callback = <span class="variable language_">this</span>.<span class="property">_rejectQueue</span>.<span class="title function_">shift</span>()</span><br><span class="line">          <span class="title function_">callback</span>(val)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">setTimeout</span>(run)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// new Promise()时立即执行executor,并传入resolve和reject</span></span><br><span class="line">    <span class="title function_">executor</span>(_resolve, _reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">resolveFn, rejectFn</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span></span><br><span class="line">    <span class="keyword">typeof</span> resolveFn !== <span class="string">&#x27;function&#x27;</span> ? resolveFn = <span class="function"><span class="params">value</span> =&gt;</span> value : <span class="literal">null</span></span><br><span class="line">    <span class="keyword">typeof</span> rejectFn !== <span class="string">&#x27;function&#x27;</span> ? rejectFn = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(reason <span class="keyword">instanceof</span> <span class="title class_">Error</span>? reason.<span class="property">message</span>:reason);</span><br><span class="line">    &#125; : <span class="literal">null</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// return一个新的promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">fulfilledFn</span> = value =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">          <span class="keyword">let</span> x = <span class="title function_">resolveFn</span>(value)</span><br><span class="line">          <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">          x <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span> ? x.<span class="title function_">then</span>(resolve, reject) : <span class="title function_">resolve</span>(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// reject同理</span></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">rejectedFn</span>  = error =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = <span class="title function_">rejectFn</span>(error)</span><br><span class="line">          x <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span> ? x.<span class="title function_">then</span>(resolve, reject) : <span class="title function_">resolve</span>(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">switch</span> (<span class="variable language_">this</span>.<span class="property">_status</span>) &#123;</span><br><span class="line">        <span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">        <span class="keyword">case</span> <span class="attr">PENDING</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">_resolveQueue</span>.<span class="title function_">push</span>(fulfilledFn)</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">_rejectQueue</span>.<span class="title function_">push</span>(rejectedFn)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">        <span class="keyword">case</span> <span class="attr">FULFILLED</span>:</span><br><span class="line">          <span class="title function_">fulfilledFn</span>(<span class="variable language_">this</span>.<span class="property">_value</span>)    <span class="comment">// this._value是上一个then回调return的值(见完整版代码)</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="attr">REJECTED</span>:</span><br><span class="line">          <span class="title function_">rejectedFn</span>(<span class="variable language_">this</span>.<span class="property">_value</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//catch方法其实就是执行一下then的第二个回调</span></span><br><span class="line">  <span class="keyword">catch</span>(rejectFn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, rejectFn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//finally方法</span></span><br><span class="line">  <span class="title function_">finally</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(</span><br><span class="line">      <span class="function"><span class="params">value</span> =&gt;</span> <span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> value),             <span class="comment">//执行回调,并returnvalue传递给后面的then</span></span><br><span class="line">      <span class="function"><span class="params">reason</span> =&gt;</span> <span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)  <span class="comment">//reject同理</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态的resolve方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) <span class="keyword">return</span> value <span class="comment">//根据规范, 如果参数是Promise实例, 直接return这个实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(value))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态的reject方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(reason))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态的all方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">all</span>(<span class="params">promiseArr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      promiseArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">        <span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(p).<span class="title function_">then</span>(</span><br><span class="line">          <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            index++</span><br><span class="line">            result[i] = val</span><br><span class="line">            <span class="keyword">if</span>(index === promiseArr.<span class="property">length</span>) &#123;</span><br><span class="line">              <span class="title function_">resolve</span>(result)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态的race方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">race</span>(<span class="params">promiseArr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> promiseArr) &#123;</span><br><span class="line">        <span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(p).<span class="title function_">then</span>(  <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">          <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(value)        <span class="comment">//注意这个resolve是上边new MyPromise的</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">success</span> (res) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">  &#125;, <span class="keyword">function</span> <span class="title function_">fail1</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;fail1: &#x27;</span>, e)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> <span class="title function_">fail2</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;fail2: &#x27;</span>, e)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise——结合源码看的十道题目</title>
    <url>/2020/08/29/Promise/%E7%9C%8B%E4%BA%86%E5%BF%85%E6%87%82%E7%9A%84Promise%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="题目1"><a href="#题目1" class="headerlink" title="题目1."></a>题目1.</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>搞清楚宏任务和微任务的执行顺序（先宏任务，再微任务，以此循环…）<a href="https://www.cnblogs.com/wangziye/p/9566454.html">js 宏任务和微任务</a><br>典型的微任务： Promise、process.nextTick<br>典型的宏任务：setTimeout</p>
<h3 id="题目2"><a href="#题目2" class="headerlink" title="题目2."></a>题目2.</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error!!!&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>, promise1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>, promise2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>, promise1)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>, promise2)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>

<h3 id="题目3"><a href="#题目3" class="headerlink" title="题目3."></a>题目3.</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;success1&#x27;</span>)</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;success2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then: &#x27;</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch: &#x27;</span>, err)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为什么连续调用了resolve()、reject()、resolve()3次，只有第一个会执行？，从源码中可以看到，不管是resove还是reject，只有value&#x3D;&#x3D;&#x3D;’pedding’,才会执行，而第一次的resolve()已经把状态置成了’fulfilled’，不再是’pedding’，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">resolve</span> = value =&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只有状态是PENDING，才会执行后续</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="题目4"><a href="#题目4" class="headerlink" title="题目4."></a>题目4.</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="题目5"><a href="#题目5" class="headerlink" title="题目5."></a>题目5.</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;once&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res, <span class="title class_">Date</span>.<span class="title function_">now</span>() - start)</span><br><span class="line">&#125;)</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res, <span class="title class_">Date</span>.<span class="title function_">now</span>() - start)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="题目6"><a href="#题目6" class="headerlink" title="题目6."></a>题目6.</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error!!!&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then: &#x27;</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch: &#x27;</span>, err)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="题目7"><a href="#题目7" class="headerlink" title="题目7."></a>题目7.</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">  &#125;)</span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="题目8"><a href="#题目8" class="headerlink" title="题目8."></a>题目8.</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="number">2</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>promise的透传，首先1传了第一个then，但then(fn)函数期待参数fn是个函数，但确传了个数值2，所以promise会如封装一个函数<code>return (p) =&gt; p</code>,这里p是1，所以就会一直之执行resove(1)透传下去</p>
<h3 id="题目9"><a href="#题目9" class="headerlink" title="题目9."></a>题目9.</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">success</span> (res) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">  &#125;, <span class="keyword">function</span> <span class="title function_">fail1</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;fail1: &#x27;</span>, e)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> <span class="title function_">fail2</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;fail2: &#x27;</span>, e)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML脱离文档流的三种方法</title>
    <url>/2018/10/24/css/HTML%E8%84%B1%E7%A6%BB%E6%96%87%E6%A1%A3%E6%B5%81%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="什么是文档流？"><a href="#什么是文档流？" class="headerlink" title="什么是文档流？"></a>什么是文档流？</h2><p>将窗体自上而下分成一行一行，并在每行中按从左至右依次排放元素，称为文档流，也称为普通流。</p>
<p>这个应该不难理解，HTML中全部元素都是盒模型，盒模型占用一定的空间，依次排放在HTML中，形成了文档流。</p>
<h2 id="什么是脱离文档流？"><a href="#什么是脱离文档流？" class="headerlink" title="什么是脱离文档流？"></a>什么是脱离文档流？</h2><p>元素脱离文档流之后，将不再在文档流中占据空间，而是处于浮动状态（可以理解为漂浮在文档流的上方）。脱离文档流的元素的定位基于正常的文档流，当一个元素脱离文档流后，依然在文档流中的其他元素将忽略该元素并填补其原先的空间。</p>
<h2 id="怎么脱离文档流？"><a href="#怎么脱离文档流？" class="headerlink" title="怎么脱离文档流？"></a>怎么脱离文档流？</h2><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><p>使用float可以脱离文档流。</p>
<p>注意！！！：使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在该元素的周围。</p>
<p>举个栗子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.first</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid red;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.second</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid blue;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;first&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;second&quot;</span>&gt;</span>456<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img data-src="https://chao31.github.io/pics/img/202303021635021.png"></p>
<p>这段代码中把红色的框设置为了左浮，所以红色的框称为了浮动状态（浮动在蓝色框的上面），而蓝色框占用了原来空色框的位置。注意到，蓝色框中的文本依然认为红色框存在，所以为红色框让出了位置。由于div是块状元素，所以456出现在下方。</p>
<h3 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h3><p>absolute称为绝对定位，其实博主觉得应该称为相对定位，因为使用absolute脱离文档流后的元素，是相对于该元素的父类（及以上，如果直系父类元素不满足条件则继续向上查询）元素进行定位的，并且这个父类元素的position必须是非static定位的（static是默认定位方式）。</p>
<p>举个栗子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.first</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.second</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid blue;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.third</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;first&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;second&quot;</span>&gt;</span>456<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;third&quot;</span>&gt;</span>789<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="https://chao31.github.io/pics/img/202303021637717.png"></p>
<p>通过把蓝色的框的position设置为absolute使蓝色的框变为浮动状态，可以看到绿色的框被蓝色的框遮挡。emmm…，看起来貌似没有问题，但是还记得前面说的absolute是相对谁定位的吗？相对非static元素的父级定位的，这里蓝框的父级就是html，所以应该是相对于html定位，但是代码中没有提供相对位置，所以只能浮动在原来该元素在文档流中的位置上方。</p>
<p>下面加上相对位置并把html以dotted的形式显示出来：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.first</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.second</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid blue;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.third</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">html</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: dotted;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;first&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;second&quot;</span>&gt;</span>456<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;third&quot;</span>&gt;</span>789<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://chao31.github.io/pics/img/202303021637487.png"></p>
<p>结果很明显，蓝色的框遮住了html的点，所以当父级元素的position全是static的时候，absolute是相对于html来进行定位的。</p>
<p>下面举个相对于父级元素定位的栗子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.first</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid red;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.second</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid blue;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.third</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">html</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: dotted;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;first&quot;</span>&gt;</span></span><br><span class="line">    123</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;second&quot;</span>&gt;</span></span><br><span class="line">        456</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;third&quot;</span>&gt;</span></span><br><span class="line">    789</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://chao31.github.io/pics/img/202303021638347.png"></p>
<p>嗯，没问题，蓝色的框是相对红色的框进行定位的，具体来说是相对于border。（可以试一下改变红色框的margin和paddind看看会发生什么）。</p>
<p>注意：绝对定位的窗口一般都要设置相对距离，当你同时设置top和bottom的时候，只有top会生效，同理，同时设置left和right的时候，只有left会生效。</p>
<h3 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h3><p>完全脱离文档流，相对于浏览器窗口进行定位。（相对于浏览器窗口就是相对于html）。</p>
<p> 举个栗子：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.first</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.second</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid blue;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.third</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">html</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: dotted;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;first&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;second&quot;</span>&gt;</span>456<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;third&quot;</span>&gt;</span>789<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="https://chao31.github.io/pics/img/202303021638883.png"></p>
<p>可以很明显的看出，蓝色的框是相对于html进行定位的。当然，如果不提供相对位置的话，蓝色的框会浮动在其原先在文档流中的位置上方。</p>
<p>Note：文档流是在body中的，body在html中，这个在代码结构中也体现出来了，下面的例子可以更直观的看出：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.first</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.second</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid blue;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.third</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: dotted red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">html</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: double black;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;first&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;second&quot;</span>&gt;</span>456<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;third&quot;</span>&gt;</span>789<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="https://chao31.github.io/pics/img/202303021639461.png"></p>
<h3 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h3><p>最后说一个半脱离文档流的方法，就是position：relative。下面说明一下为什么是半脱离文档流。</p>
<p>先看下面这段代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.first</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.second</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid blue;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">top</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.third</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;first&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;second&quot;</span>&gt;</span>456<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;third&quot;</span>&gt;</span>789<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="https://chao31.github.io/pics/img/202303021639292.png"></p>
<p>可以看到，蓝色的框是浮动了，但是绿色的框却相对于蓝色的框原先在文档流中的位置进行了定位。这就是所谓的半脱离文档流，本体还在文档流中占有位置，但是却可以通过改变位置使其漂浮到其他的地方，其定位方式是相对其原先在文档流中的位置进行定位的。</p>
<p>注意：可以尝试改变蓝色框的margin和padding属性，看一下会发生什么。</p>
<p>关键就是知道蓝色框在原来的文档流占用位置，相对定位后还是在原来的位置占据文档流。（类似实体投影到另一个地方）。</p>
<p>以上就是脱离文档流的方法。</p>
<p>最后再多说一句，一般设置relative是为了让absolute有个相对定位的参照。</p>
<p><a href="https://blog.csdn.net/thelostlamb/article/details/79581984">转载自</a></p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>git reset、--soft、--hard的区别</title>
    <url>/2018/06/13/git/git%E7%9A%84reset%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git reset [--soft | --mixed | --hard] </span><br></pre></td></tr></table></figure>
<p>为了简单，不用工作区和暂存区描述，用红色文件和绿色文件描述</p>
<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p><code>git reset</code> 不加参数，默认是–mixed </p>
<p>git会回到指定的commit，并将两个commit之间的所有diff保留下来（红色文件）</p>
<p>利用这个特性，在合master前，feature分支的commit太多，希望合成一个</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回到最初的commit</span></span><br><span class="line">git reset xxxxx</span><br><span class="line"><span class="comment">// 重新提一个commit</span></span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">&#x27;新功能xxx&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>☑️ Squash commits when merge request is accepted.<br>其实提MR时，勾选这个，就能合并所有的commit</p>
</blockquote>
<h3 id="git-reset-–hard"><a href="#git-reset-–hard" class="headerlink" title="git reset –hard"></a>git reset –hard</h3><p>git 会回到指定的commit，但两个commit之间的所有diff都被删除，干干净净的回到指定commit（如果执行这个命令之前就有被修改的红色文件，执行之后也会被删除）</p>
<h3 id="git-reset-–soft"><a href="#git-reset-–soft" class="headerlink" title="git reset –soft"></a>git reset –soft</h3><p>git会回到指定的commit，并将两个commit之间的所有diff保留下来，但不会变成红色文件，而是变成绿色文件（执行命令之前的红色文件修改，依然保留下来为红色）</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>你想知道的BFC</title>
    <url>/2018/11/25/css/%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84BFC/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用技巧</title>
    <url>/2017/08/12/git/git%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h3 id="git-push-–set-upstream"><a href="#git-push-–set-upstream" class="headerlink" title="git push –set-upstream"></a>git push –set-upstream</h3><p>新建一个分支NAME后，直接执行<code>git push</code>到远程，是push不上去的</p>
<p>要么就是暴力推上去<code>git push origin NAME</code>,</p>
<p>若用下面这个建立远程关联，以后就能用<code>git push</code>了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin <span class="variable constant_">NAME</span></span><br></pre></td></tr></table></figure>
<h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 提交本地test分支 作为 远程的master分支</span><br><span class="line">git push origin test:master </span><br></pre></td></tr></table></figure>

<h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 相当于是从远程获取最新版本到本地，不会自动merge</span><br><span class="line">git fetch</span><br><span class="line"></span><br><span class="line">// 把b分支合并到当前分支</span><br><span class="line">git rebase b </span><br><span class="line"></span><br><span class="line">// 如：将远程的origin/master，合到本地分支</span><br><span class="line">git rebase origin/master</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="提mr时，合master有冲突"><a href="#提mr时，合master有冲突" class="headerlink" title="提mr时，合master有冲突"></a>提mr时，合master有冲突</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;分支名&gt; origin/&lt;分支名&gt;</span><br><span class="line">git checkout master</span><br><span class="line">git pull --rebase=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">git checkout &lt;分支名&gt;</span><br><span class="line"># 合并master</span><br><span class="line">git merge master --no-ff</span><br><span class="line"># 解决冲突后，</span><br><span class="line">git add -A</span><br><span class="line">git commit -m &lt;合并信息&gt;</span><br><span class="line">git push origin &lt;分支名&gt;:&lt;分支名&gt;</span><br></pre></td></tr></table></figure>

<h3 id="文件回退到指定版本"><a href="#文件回退到指定版本" class="headerlink" title="文件回退到指定版本"></a>文件回退到指定版本</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会把文件变成绿色 + 红色</span></span><br><span class="line">git reset xxxx file</span><br><span class="line"><span class="comment">// 对红色进行checkout恢复，就只剩绿色了，但文件已经变回指定版本了</span></span><br><span class="line">git checkout file</span><br><span class="line"><span class="comment">// 若想让绿色变成红色，继续reset操作</span></span><br></pre></td></tr></table></figure>

<h3 id="回退到某个版本"><a href="#回退到某个版本" class="headerlink" title="回退到某个版本"></a>回退到某个版本</h3><p><a href="https://chao31.github.io/2018/06/13/git/git%E7%9A%84reset%E5%8C%BA%E5%88%AB/">详细请看</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git reset abcsd</span><br><span class="line">git reset --hard abcsd</span><br><span class="line">git reset --soft abcsd</span><br></pre></td></tr></table></figure>

<h3 id="git-reflog-回退到某个操作"><a href="#git-reflog-回退到某个操作" class="headerlink" title="git reflog 回退到某个操作"></a>git reflog 回退到某个操作</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过reflog找到操作的commit</span></span><br><span class="line">git reflog</span><br><span class="line"><span class="comment">// 回到那个commit</span></span><br><span class="line">git reset </span><br></pre></td></tr></table></figure>

<h3 id="回退到上一个版本"><a href="#回退到上一个版本" class="headerlink" title="回退到上一个版本"></a>回退到上一个版本</h3><p>上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写<code>100个^</code>比较容易数不过来，所以写成<code>HEAD~100</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git reset --hard <span class="variable constant_">HEAD</span>^</span><br></pre></td></tr></table></figure>

<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看当前修改了啥</span></span><br><span class="line">git diff</span><br><span class="line"><span class="comment">// 和某个commit做diff</span></span><br><span class="line">git diff 276bb8f</span><br><span class="line"><span class="comment">// 和某个文件做diff</span></span><br><span class="line">git diff index.<span class="property">html</span></span><br></pre></td></tr></table></figure>
<h3 id="查看分支合并图"><a href="#查看分支合并图" class="headerlink" title="查看分支合并图"></a>查看分支合并图</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git log --graph</span><br></pre></td></tr></table></figure>

<h3 id="基于某个分支创建新分支"><a href="#基于某个分支创建新分支" class="headerlink" title="基于某个分支创建新分支"></a>基于某个分支创建新分支</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于当前分支创建新分支dev</span></span><br><span class="line">git checkout -b dev</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于远程分支，创建新分支</span></span><br><span class="line">git checkout -b &lt;分支名&gt; origin/&lt;分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如：本地没有 develop-test，基于远程创建一个develop-test</span></span><br><span class="line">git checkout -b develop-test origin/develop-test</span><br></pre></td></tr></table></figure>

<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>查看本地分支：<code>git branch</code></p>
<p>查看远程分支：<code>git branch -a</code></p>
<p>创建分支：<code>git branch &lt;name&gt;</code></p>
<p>切换分支：<code>git checkout &lt;name&gt;</code></p>
<p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></p>
<p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>
<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
<h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p>查看工作现场：<code>git stash list</code></p>
<p>恢复现场但不删除stash：<code>git stash apply</code></p>
<p>删除stash：<code>git stash drop</code></p>
<p>恢复现场并删除stash：<code>git stash pop</code></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise源码实现——版本二</title>
    <url>/2020/08/27/Promise/Promise%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B02/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AjPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">PENDING</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span> = [];</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = value =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">FULFILLED</span>;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">map</span>(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">            cb = <span class="title function_">cb</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = reason =&gt; &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">REJECTED</span>;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">map</span>(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">            cb = <span class="title function_">cb</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">fn</span>(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> newPromise;</span><br><span class="line"></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">    onRejected =</span><br><span class="line">      <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">        ? onRejected</span><br><span class="line">        : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">          &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (newPromise = <span class="keyword">new</span> <span class="title class_">AjPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">            <span class="title function_">resolvePromise</span>(newPromise, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (newPromise = <span class="keyword">new</span> <span class="title class_">AjPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">            <span class="title function_">resolvePromise</span>(newPromise, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (newPromise = <span class="keyword">new</span> <span class="title class_">AjPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onFulfilled</span>(value);</span><br><span class="line">            <span class="title function_">resolvePromise</span>(newPromise, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(reason);</span><br><span class="line">            <span class="title function_">resolvePromise</span>(newPromise, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">null</span>, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;循环引用&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="title class_">AjPromise</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      x.<span class="title function_">then</span>(</span><br><span class="line">        <span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">resolvePromise</span>(promise2, y, resolve, reject);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x.<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">&#x27;function&#x27;</span> || <span class="keyword">typeof</span> x === <span class="string">&#x27;object&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.<span class="property">then</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        then.<span class="title function_">call</span>(</span><br><span class="line">          x,</span><br><span class="line">          <span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, y, resolve, reject);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            <span class="title function_">reject</span>(r);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">      called = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">reject</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">AjPromise</span>.<span class="property">all</span> = <span class="keyword">function</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AjPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> done = <span class="title function_">gen</span>(promises.<span class="property">length</span>, resolve);</span><br><span class="line">    promises.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">      promise.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">done</span>(index, value);</span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">gen</span>(<span class="params">length, resolve</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> values = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">i, value</span>) &#123;</span><br><span class="line">    values[i] = value;</span><br><span class="line">    <span class="keyword">if</span> (++count === length) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(values);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">AjPromise</span>.<span class="property">race</span> = <span class="keyword">function</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AjPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      promises[i].<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">AjPromise</span>.<span class="property">resolve</span> = <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AjPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">resolve</span>(value));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">AjPromise</span>.<span class="property">reject</span> = <span class="keyword">function</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AjPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(reason));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">AjPromise</span>.<span class="property">deferred</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> defer = &#123;&#125;;</span><br><span class="line">  defer.<span class="property">promise</span> = <span class="keyword">new</span> <span class="title class_">AjPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    defer.<span class="property">resolve</span> = resolve;</span><br><span class="line">    defer.<span class="property">reject</span> = reject;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> defer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// module.exports = AjPromise;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new AjPromise((resolve, reject) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     resolve(2);</span></span><br><span class="line"><span class="comment">//   &#125;, 2000);</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">//   .then(res =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     console.log(res);</span></span><br><span class="line"><span class="comment">//     return res + 1;</span></span><br><span class="line"><span class="comment">//   &#125;)</span></span><br><span class="line"><span class="comment">//   .then(res =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     console.log(res);</span></span><br><span class="line"><span class="comment">//   &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环引用</span></span><br><span class="line"><span class="comment">// const promise = AjPromise.resolve()</span></span><br><span class="line"><span class="comment">//   .then(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     return promise</span></span><br><span class="line"><span class="comment">//   &#125;)</span></span><br><span class="line"><span class="comment">// promise.catch(console.error)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">AjPromise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>merge--no-ff和--ff和--squash的区别</title>
    <url>/2020/02/01/git/merge-no-ff%E5%92%8C-ff%E5%92%8C-squash%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="一张图来告诉你–no-ff和–ff"><a href="#一张图来告诉你–no-ff和–ff" class="headerlink" title="一张图来告诉你–no-ff和–ff"></a>一张图来告诉你–no-ff和–ff</h3><p><img data-src="/2020/02/01/git/merge-no-ff%E5%92%8C-ff%E5%92%8C-squash%E7%9A%84%E5%8C%BA%E5%88%AB/b6.png"></p>
<h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><blockquote>
<p>我们平常什么都不加的时候，则使用默认的 –ff ， 即 fast-forward 方式</p>
</blockquote>
<blockquote>
<p>fast-forward方式就是当条件允许的时候，git直接把HEAD指针指向合并分支的头，完成合并。属于“快进方式”，不过这种情况如果删除分支，则会丢失分支信息。因为在这个过程中没有创建commit</p>
</blockquote>
<h3 id="git-merge-–no-ff"><a href="#git-merge-–no-ff" class="headerlink" title="git merge –no-ff"></a>git merge –no-ff</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指的是强行关闭fast-forward方式,保留分支的commit历史</span><br></pre></td></tr></table></figure>

<h3 id="git-merge-–squash"><a href="#git-merge-–squash" class="headerlink" title="git merge –squash"></a>git merge –squash</h3><blockquote>
<p>是用来把一些不必要commit进行压缩，比如说，你的feature在开发的时候写的commit很乱，那么我们合并的时候不希望把这些历史commit带过来，于是使用</p>
</blockquote>
<h3 id="动图来告诉几种合并的区别"><a href="#动图来告诉几种合并的区别" class="headerlink" title="动图来告诉几种合并的区别"></a>动图来告诉几种合并的区别</h3><p><img data-src="/2020/02/01/git/merge-no-ff%E5%92%8C-ff%E5%92%8C-squash%E7%9A%84%E5%8C%BA%E5%88%AB/b1.gif"><br><img data-src="/2020/02/01/git/merge-no-ff%E5%92%8C-ff%E5%92%8C-squash%E7%9A%84%E5%8C%BA%E5%88%AB/b2.gif"><br><img data-src="/2020/02/01/git/merge-no-ff%E5%92%8C-ff%E5%92%8C-squash%E7%9A%84%E5%8C%BA%E5%88%AB/b3.gif"><br><img data-src="/2020/02/01/git/merge-no-ff%E5%92%8C-ff%E5%92%8C-squash%E7%9A%84%E5%8C%BA%E5%88%AB/b4.gif"><br><img data-src="/2020/02/01/git/merge-no-ff%E5%92%8C-ff%E5%92%8C-squash%E7%9A%84%E5%8C%BA%E5%88%AB/b5.png"></p>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p><img data-src="/2020/02/01/git/merge-no-ff%E5%92%8C-ff%E5%92%8C-squash%E7%9A%84%E5%8C%BA%E5%88%AB/a1.png"></p>
<blockquote>
<p>在master分支上，执行<code>git merge hotfix</code><br>然后看到了Fast-forward 的字样，hotfix通过–ff的方式合进了master，如下：<br><img data-src="/2020/02/01/git/merge-no-ff%E5%92%8C-ff%E5%92%8C-squash%E7%9A%84%E5%8C%BA%E5%88%AB/a2.png"><br>仅仅是master指针指向了这个提交C4。这样是一种比较快的合并方式，轻量级，简单。<br>这个时候，我们往往会删掉hotfix分支，因为它的历史作用已经结束，这个时候，我们的iss53这个功能又向前开发，进行了一次提交，到了C5，那么变成了这样：<br><img data-src="/2020/02/01/git/merge-no-ff%E5%92%8C-ff%E5%92%8C-squash%E7%9A%84%E5%8C%BA%E5%88%AB/a3.png"><br>然后，我们要把iss53 这个分支合并回master，因为有分叉，两个版本的内容要进行合并,是不能用Fast-forward（只有在没有需要合并内容的时候，会有这个fast-forward 方式的提交） ，这时用的就是–no-ff的效果，并生成了一个新的commit号<br><img data-src="/2020/02/01/git/merge-no-ff%E5%92%8C-ff%E5%92%8C-squash%E7%9A%84%E5%8C%BA%E5%88%AB/a4.png"><br>如果我们对第一次合并，使用了–no-ff参数，那么也会产生这样的结果，生成一个新的提交，实际上等于是对C4 进行一次复制，创建一个新的commit，这就是–no-ff的作用。</p>
</blockquote>
<p>参考:<br><a href="https://www.codenong.com/9069061/">“git merge”和”git merge–no ff”有什么区别？</a><br><a href="https://blog.csdn.net/chaiyu2002/article/details/81020370">Git：git-merge的–ff和–no-ff</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git rebase和git merge的区别</title>
    <url>/2020/01/28/git/rebase%E5%92%8Cmerge%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>假设有个开发过程如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1. master分支有两个commit：C1 -&gt; C2</span><br><span class="line">2. 我基于master切一个dev分支进行开发</span><br><span class="line">3. dev分支在今天下午生成了3个commit，分别在：C3(2点)-&gt; C4(3点) -&gt; C5(6点)</span><br><span class="line">4. 同样在今天下午，其它开发者先于我在master分支上合入了自己的分支，C6(4点) -&gt; C7(5点)，所以远程的master就变成了C1 -&gt; C2 -&gt; C6(4点) -&gt; C7(5点)</span><br></pre></td></tr></table></figure>
<p>如下图：<br><img data-src="/2020/01/28/git/rebase%E5%92%8Cmerge%E7%9A%84%E5%8C%BA%E5%88%AB/a1.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5. 在7点，我想把我的dev分支合进master，有两种选择：merge和rebase</span><br></pre></td></tr></table></figure>

<h3 id="使用git-merge"><a href="#使用git-merge" class="headerlink" title="使用git merge"></a>使用git merge</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 在master上，执行`git merge dev`</span><br><span class="line">2. git会找出master和dev的最近共同祖先commit点，即分叉点C2</span><br><span class="line">3. 然后进行合并，将dev最后1次的commit（C5）和master最后一次commit（C7）合并后生成一个新的commit（C8），有冲突的话需要解决冲突</span><br><span class="line">4. 再将C8和C2之间的所有commit，按提交时间顺序进行排序</span><br><span class="line">5. 最后生成的master：C1 -&gt; C2 -&gt;C3(2点)-&gt; C4(3点) -&gt; C6(4点) -&gt; C7(5点) -&gt; C5(6点) -C8(7点)</span><br></pre></td></tr></table></figure>
<p><img data-src="/2020/01/28/git/rebase%E5%92%8Cmerge%E7%9A%84%E5%8C%BA%E5%88%AB/a2.jpg"></p>
<h3 id="使用git-rebase"><a href="#使用git-rebase" class="headerlink" title="使用git rebase"></a>使用git rebase</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 在dev分支上，执行`git rebase origin/master`，push到dev远程后，再去master分支，执行`git merge dev`</span><br><span class="line">2. 执行rebase时，git会找出master和dev的最近共同祖先commit点，即分叉点C2</span><br><span class="line">3. 然后将dev分支上，C2到最后一次commit(C5)之间的所有commit截取，移接到master的最后一次commit(C7)后面，但截取的这一段(C3~C5的commit的hash值会变成新的，也就是变成了C3&#x27;~C5&#x27;)</span><br><span class="line">4. dev rebase了 master后，就变成了C1 -&gt; C2 -&gt; C6 -&gt; C7 -&gt; C3&#x27; -&gt; C4&#x27; -&gt; C5&#x27;</span><br></pre></td></tr></table></figure>
<p><img data-src="/2020/01/28/git/rebase%E5%92%8Cmerge%E7%9A%84%E5%8C%BA%E5%88%AB/a3.jpg"></p>
<h3 id="merge和rebase的区别"><a href="#merge和rebase的区别" class="headerlink" title="merge和rebase的区别"></a>merge和rebase的区别</h3><p><img data-src="/2020/01/28/git/rebase%E5%92%8Cmerge%E7%9A%84%E5%8C%BA%E5%88%AB/a4.jpg"></p>
<ul>
<li><p><code>git merge</code> 操作合并分支会让两个分支的每一次提交都按照提交时间（并不是push时间）排序，并且会将两个分支的最新一次commit点进行合并成一个新的commit，最终的分支树呈现菱形</p>
</li>
<li><p><code>git rebase</code>操作实际上是将当前执行rebase分支的所有基于原分支提交点之后的commit打散成一个一个的patch，并重新生成一个新的commit hash值，再次基于原分支目前最新的commit点上进行提交，并不根据两个分支上实际的每次提交的时间点排序，rebase完成后，切到基分支进行合并另一个分支时也不会生成一个新的commit点，最终的分支树呈现线性</p>
</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>SEO 的 301 和 302 重定向：应该使用哪个？</title>
    <url>/2021/01/01/http/SEO/</url>
    <content><![CDATA[<h2 id="301-和-302-选哪个重要吗？"><a href="#301-和-302-选哪个重要吗？" class="headerlink" title="301 和 302 选哪个重要吗？"></a>301 和 302 选哪个重要吗？</h2><p>用户无法察觉 <code>301</code> 和 <code>302</code> 的区别，两者在功能上是相同的，所以选哪个重要吗？</p>
<p>答案很简单：搜索引擎对待 <code>301</code> 重定向和 <code>302</code> 重定向的方式不同，选择错误的重定向可能会导致 <code>SEO</code> 问题，所以选哪个很重要。</p>
<p>如果你要将内容永久移动到新位置，请使用 <code>301</code> 重定向，如果你只是暂时移动它，请使用 <code>302</code> 重定向。</p>
<p>选择很简单，但要了解的东西有很多。</p>
<h2 id="未使用重定向，旧网址和新网址同时存在，有什么不好？"><a href="#未使用重定向，旧网址和新网址同时存在，有什么不好？" class="headerlink" title="未使用重定向，旧网址和新网址同时存在，有什么不好？"></a>未使用重定向，旧网址和新网址同时存在，有什么不好？</h2><ul>
<li><code>重复内容</code>: google 不喜欢<code>重复内容</code>，因此当<code>旧网址</code>和<code>新网址</code>的内容相同时，且<code>旧网址</code>尚未被移除、<code>新网址</code>已经被收录的这段时间内，很有可能被 google 认定你的网址存在大量重复内容，会导致网址质量下降，最坏的情况是可能受到排名惩罚。</li>
<li><code>不能继承旧 SEO 排名</code>：通过重定向，能够保留原始地址的 SEO 排名效果，让新网址<code>继承旧网址 SEO 排名</code>。</li>
</ul>
<h2 id="为什么大公司不愿意翻新老旧架构的网站？"><a href="#为什么大公司不愿意翻新老旧架构的网站？" class="headerlink" title="为什么大公司不愿意翻新老旧架构的网站？"></a>为什么大公司不愿意翻新老旧架构的网站？</h2><p>由于 HTML 的语义化、网站的加载速度、重要内容的前后顺序等跟网站架构相关的东西，都会影响 SEO 的排名，导致变更网站后所需复原的成本过大，需要重定向的节点太多，大公司不希望因变更而导致失去搜索引擎的流量与排名，因此一动不如一静。</p>
<h3 id="前端-SEO-需要注意哪些"><a href="#前端-SEO-需要注意哪些" class="headerlink" title="前端 SEO 需要注意哪些"></a>前端 SEO 需要注意哪些</h3><ul>
<li>语义化的 HTML 代码，符合 W3C 规范，语义化代码让搜索引擎容易理解网页</li>
<li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li>
<li>非装饰性图片必须加 alt</li>
<li>合理的 <code>title</code>、<code>description</code>、<code>keywords</code><ul>
<li>搜索对着三项的权重逐个减小，<code>title</code> 值强调重点即可，重要关键词出现不要超过 <code>2</code> 次，而且要靠前，不同页面 <code>title</code> 要有所不同。</li>
<li><code>description</code> 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 <code>description</code> 有所不同。</li>
<li><code>keywords</code> 列举出重要关键词即可。</li>
</ul>
</li>
<li>重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li>
<li>重要内容不要用 js 输出：爬虫不会执行 js 获取内容</li>
<li>少用 iframe：搜索引擎不会抓取 iframe 中的内容</li>
</ul>
<h2 id="301-重定向"><a href="#301-重定向" class="headerlink" title="301 重定向"></a>301 重定向</h2><p>301 重定向的意思是 <code>将网址永久的移动到新的 URL</code>。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p>网页或网站的链接更换新的主域名</p>
</li>
<li><p>某个网站中的网页已删除，但搜索引擎中还存在其内容</p>
</li>
<li><p>当你从 HTTP 切换到 HTTPS 时</p>
</li>
<li><p>永久合并两个或多个页面或网站时</p>
</li>
<li><p>二级域名跳转到主域名，集聚网站的权重</p>
</li>
<li><p>非法的黑帽 SEO（新网址和旧网址的内容并不是高度一致）</p>
</li>
</ul>
<h2 id="302-重定向"><a href="#302-重定向" class="headerlink" title="302 重定向"></a>302 重定向</h2><p>302 重定向的意思是<code>将网址临时移动到新的 URL</code>，302 重定向使用较少，但都是非常具体和个性化的情景：</p>
<h3 id="使用特例"><a href="#使用特例" class="headerlink" title="使用特例"></a>使用特例</h3><ul>
<li><p>网站发生故障时，给出新的临时地址让用户访问</p>
</li>
<li><p>临时测试网站的新功能或网站页面时</p>
</li>
<li><p>A &#x2F; B Test</p>
</li>
<li><p>网站需要长时间的维护和修改时</p>
</li>
<li><p>网站收录作弊时</p>
</li>
<li><p>你希望在不影响旧页面排名的情况下获得新页面的反馈时</p>
</li>
<li><p>当你正在进行促销，并希望暂时将访问者重定向到促销页面时</p>
</li>
</ul>
<h2 id="Google-如何处理-301-和-302-重定向"><a href="#Google-如何处理-301-和-302-重定向" class="headerlink" title="Google 如何处理 301 和 302 重定向"></a>Google 如何处理 301 和 302 重定向</h2><p>由于 <code>301</code> 和 <code>302</code> 重定向的功能与最终用户相同，因此选择使用哪种重定向主要取决于 <code>Google</code> 如何对待它们，这里我们来看看谷歌的<code>索引化</code>。</p>
<h3 id="索引化"><a href="#索引化" class="headerlink" title="索引化"></a>索引化</h3><p>当一个 URL 重定向到另一个 URL 时，Google 只会保留其中一个 URL 的<code>索引</code>。</p>
<h4 id="对于-301-重定向"><a href="#对于-301-重定向" class="headerlink" title="对于 301 重定向"></a>对于 301 重定向</h4><p><code>Google</code> 会索引新页面，并把旧页面的索引取消。 这是因为 <code>301</code> 重定向会告诉 <code>Google</code> 这是一个永久性的移动，因此没有必要保留旧的 URL 索引</p>
<p>例如，很多年前，Moz 将域名 <code>seomoz.org</code> 更改并重定向到了 <code>moz.com</code>,直接搜索关键字<code>seomoz.org</code>，就会搜到新域名——<code>moz.com</code></p>
<p><img data-src="https://chao31.github.io/pics/githubIo/search1_20220529145420.png"></p>
<p>但通过<code>site:</code>搜索，会搜到旧的域名，因为<code>site:searches</code> 不会告诉你 URL 是否被索引</p>
<p><img data-src="https://chao31.github.io/pics/githubIo/search2_20220529145622.png"></p>
<h4 id="对于-302-重定向"><a href="#对于-302-重定向" class="headerlink" title="对于 302 重定向"></a>对于 302 重定向</h4><p><code>Google</code> 只会索引旧页面。</p>
<p> 然而，由于 <code>Google</code> 知道人们经常错误地使用 <code>302</code> 进行永久重定向，因此他们实际上会单独评估每个 <code>302</code> 重定向，以试图确定你的真正目的。</p>
<blockquote>
<p>当我们识别到一个重定向并看到它是 302 时，我们首先假定它是一个临时重定向，并假定你想要为初始 URL 编制索引，而不是为了重定向。 […] 然而，当我们意识到它实际上更像是一个永久重定向，302 可能是你不小心设置的，那么我们会将其视为 301。我们不会为此 URL 编制索引， 而将为重定向目标建立索引。</p>
<div style='display: flex; align-items: center'>
    <img data-src='https://ahrefs.com/blog/wp-content/uploads/2018/01/john-mueller.png' width = '40px' height = '40px' style='display: inline-block; border-radius: 40px;margin-right: 1rem'/>
    <span>John Mueller, Webmaster Trends Analyst Google</span>
  </div>
</blockquote>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在大多数的情況之下，301 重定向网址或许是最适合你的重定向类型，因为 301 重定向能确保你的 SEO 排名不会在网站架构的变更中失去。</p>
<p>但如果你希望的效果是类似<code>A/B Test</code>这样的测试，那么这一类的短暂导向引流就是你所需要采用的，这种情况就千万不要使用 301 ，以免影响你原本的网址 SEO 排名。</p>
<p>如果我们碰巧使用了错误的重定向类型 302，Google 的<code>索引化</code>会通过对 302 的单独评估，最终明白你的真实意图，那是否任何情况下都去使用 302 呢？当然不是，因为 Google 并不总是足够聪明，我们能确保万无一失吗？</p>
<p>所以最佳做法还是尽可能的选用正确的重定向类型。</p>
<p>参考：</p>
<ol>
<li><a href="https://ahrefs.com/blog/zh/301-vs-302-redirects/">SEO 的 301 和 302 重定向：应该使用哪个？</a></li>
<li><a href="https://seo.whoops.com.tw/301-vs-302-redirects/">301 與 302 重定向轉址：哪一個對 SEO 更友善？</a></li>
<li><a href="https://www.feiniaomy.com/post/531.html">301 与 302 重定向对 SEO 的影响</a></li>
</ol>
]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>SEO</tag>
        <tag>301 和 302</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建git服务器</title>
    <url>/2017/09/13/git/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="ubuntu安装git"><a href="#ubuntu安装git" class="headerlink" title="ubuntu安装git"></a>ubuntu安装git</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line">sudo apt-get install git</span><br><span class="line"></span><br><span class="line"><span class="comment">// git仓库配置</span></span><br><span class="line">git config --<span class="variable language_">global</span> user.<span class="property">name</span> <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">git config --<span class="variable language_">global</span> user.<span class="property">email</span> <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="在Ubuntu上创建git用户"><a href="#在Ubuntu上创建git用户" class="headerlink" title="在Ubuntu上创建git用户"></a>在Ubuntu上创建git用户</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sudo adduser git</span><br></pre></td></tr></table></figure>
<p>这样在&#x2F;home目录下就多了一个git目录</p>
<h2 id="在git用户下创建-ssh-目录"><a href="#在git用户下创建-ssh-目录" class="headerlink" title="在git用户下创建.ssh 目录"></a>在git用户下创建.ssh 目录</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cd /home/git</span><br><span class="line">mkdir .<span class="property">ssh</span></span><br><span class="line">cd .<span class="property">ssh</span></span><br><span class="line">vi authorized_keys</span><br></pre></td></tr></table></figure>
<p>将本地~&#x2F;.ssh 里的id_rsa.pub中的内容添加到服务器端的authorized_keys<br><img data-src="https://upload-images.jianshu.io/upload_images/3770183-1e0b47505c13aea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="初始化一个git仓库"><a href="#初始化一个git仓库" class="headerlink" title="初始化一个git仓库"></a>初始化一个git仓库</h2><p>在opt下建一个git目录，以后git的仓库都放在这个目录</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cd /opt</span><br><span class="line">mkdir git</span><br><span class="line">chown -R <span class="attr">git</span>:git git  <span class="comment">//修改git目录的拥有者</span></span><br><span class="line">chmod <span class="number">777</span> git</span><br><span class="line">cd git</span><br></pre></td></tr></table></figure>
<blockquote>
<p>&#x2F;&#x2F; chown将指定文件的拥有者改为指定的用户或组<br>chown -R 用户名:组名 文件</p>
</blockquote>
<p>初始化一个project仓库，一般以.git结尾进行命名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mkdir project.<span class="property">git</span> </span><br><span class="line">cd project.<span class="property">git</span></span><br><span class="line">git --bare init</span><br></pre></td></tr></table></figure>
<h2 id="本地进行代码推送"><a href="#本地进行代码推送" class="headerlink" title="本地进行代码推送"></a>本地进行代码推送</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 在 本地 的电脑上</span><br><span class="line">cd myproject</span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;initial commit&#x27;</span></span><br><span class="line">git remote add origin git@<span class="attr">gitserver</span>:<span class="regexp">/opt/gi</span>t/project.<span class="property">git</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>若因权限问题推送失败，则可能是文件夹所有者问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 修改服务器project.<span class="property">git</span>仓库的所有者</span><br><span class="line">chown -R <span class="attr">git</span>:git project.<span class="property">git</span></span><br></pre></td></tr></table></figure>
<h2 id="node-安装"><a href="#node-安装" class="headerlink" title="node 安装"></a>node 安装</h2><ol>
<li>去node官网，找到对应版本链接</li>
<li><code>wget https://nodejs.org/dist/v10.15.0/node-v10.15.0-linux-x64.tar.xz</code></li>
<li>mv到对应目录，如&#x2F;opt&#x2F;</li>
<li>解压<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tar -xvf   node-v10<span class="number">.15</span><span class="number">.0</span>-linux-x64.<span class="property">tar</span>.<span class="property">xz</span></span><br><span class="line">mv node-v10<span class="number">.15</span><span class="number">.0</span>-linux-x64.<span class="property">tar</span>.<span class="property">xz</span> nodejs </span><br></pre></td></tr></table></figure></li>
<li>确认一下nodejs下bin目录是否有node 和npm文件，如果有则执行软连接，变为全局<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ln -s /opt/nodejs/bin/npm /usr/local/bin/ </span><br><span class="line">ln -s /opt/nodejs/bin/node /usr/local/bin/</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie篇</title>
    <url>/2019/11/21/http/cookie%E7%AF%87/</url>
    <content><![CDATA[<h2 id="什么是cookie"><a href="#什么是cookie" class="headerlink" title="什么是cookie?"></a>什么是cookie?</h2><ol>
<li><p>第一次访问服务器的时候，会在<code>响应头</code>里面看到Set-Cookie信息（只有在首次访问服务器的时候才会在<code>响应头</code>中出现该信息）,如：<br>Set-Cookie:JSESSIONID&#x3D;joadjosd</p>
</li>
<li><p>浏览器会根据响应头的set-cookie信息设置浏览器的cookie并保存到浏览器本地</p>
</li>
<li><p>当再次请求的时候（非首次请求），浏览器会在请求头里将cookie发送给服务器(每次请求都是这样)，如：<br>将上面保存的 JSESSIONID&#x3D;joadjosd 发给服务器</p>
</li>
</ol>
<h2 id="什么是JSESSIONID？"><a href="#什么是JSESSIONID？" class="headerlink" title="什么是JSESSIONID？"></a>什么是JSESSIONID？</h2><ol>
<li><p>当用户访问服务器的时候，服务器会为每一个用户开启一个session,浏览器是怎么判断这个session到底是属于哪个用户呢？JSESSIONID的作用就体现出来了：JSESSIONID就是用来判断当前用户对应于哪个session，换句话说JSESSIONID会告诉服务器该浏览器的session保存在服务器内存的什么地方。</p>
</li>
<li><p>服务器首先检查这个浏览器的请求里是否已包含了一个session标识————称为session id，如果已包含则说明以前已经为此浏览器创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个）；如果浏览器请求不包含session id，则为此浏览器创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给浏览器保存。</p>
</li>
<li><p>保存这个session id的方式可以采用cookie，这样浏览器在下次请求中，会把包含这个session id的cookie发送给服务器。</p>
</li>
<li><p>一般这个cookie的名字都是类似于SESSIONID，JSESSIONID只是tomcat的对session id的叫法，其实就是session id，在其它的容器也许就不叫JSESSIONID了。</p>
</li>
</ol>
<h2 id="创建cookie"><a href="#创建cookie" class="headerlink" title="创建cookie"></a>创建cookie</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setCookie</span>(<span class="params">name,value,cookieDomain</span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">cookie</span> = name + <span class="string">&#x27;=&#x27;</span>+ <span class="built_in">encodeURIComponent</span>(value) + <span class="string">&#x27;;domain=&#x27;</span> + cookieDomain + <span class="string">&#x27;;path=/&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除cookie"><a href="#删除cookie" class="headerlink" title="删除cookie"></a>删除cookie</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除 cookie 非常简单。您只需要设置 expires 参数为以前的时间即可</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">delCookie</span>(<span class="params">name</span>) &#123;  </span><br><span class="line">  <span class="keyword">var</span> exp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  exp.<span class="title function_">setTime</span>(exp.<span class="title function_">getTime</span>() - <span class="number">1</span>);  </span><br><span class="line">  <span class="keyword">var</span> cookie = <span class="title function_">getCookie</span>(name);  </span><br><span class="line">  cookie &amp;&amp; (<span class="variable language_">document</span>.<span class="property">cookie</span> = name + <span class="string">&#x27;=&#x27;</span> + cookie + <span class="string">&#x27;;expires=&#x27;</span> + exp.<span class="title function_">toGMTString</span>()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="cookie属性"><a href="#cookie属性" class="headerlink" title="cookie属性"></a>cookie属性</h2><p>| 属性项 |	属性项介绍 |<br>|—<br>| NAME&#x3D;VALUE |	键值对，可以设置要保存的 Key&#x2F;Value，注意这里的 NAME 不能和其他属性项的名字一样<br>| Expires | 过期时间，在设置的某个时间点后该 Cookie 就会失效<br>| Domain	| 生成该 Cookie 的域名，如 domain&#x3D;”<a href="http://www.baidu.com/">www.baidu.com</a>“<br>| Path	| 该 Cookie 是在当前的哪个路径下生成的，如 path&#x3D;&#x2F;wp-admin&#x2F;<br>| Secure	| 如果设置了这个属性，那么只会在 SSH 连接时才会回传该 Cookie</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>1.<a href="https://blog.csdn.net/tanga842428/article/details/78600940">JSESSIONID的简单说明</a><br>2.<a href="https://www.cnblogs.com/caiwenjing/p/8081391.html">cookie、session、sessionid 与jsessionid</a><br>3.<a href="https://www.jianshu.com/p/6fc9cea6daa2">深入理解Cookie</a><br>4.<a href="https://www.runoob.com/js/js-cookies.html">javascript cookie</a></p>
]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>https原理</title>
    <url>/2018/12/03/http/https%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="TCP-x2F-IP协议簇"><a href="#TCP-x2F-IP协议簇" class="headerlink" title="TCP&#x2F;IP协议簇"></a>TCP&#x2F;IP协议簇</h2><p><img data-src="/2018/12/03/http/https%E5%8E%9F%E7%90%86/2.jpg"></p>
<blockquote>
<p> <code>TCP/IP协议簇</code>是协议的集合，包含上图等协议，http协议就是它的一个子集；TCP&#x2F;IP协议并不完全符合OSI的七层参考模型，它采用了4层的层级结构，如下图。</p>
</blockquote>
<p><img data-src="/2018/12/03/http/https%E5%8E%9F%E7%90%86/1.jpg"></p>
<ul>
<li><p><code>http协议</code>处于<code>应用层</code>，当客户端发送http请求，为了便于传输，<code>传输层</code>（TCP协议）将应用层的http报文进行切割，并在各个报文上打上标记序号及端口号，转发给<code>网络层</code>（IP协议），<code>网络层</code>增加目的地——<code>MAC地址</code>后转发给<code>链路层</code>，这样发送网络的请求准备就齐全了；服务器端在<code>链路层</code>接收到数据，按顺序往上发送，一直到<code>应用层</code>，这样才算真正接收到http请求。</p>
</li>
<li><p>发送端在曾与层之间传输数据时，每经过一层必定会被打上一个该层所属的<code>首部信息</code>，反之，服务器端在接收时会一层一层的去掉<code>首部信息</code>，这种把数据信息包装起来的方法叫做<code>封装</code>。</p>
</li>
<li><p>为了确认数据送到目标处，TCP协议采用了三次握手的策略，握手的过程中使用了TCP标志（flag）——<code>SYN</code>和<code>ACK</code>：发送端首先发送一个带有<code>SYN</code>的标志给对方，接收端收到后，发送一个<code>SYN/ACK</code>标志的数据包，表示确认收到，最后，发送端再发送一个<code>ACK</code>标志的数据包，代表“握手”结束。<br><img data-src="/2018/12/03/http/https%E5%8E%9F%E7%90%86/3.jpg"></p>
</li>
</ul>
<hr>
<h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><blockquote>
<p><code>HTTP协议</code>（HyperText Transfer Protocol，超文本传输协议）：是客户端与Web服务器之间的应用层通信协议。</p>
</blockquote>
<h3 id="http协议的不足"><a href="#http协议的不足" class="headerlink" title="http协议的不足"></a>http协议的不足</h3><ul>
<li>通信使用明文（不加密），内容有可能被窃听</li>
<li>不验证通信双方的身份，有可能遭遇伪装</li>
<li>无法证明报文的完整性，所以有可能已遭篡改</li>
</ul>
<hr>
<h2 id="https协议"><a href="#https协议" class="headerlink" title="https协议"></a>https协议</h2><blockquote>
<p><code>HTTPS 协议</code>（HyperText Transfer Protocol over Secure Socket Layer）：可以理解为HTTP+SSL&#x2F;TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。</p>
</blockquote>
<p><img data-src="/2018/12/03/http/https%E5%8E%9F%E7%90%86/4.jpg"><br>如上图，HTTPS 相比 HTTP 多了一层 SSL&#x2F;TLS，位于应用层与TCP协议之间。</p>
<h3 id="http请求劫持"><a href="#http请求劫持" class="headerlink" title="http请求劫持"></a>http请求劫持</h3><p>HTTP请求过程中，客户端与服务器之间没有任何身份确认的过程，数据全部明文传输，“裸奔”在互联网上，所以很容易遭到黑客的攻击，如下：<br><img data-src="/2018/12/03/http/https%E5%8E%9F%E7%90%86/5.png"></p>
<hr>
<h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><ol>
<li><code>对称加密</code>：加密和解密都是使用的同一个密钥——<code>对称密钥</code>。</li>
<li><code>非对称加密</code>: 加密和解密使用不同的密钥——<code>公钥</code>、<code>私钥</code>，<code>公钥</code>和<code>算法</code>都是公开的，<code>私钥</code>是保密的，用<code>公钥</code>加密，就可以用<code>私钥</code>解密，反之亦然；但<code>公钥</code>是公开的（黑客也有<code>公钥</code>），如果<code>私钥</code>加密的信息被黑客截获，黑客同样可以使用<code>公钥</code>进行解密，获取其中的内容，所以使用非对称加密，通信双方通常有两套<code>私钥</code>和<code>公钥</code>，发消息的一方使用对方的<code>公钥</code>进行加密，接收消息的一方使用自己的<code>私钥</code>解密（所以<code>私钥</code>可以认为是个人身份的证明）；非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。</li>
<li><code>消息摘要</code>：<code>消息摘要</code>是<code>哈希</code>算法的一种，可以将消息<code>哈希</code>转换成一个固定长度的值唯一的字符串。值唯一的意思是不同的消息转换的<code>摘要</code>是不同的，并且能够确保唯一。该过程不可逆，即不能通过<code>摘要</code>反推<code>明文</code>（似乎SHA1已经可以被破解了，SHA2还没有。一般认为不可破解，或者破解需要耗费太多时间，性价比低）。</li>
<li><code>数字签名</code>： 签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过;hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改,举例如下：<br>假设现在有通信双方A和B，两者之间使用两套非对称加密机制,现在A向B发消息:<br><img data-src="/2018/12/03/http/https%E5%8E%9F%E7%90%86/9.png"><br>那么，如果在发送过程中，有人修改了里面密文消息，B拿到的密文，解密之后得到明文，并非A所发送的，信息不正确。<br>要解决两个问题：1. A的身份认证 2. A发送的消息完整性 那么就要用到上面所讲的基础知识。<br>数字签名的过程如下图：<br><img data-src="/2018/12/03/http/https%E5%8E%9F%E7%90%86/10.png"><br>简单解释：<br>A：将明文进行摘要运算后得到摘要（消息完整性），再将摘要用A的私钥加密（身份认证），得到数字签名，将密文和数字签名一块发给B。<br>B：收到A的消息后，先将密文用自己的私钥解密，得到明文。将数字签名用A的公钥进行解密后，得到正确的摘要（解密成功说明A的身份被认证了）。<br>对明文进行摘要运算，得到实际收到的摘要，将两份摘要进行对比，如果一致，说明消息没有被篡改（消息完整性）。<br>疑问：<br>摘要使用A的私钥加密，如果被拥有A的公钥的第三者截获，不就可以获取到摘要了么，会不会对安全造成威胁？<br>答：不会，因为摘要是不可逆推出原文的。</li>
</ol>
<h3 id="HTTP-向-HTTPS-演化"><a href="#HTTP-向-HTTPS-演化" class="headerlink" title="HTTP 向 HTTPS 演化"></a>HTTP 向 HTTPS 演化</h3><h4 id="使用对称加密"><a href="#使用对称加密" class="headerlink" title="使用对称加密"></a>使用对称加密</h4><p>若对传输的信息加密,这样即使黑客截获，也无法破解<br><img data-src="/2018/12/03/http/https%E5%8E%9F%E7%90%86/6.png"><br>此种方式属于<code>对称加密</code>，双方拥有相同的密钥，信息得到安全传输，但此种方式的缺点是：</p>
<ol>
<li>因为双方都要有<code>密钥</code>，所以若是客户端有了一个<code>密钥</code>，如何安全地给服务器也传送一把</li>
<li>客户端、服务器数量多，安全级别也不同，<code>密钥</code>极易泄露</li>
</ol>
<p>所以试一试非对称加密</p>
<hr>
<h4 id="使用非对称加密"><a href="#使用非对称加密" class="headerlink" title="使用非对称加密"></a>使用非对称加密</h4><p><img data-src="/2018/12/03/http/https%E5%8E%9F%E7%90%86/7.png"><br>如上图所示，它只使用了一套<code>公钥</code>和<code>私钥</code>，客户端用公钥对请求内容加密，服务器使用<code>私钥</code>对内容解密，同理，服务器使用<code>私钥</code>加密，客户端可以使用<code>公钥</code>解密，所以缺点就出来了：<code>公钥</code>是公开的（也就是黑客也会有<code>公钥</code>），所以第4步是不安全的，如果<code>私钥</code>加密的信息被黑客截获，黑客同样可以使用<code>公钥</code>进行解密，获取其中的内容。</p>
<p>但第3步是安全的，所以可以利用<code>非对称加密</code>的第3步，再结合<code>对称加密</code>的方式，一起实现加密。</p>
<hr>
<h4 id="对称与非对称加密的结合"><a href="#对称与非对称加密的结合" class="headerlink" title="对称与非对称加密的结合"></a>对称与非对称加密的结合</h4><p><img data-src="/2018/12/03/http/https%E5%8E%9F%E7%90%86/8.png"></p>
<ol>
<li>第3步使用的是<code>非对称加密</code>，客户端用<code>公钥</code>加密，将<code>对称加密算法</code>和<code>对称密钥</code>传输给了服务器</li>
<li>服务器收到信息后，用<code>私钥</code>解密，提取出<code>对称加密算法</code>和<code>对称密钥</code>，这时客户端和服务器端都有了<code>对称密钥</code></li>
<li>从第4步开始，双方都使用<code>对称加密</code>进行通信</li>
</ol>
<p>这种方式的问题：</p>
<ol>
<li>客户端如何获得公钥</li>
<li>如何确认服务器是真实的而不是黑客</li>
</ol>
<p>所以有了数字证书，服务器需要申购<code>SSL证书</code></p>
<hr>
<h4 id="SSL证书校验"><a href="#SSL证书校验" class="headerlink" title="SSL证书校验"></a>SSL证书校验</h4><p><img data-src="/2018/12/03/http/https%E5%8E%9F%E7%90%86/11.png"><br>如上图所示，在第2步时服务器发送了一个SSL证书给客户端，SSL 证书中包含的具体内容有：</p>
<ol>
<li>证书的发布机构CA</li>
<li>证书的有效期</li>
<li>公钥</li>
<li>证书所有者</li>
<li>签名<br>…</li>
</ol>
<p>客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例说明如下：<br><img data-src="/2018/12/03/http/https%E5%8E%9F%E7%90%86/13.png"></p>
<ol>
<li>首先浏览器读取证书中的<code>证书所有者</code>、<code>有效期</code>等信息进行一一校验</li>
<li>浏览器的”证书管理器”，有”受信任的根证书颁发机构”列表,客户端会根据这张列表，比对服务器发来的证书中的<code>颁发者CA</code>，校验证书是否为<code>合法机构</code>颁发</li>
<li>如果找不到，浏览器就会报错，说明服务器发来的<code>证书</code>是<code>不可信任</code>的。</li>
<li>如果找到，那么浏览器就会从操作系统中取出<code>颁发者CA</code>的<code>公钥</code>，然后对服务器发来的<code>证书</code>里面的<code>签名</code>进行<code>解密</code></li>
<li>浏览器使用相同的<code>摘要</code>算法计算出服务器发来的<code>证书</code>的<code>摘要</code>，将这个计算的<code>摘要</code>与证书<code>签名</code>解密出的<code>摘要</code>做对比</li>
<li>对比结果一致，则证明服务器发来的<code>证书</code>合法，没有被冒充</li>
<li>此时浏览器就可以读取证书中的<code>公钥</code>，用于后续加密了</li>
</ol>
<p>所以通过发送SSL证书的形式，既解决了公钥获取问题，又解决了黑客冒充问题，一箭双雕，HTTPS加密过程也就此形成<br>所以相比HTTP，HTTPS 传输更加安全</p>
<ol>
<li>所有信息都是加密传播，黑客无法窃听。</li>
<li>具有校验机制，一旦被篡改，通信双方会立刻发现。</li>
<li>配备身份证书，防止身份被冒充。</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，相比 HTTP 协议，HTTPS 协议增加了很多握手、加密解密等流程，虽然过程很复杂，但其可以保证数据传输的安全。所以在这个互联网膨胀的时代，其中隐藏着各种看不见的危机，为了保证数据的安全，维护网络稳定，建议大家多多推广HTTPS。<br>HTTPS 缺点：</p>
<ol>
<li>SSL 证书费用很高，以及其在服务器上的部署、更新维护非常繁琐</li>
<li>HTTPS 降低用户访问速度（多次握手）</li>
<li>网站改用HTTPS 以后，由HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用302跳转）</li>
<li>HTTPS 涉及到的安全算法会消耗 CPU</li>
</ol>
<p>本文转载自 <a href="http://www.4hou.com/info/news/4067.html">HTTPS 加密算法原理详解</a>，增加了少量自己的归纳、理解<br>参考：</p>
<ol>
<li>《图解HTTP协议》</li>
<li><a href="https://www.cnblogs.com/SirSmith/p/4985571.html">数字签名原理简介</a></li>
</ol>
]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>Component 与 PureComponent 解析</title>
    <url>/2022/05/29/react/Component%E4%B8%8EPureComponent%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>有啥不对的请多多指教，研究的不算很深，记录为了分享，也为了博采众长，完善知识。</p>
<p>官方文档</p>
<blockquote>
<p><code>React.PureComponent</code> 与 <code>React.Component</code> 很相似。两者的区别在于 <code>React.Component</code> 并未实现 <code>shouldComponentUpdate()</code>，而 <code>React.PureComponent </code>中以浅层对比 <code>prop</code> 和 <code>state</code> 的方式来实现了该函数。</p>
</blockquote>
<p>官方解释也很容易理解，<code>React.PureComponent</code> 比 <code>React.Component</code> 中多实现了一个方法，就导致了在组件数据发生变化时，<code>React.PureComponent</code> 会先进行和上一次的比较，如果相同，就不会再继续更新了。</p>
<p>口说无凭，还是得通过代码来体会。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h3 id="先看两者相同得地方"><a href="#先看两者相同得地方" class="headerlink" title="先看两者相同得地方"></a>先看两者相同得地方</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Box1 update&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Box1: &#123;this.props.count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Box2 update&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Box2: &#123;this.props.count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;parent update&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Box1</span> <span class="attr">count</span>=<span class="string">&#123;count&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Box2</span> <span class="attr">count</span>=<span class="string">&#123;count&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时，点击 <code>button</code> 按钮的时候，上述 2 个 <code>Box</code> 组件都会进行更新。<br><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ab3786a2c6e4291b42ea0a74c82925f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"><br>这也是最基础的组件更新。</p>
<h3 id="取消外部数据引入"><a href="#取消外部数据引入" class="headerlink" title="取消外部数据引入"></a>取消外部数据引入</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Box1 update&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Box1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Box2 update&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Box2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;parent update&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Box1</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Box2</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>取消 <code>Box</code> 组件内对外部 <code>count</code> 的引入</p>
<p>此时页面更新为</p>
<p><img data-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ee68b83f2ab45569330aaff58bee7dc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"></p>
<p>此时会发现只有 <code>Box1</code> 重新刷新了一遍，而 <code>Box2</code> 未重新加载组件，也就是 <code>PureComponent</code> 内部做了浅比较相同的不会进行更新。</p>
<h3 id="为什么被称为浅比较"><a href="#为什么被称为浅比较" class="headerlink" title="为什么被称为浅比较"></a>为什么被称为浅比较</h3><p><code>浅比较</code>是指对值类型进行比较，而稍微复杂一点的引用类型（Object）,就无法进行判断了，react 内部的更新都是浅比较。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title class_">React</span>.<span class="title function_">useState</span>(&#123; <span class="attr">num</span>: <span class="number">1</span> &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;parent update&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">click</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> newCount = count;</span><br><span class="line">    newCount.<span class="property">num</span> = count.<span class="property">num</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="title function_">setCount</span>(newCount);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;update:&#x27;</span>, count)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Box1</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Box2</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;click&#125;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时，父组件内部的 <code>count</code> 为对象类型，此时进行更新时，页面不会触发任何更新，父组件也不会进行刷新（由于是引用类型，<code>newCount</code> 发生数据变化时，<code>count</code> 其实已经发生变化，但是页面并不会有任何的反应）。</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3f8a7dd3664439186401dd551d72f48~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"></p>
<p>由图可见，子组件和父组件并没有进行刷新，均未打印。</p>
<h2 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h2><p><code>const</code> 的不可变定义也是只对于值类型而言，对于引用类型，还是依然可变。上述代码云清并不会报错。</p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>上述的一切代码都是建立在父组件自身更新的基础上子组件才会刷新，如果我将 <code>setCount(count + 1)</code> 改为 <code>setCount(count + 0)</code>,那么，父组件本身不会进行刷新，子组件也就理所当然的不会有任何变化。</p>
<h3 id="另类的不更新"><a href="#另类的不更新" class="headerlink" title="另类的不更新"></a>另类的不更新</h3><p>这里的父组件刷新带动子组件刷新有一种例外的情况。代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Parent</span> = (<span class="params">&#123; children &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;parent update&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;children&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;box2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Parent</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Box1</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Box2</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Parent</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将父组件抽离出来，子组件以 <code>children</code> 的形式引入。</p>
<p>此时页面点击发生的变化为</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a244047e65994451ab298a979227e067~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"></p>
<p>会发现不管怎么点击，只有 Parent 组件进行刷新，子组件全部都毫无反应。</p>
<p>这个原因我不得而知，可能是因为 react 生成 dom 的时候问题，这个等待深入学习后再来解答。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>PureComponent</code> 多用于抽取本地缓存制作的下拉框组件或者是根据数据字典生成的展示组件，这种固定的组件基本在用户使用时不会有任何的变化，只在登录和页面加载最开始生成。</p>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>从 0 到 1 实现 React（一）实现 createElement 方法</title>
    <url>/2022/02/04/react/%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0React1/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul>
<li>本文是作者在读懂了大神<code>Rodrigo Pombo</code> 的<a href="https://pomb.us/build-your-own-react/">《Build your own React》</a>源码后，加上了自己的理解，以及做了少量修改后的实现，在这里再次感谢大神！🙏🏻</li>
<li>核心代码 200+ 🎉</li>
<li>fiber 架构的 react 🔥</li>
<li>通俗易懂，对标全网最简单的 react 实现 😍</li>
<li>构建工具选用 parcel，号称零配置</li>
<li>从零到一的实现一个 react</li>
<li>每篇文章在最后，都会附上当前章节源码 🌐</li>
<li><a href="https://github.com/chao31/Didact">github 源码</a></li>
</ul>
<h2 id="创建一个空项目"><a href="#创建一个空项目" class="headerlink" title="创建一个空项目"></a>创建一个空项目</h2><p>创建项目并初始化<code>package.json</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> Didact</span><br><span class="line">npm init -y </span><br></pre></td></tr></table></figure>

<h3 id="安装-parcel"><a href="#安装-parcel" class="headerlink" title="安装 parcel"></a>安装 parcel</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i -D parcel-bundler@^<span class="number">1.12</span><span class="number">.5</span></span><br></pre></td></tr></table></figure>
<p><strong>为了跟着教程走不会因版本问题报错，本文接下来的所有 npm 依赖都将带上版本号</strong></p>
<h3 id="新增-index-html-模板"><a href="#新增-index-html-模板" class="headerlink" title="新增 index.html 模板"></a>新增 index.html 模板</h3><p>添加 html 代码：</p>
<ul>
<li>根节点 <code>root</code></li>
<li>内联的方式引入 一个<code>index.js</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;theme-color&quot;</span> <span class="attr">content</span>=<span class="string">&quot;#000000&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Didact<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="添加入口-index-js"><a href="#添加入口-index-js" class="headerlink" title="添加入口 index.js"></a>添加入口 index.js</h3><p><code>index.js</code>里面是一段 JSX 代码</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功启动&#x27;</span>); </span><br></pre></td></tr></table></figure>

<h3 id="增加-script-命令"><a href="#增加-script-命令" class="headerlink" title="增加 script 命令"></a>增加 script 命令</h3><p>修改 package.json</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line"><span class="addition">+  &quot;start&quot;: &quot;parcel index.html&quot;,</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>执行 <code>npm start</code>，访问<code>http://localhost:1234/</code>, 会看到控制台打印<code>&quot;成功启动&quot; </code></p>
<h2 id="如何处理-JSX"><a href="#如何处理-JSX" class="headerlink" title="如何处理 JSX"></a>如何处理 JSX</h2><h3 id="什么是-jsx？"><a href="#什么是-jsx？" class="headerlink" title="什么是 jsx？"></a>什么是 jsx？</h3><p>如下就是一段 JSX 代码， <a href="https://zh-hans.reactjs.org/docs/introducing-jsx.html">具体请参考</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> profile = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;profile&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;profile-title&quot;</span>&gt;</span>title<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">className</span>=<span class="string">&quot;profile-content&quot;</span>&gt;</span>content<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    我是一段文本</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>接下来要将上面 <code>JSX</code> 代码转化为下面的<code>数据结构</code>来描述</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象来描述 jsx</span></span><br><span class="line"><span class="keyword">const</span> profile = &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">       <span class="attr">className</span>: <span class="string">&quot;profile&quot;</span>,</span><br><span class="line">       <span class="attr">children</span>: [</span><br><span class="line">           &#123;<span class="attr">type</span>: <span class="string">&#x27;span&#x27;</span>, <span class="attr">props</span>: &#123;…&#125;&#125;,</span><br><span class="line">           &#123;<span class="attr">type</span>: <span class="string">&#x27;h3&#x27;</span>, <span class="attr">props</span>: &#123;…&#125;&#125;,</span><br><span class="line">           <span class="string">&quot;我是一段文本&quot;</span></span><br><span class="line">       ],</span><br><span class="line">   &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="安装-babel-处理-JSX"><a href="#安装-babel-处理-JSX" class="headerlink" title="安装 babel 处理 JSX"></a>安装 babel 处理 JSX</h3><p>我们使用<code>@babel/preset-react</code>来转化 jsx，但同时需安装它所需要依赖——<code>babel-core</code>，所以整体安装命令如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i -D @babel/preset-react@^<span class="number">7.17</span><span class="number">.12</span> babel-core@^<span class="number">7.0</span><span class="number">.0</span>-bridge<span class="number">.0</span></span><br></pre></td></tr></table></figure>

<p>然后再根目录添加<code>.babelrc</code>文件：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;@babel/preset-react&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="comment">// 这样写，babel会调用 Didact.createElement函数 来递归生成 jsx对象</span></span><br><span class="line">        <span class="attr">&quot;pragma&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Didact.createElement&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><em>注意：我们在上面设置了<code>pragma</code>属性，它指定了<code>babel</code>通过调用<code>Didact.createElement</code>来递归JSX，从而生成上面的数据结构。</em></p>
<h3 id="测试-JSX-的转换"><a href="#测试-JSX-的转换" class="headerlink" title="测试 JSX 的转换"></a>测试 JSX 的转换</h3><p>将 index.js 的console打印改为上面的那段 JSX</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">- console.log(&#x27;成功启动&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ const profile = (</span></span><br><span class="line"><span class="addition">+   &lt;div className=&quot;profile&quot;&gt;</span></span><br><span class="line"><span class="addition">+     &lt;span className=&quot;profile-title&quot;&gt;title&lt;/span&gt;</span></span><br><span class="line"><span class="addition">+     &lt;h3 className=&quot;profile-content&quot;&gt;content&lt;/h3&gt;</span></span><br><span class="line"><span class="addition">+     我是一段文本</span></span><br><span class="line"><span class="addition">+   &lt;/div&gt;</span></span><br><span class="line"><span class="addition">+ );</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ console.log(&#x27;profile: &#x27;, profile);</span></span><br></pre></td></tr></table></figure>

<p>打开控制台，会看到如下错误提示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">ReferenceError</span>: <span class="title class_">Didact</span> is not defined</span><br><span class="line">    at <span class="title class_">Object</span>.<span class="property">parcelRequire</span>.<span class="property">index</span>.<span class="property">js</span> (index.<span class="property">js</span>:<span class="number">29</span>:<span class="number">3</span>)</span><br><span class="line">    at newRequire (<span class="title class_">Didact</span>.<span class="property">e31bb0bc</span>.<span class="property">js</span>:<span class="number">47</span>:<span class="number">24</span>)</span><br><span class="line">    at <span class="title class_">Didact</span>.<span class="property">e31bb0bc</span>.<span class="property">js</span>:<span class="number">81</span>:<span class="number">7</span></span><br><span class="line">    at <span class="title class_">Didact</span>.<span class="property">e31bb0bc</span>.<span class="property">js</span>:<span class="number">120</span>:<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>点击进入第一行错误定位，会跳转到源码出错的地方—— “Didact.createElement 未定义”，因为我们还未实现<code>Didact.createElement</code>,所以因找不到该函数而报错。</p>
<p>但在实现<code>createElement</code>方法前，我们先看看babel是如何处理jsx的。</p>
<h3 id="babel转换jsx的过程"><a href="#babel转换jsx的过程" class="headerlink" title="babel转换jsx的过程"></a>babel转换jsx的过程</h3><p>babel调用<code>Didact.createElement</code>转换jsx的过程如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> profile = <span class="title class_">Didact</span>.<span class="title function_">createElement</span>(</span><br><span class="line">  <span class="comment">// HTML 标签的类型</span></span><br><span class="line">  <span class="string">&quot;div&quot;</span>, </span><br><span class="line">  <span class="comment">// 该 HTML 标签的属性</span></span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">&quot;profile&quot;</span> &#125;, </span><br><span class="line">  <span class="comment">// 后面都该 HTML 标签的 children</span></span><br><span class="line">  <span class="comment">// 第一个 child</span></span><br><span class="line">  <span class="title class_">Didact</span>.<span class="title function_">createElement</span>(</span><br><span class="line">    <span class="string">&quot;span&quot;</span>, </span><br><span class="line">    &#123; <span class="attr">className</span>: <span class="string">&quot;profile-title&quot;</span> &#125;, </span><br><span class="line">    <span class="string">&quot;title&quot;</span></span><br><span class="line">  ), </span><br><span class="line">  <span class="comment">// 第二个 child</span></span><br><span class="line">  <span class="title class_">Didact</span>.<span class="title function_">createElement</span>(</span><br><span class="line">    <span class="string">&quot;h3&quot;</span>, </span><br><span class="line">    &#123; <span class="attr">className</span>: <span class="string">&quot;profile-content&quot;</span> &#125;, </span><br><span class="line">    <span class="string">&quot;content&quot;</span></span><br><span class="line">  ),</span><br><span class="line">  <span class="comment">// 第三个 child</span></span><br><span class="line">  <span class="string">&quot;我是一段文本&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;profile: &#x27;</span>, profile);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出，<code>@babel/preset-react</code>做了两件事情：</p>
<ul>
<li>将 JSX 代码转换成了参数，<code>type, props, ...children</code></li>
<li>将上面的参数传递给 Didact.createElement，并执行该函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Didact</span>.<span class="title function_">createElement</span>(</span><br><span class="line">  type,</span><br><span class="line">  [props],</span><br><span class="line">  [...children]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数说明：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// - type：标签类型，如：`div`、`span`、`h3`, </span></span><br><span class="line"><span class="comment">//        也可以是 React 组件 类型（class 组件或函数组件）</span></span><br><span class="line"><span class="comment">// - props: 该标签的属性，如`classname`, 若无则为 null</span></span><br><span class="line"><span class="comment">// - children：第 2、3...个参数，都是子元素，子元素又开始递归调用`React.createElement`</span></span><br></pre></td></tr></table></figure>

<h2 id="实现-createElement-方法"><a href="#实现-createElement-方法" class="headerlink" title="实现 createElement 方法"></a>实现 createElement 方法</h2><p>很简单，让<code>Didact.createElement</code> 返回一个含有 children 的树状结构，就实现了createElement</p>
<p>在index.js中添加：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+ function createElement(type, props, ...children) &#123;</span></span><br><span class="line"><span class="addition">+   return &#123;</span></span><br><span class="line"><span class="addition">+     type,</span></span><br><span class="line"><span class="addition">+     props: &#123;</span></span><br><span class="line"><span class="addition">+       ...props,</span></span><br><span class="line"><span class="addition">+       ...children,</span></span><br><span class="line"><span class="addition">+     &#125;</span></span><br><span class="line"><span class="addition">+   &#125;;</span></span><br><span class="line"><span class="addition">+ &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ const Didact = &#123;</span></span><br><span class="line"><span class="addition">+   createElement,</span></span><br><span class="line"><span class="addition">+ &#125;;</span></span><br><span class="line"></span><br><span class="line">const profile = (</span><br><span class="line">  &lt;div className=&quot;profile&quot;&gt;</span><br><span class="line">    &lt;span className=&quot;profile-title&quot;&gt;title&lt;/span&gt;</span><br><span class="line">    &lt;h3 className=&quot;profile-content&quot;&gt;content&lt;/h3&gt;</span><br><span class="line">    我是一段文本</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(&#x27;profile: &#x27;, profile);</span><br></pre></td></tr></table></figure>

<p>这样就实现了<code>createElement</code>方法。</p>
<p>但通过console打印发现，<code>children</code>中的所有元素，除了<code>文本节点</code>是<code>string</code>其它节点都是<code>对象</code>。</p>
<p>这里将文本节点也统一处理成对象，这样后面会少了很多<code>if、else</code>的判断。</p>
<p>将文本节点构建为<code>type：&#39;TEXT_ELEMENT&#39;</code>的对象，修改代码：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">function createElement(type, props, ...children) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type,</span><br><span class="line">    props: &#123;</span><br><span class="line">      ...props,</span><br><span class="line"><span class="deletion">-      ...children,</span></span><br><span class="line"><span class="addition">+      children: children.map(child =&gt;</span></span><br><span class="line"><span class="addition">+        typeof child === &quot;object&quot; ? child : createTextElement(child)</span></span><br><span class="line"><span class="addition">+      )</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+ function createTextElement(text) &#123;</span></span><br><span class="line"><span class="addition">+  return &#123;</span></span><br><span class="line"><span class="addition">+    type: &quot;TEXT_ELEMENT&quot;,</span></span><br><span class="line"><span class="addition">+    props: &#123;</span></span><br><span class="line"><span class="addition">+      nodeValue: text,</span></span><br><span class="line"><span class="addition">+      children: []</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+  &#125;;</span></span><br><span class="line"><span class="addition">+ &#125;</span></span><br><span class="line"></span><br><span class="line">const Didact = &#123;</span><br><span class="line">  createElement,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样我们就彻底完成了<code>createElement</code>方法</p>
<p><a href="https://github.com/chao31/Didact/blob/feature/chao31_createElement/index.js">本章源码</a></p>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>从 0 到 1 系列</tag>
      </tags>
  </entry>
  <entry>
    <title>React 文档</title>
    <url>/2020/10/12/react/react%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="ReactDOM-render的改变"><a href="#ReactDOM-render的改变" class="headerlink" title="ReactDOM.render的改变"></a>ReactDOM.render的改变</h2><h3 id="挂载dom的改变"><a href="#挂载dom的改变" class="headerlink" title="挂载dom的改变"></a>挂载dom的改变</h3><ul>
<li><p>Legacy Root API: 通过<code>ReactDOM.render</code>来挂载dom，其工作方式与 React 17 相同，但是会有红色warning警告，提示将被遗弃。</p>
</li>
<li><p>New Root API：通过<code>ReactDOM.createRoot</code>来挂载dom，可以使用<code>React 18</code>中的所有新特性。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;App&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// React 17</span></span><br><span class="line">- <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, container);</span><br><span class="line"></span><br><span class="line"><span class="comment">// React 18</span></span><br><span class="line">+ <span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(container);</span><br><span class="line">+ root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure>

<h3 id="渲染回调的改变"><a href="#渲染回调的改变" class="headerlink" title="渲染回调的改变"></a>渲染回调的改变</h3><ul>
<li><code>React 17</code> 通过给 render 传递一个回调函数，在组件被渲染或更新后调用；</li>
<li><code>React 18</code> 通过App 的 props传入回调函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;App&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// React 17</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(container, <span class="language-xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">tab</span>=<span class="string">&quot;home&quot;</span> /&gt;</span></span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;rendered&#x27;</span>).</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// React 18</span></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(container);</span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">callback</span>=<span class="string">&#123;()</span> =&gt;</span> console.log(&quot;renderered&quot;)&#125; /&gt;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react 原理</title>
    <url>/2022/03/25/react/react%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>React 的特点是 <strong>快速响应</strong> ，因为它解决了制约 <strong>快速响应</strong> 的两大因素：</p>
<ul>
<li><code>CPU 的瓶颈</code>：当项目变得庞大、组件数量繁多或遇到大量运算，js 会一直占用主线程，使得浏览器得不到控制权，就不能及时开始下一帧的绘制，从而导致页面的掉帧、卡顿。</li>
<li><code>IO 的瓶颈</code>：当发送网络请求后，由于需要等待数据返回才能进一步操作，导致不能快速响应。</li>
</ul>
<p>而 <code>fiber</code> 架构主要就是用来解决 <code>CPU</code> 和 <code>IO</code> 的瓶颈问题，这两个问题一直也是最影响前端开发体验的地方，前者会造成卡顿，后者会造成白屏。为此 react 引入了两个新概念：<code>Time Slicing</code> 时间分片和<code>Suspense</code>。</p>
<h2 id="CPU-的瓶颈"><a href="#CPU-的瓶颈" class="headerlink" title="CPU 的瓶颈"></a>CPU 的瓶颈</h2><p>大多数浏览器的<code>刷新频率</code>都是<code>60Hz</code>，即每（1000ms &#x2F; 60Hz）16.6ms 浏览器刷新一次。</p>
<p>在每 16.6ms 时间内，需要完成如下工作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">js脚本执行 -----  样式布局 ----- 样式绘制</span><br></pre></td></tr></table></figure>

<p>当 JS 执行脚本更新 dom 的时间过长，超出了 16.6ms，这次刷新就没有时间去执行<code>样式布局</code>和<code>样式绘制</code>了，页面就会出现掉帧，造成卡顿。</p>
<p>为了更加深入的理解这个问题，首先看一下浏览器的帧原理：</p>
<h3 id="浏览器帧原理"><a href="#浏览器帧原理" class="headerlink" title="浏览器帧原理"></a>浏览器帧原理</h3><p>页面的内容都是一帧一帧绘制出来的，浏览器刷新率代表浏览器一秒绘制多少帧。目前浏览器大多是 60Hz（60 帧&#x2F;s），每一帧耗时也就是在 16ms 左右。原则上说 1s 内绘制的帧数越多，画面表现就也越细腻。那么在这一帧的（16ms）过程中浏览器又干了啥呢？</p>
<p><img data-src="https://chao31.github.io/pics/FE-QA/anatomy-of-a-frame.svg" alt="图片 1"></p>
<p>通过上图可以清楚的知道，浏览器一帧会经过下面这几个过程：</p>
<ol>
<li>开始一帧</li>
<li>输入事件的处理：<code>touchmove</code>、<code>click</code>、<code>scroll</code>等都应该最先触发，每帧触发一次（但也不一定）</li>
<li>执行 <code>RequestAnimationFrame</code></li>
<li>布局（Layout）</li>
<li>绘制（Paint）</li>
<li>若还有时间，执行 <code>RequestIdelCallback</code></li>
<li>结束一帧</li>
</ol>
<p>其中，第六步的 <code>RequestIdelCallback</code> 事件不是每一帧结束都会执行，只有在一帧的 16ms 中做完了前面 6 件事儿且还有剩余时间，才会执行。这里提一下，如果一帧执行结束后还有时间执行 <code>RequestIdelCallback</code> 事件，那么下一帧需要在事件执行结束才能继续渲染，所以 <code>RequestIdelCallback</code> 执行不要超过 30ms，如果长时间不将控制权交还给浏览器，会影响下一帧的渲染，导致页面出现卡顿和事件响应不及时。</p>
<h3 id="如何解决-CPU-的瓶颈呢"><a href="#如何解决-CPU-的瓶颈呢" class="headerlink" title="如何解决 CPU 的瓶颈呢"></a>如何解决 CPU 的瓶颈呢</h3><p>答案是：在浏览器每一帧的时间中，预留一些时间给 JS 线程，React 利用这部分时间更新组件（源码中预留的初始时间是 5ms）。</p>
<p>当预留的时间不够用时，React 将线程控制权交还给浏览器，这样浏览器就有剩余时间执行<code>样式布局</code>和<code>样式绘制</code>，减少掉帧的可能性，而 React 则等待下一帧时间到来继续被中断的工作。</p>
<p>上面这种将将长任务分拆到每一帧中，像蚂蚁搬家一样一次执行一小段任务的操作，被称为时间切片（time slice）。所以，解决 CPU 瓶颈的关键是实现时间切片，而时间切片的关键是：将<code>同步的更新</code>变为<code>可中断的异步更新</code>。</p>
<h2 id="react-15-为什么不能做到快速响应"><a href="#react-15-为什么不能做到快速响应" class="headerlink" title="react 15 为什么不能做到快速响应"></a>react 15 为什么不能做到快速响应</h2><p>在 React 16 以前，Reconciler 采用递归的方式创建虚拟 DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。为什么 react 15 不能做到快速响应，首先来看一下 react 15 的架构：</p>
<h3 id="React-15-架构"><a href="#React-15-架构" class="headerlink" title="React 15 架构"></a>React 15 架构</h3><p>React 15 架构可以分为两层：</p>
<ul>
<li>Reconciler（协调器）—— 负责找出变化的组件</li>
<li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li>
</ul>
<h4 id="Reconciler（协调器）"><a href="#Reconciler（协调器）" class="headerlink" title="Reconciler（协调器）"></a>Reconciler（协调器）</h4><p>当调用 <code>this.setState</code>、<code>ReactDOM.render</code>等 API 会触发更新，<code>Reconciler</code> 会做如下工作：</p>
<ul>
<li>执行函数组件、或 class 组件的 render 方法，将返回的 JSX 转化为虚拟 DOM</li>
<li>将虚拟 DOM 和上次更新时的虚拟 DOM 对比</li>
<li>通过<code>递归对比</code>找出本次更新中变化的虚拟 DOM</li>
<li>通知 <code>Renderer</code> 将变化的虚拟 DOM 渲染到页面上</li>
</ul>
<h4 id="Renderer（渲染器）"><a href="#Renderer（渲染器）" class="headerlink" title="Renderer（渲染器）"></a>Renderer（渲染器）</h4><p>常见的 <code>Renderer</code>：</p>
<ul>
<li><code>ReactDOM</code>：渲染浏览器环境</li>
<li><code>ReactNative</code>：渲染 App 原生组件</li>
<li><code>ReactTest</code>：用于测试</li>
</ul>
<p>在每次更新发生时，Renderer 接到 Reconciler 通知，将变化的组件渲染在当前宿主环境。</p>
<h3 id="React-15-架构的缺点"><a href="#React-15-架构的缺点" class="headerlink" title="React 15 架构的缺点"></a>React 15 架构的缺点</h3><p>React 15 会使用递归进行更新，由于递归一旦开始，中途就无法中断。当层级很深时，递归更新时间超过了 16ms，用户交互就会卡顿。</p>
<p>所以 react 16 将<code>同步的更新</code>变为<code>可中断的异步更新</code>，这也就是 fiber 架构：</p>
<h2 id="React-16-架构"><a href="#React-16-架构" class="headerlink" title="React 16 架构"></a>React 16 架构</h2><p>React 16 架构可以分为三层：</p>
<ul>
<li>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入 Reconciler</li>
<li>Reconciler（协调器）—— 负责找出变化的组件</li>
<li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li>
</ul>
<h3 id="Scheduler（调度器）"><a href="#Scheduler（调度器）" class="headerlink" title="Scheduler（调度器）"></a>Scheduler（调度器）</h3><p><code>requestIdleCallback</code>可以告诉我们浏览器是否有剩余时间，但基于以下因素，React 放弃使用：</p>
<ul>
<li>浏览器兼容性</li>
<li>触发频率不稳定，受很多因素影响。比如当我们的浏览器切换 tab 后，之前 tab 注册的<code>requestIdleCallback</code> 触发的频率会变得很低</li>
</ul>
<p>基于以上原因，React 16 polyfill 了一个功能更加完备的 <code>requestIdleCallback</code>，这就是 <code>Scheduler</code>。除了在空闲时触发回调的功能外，<code>Scheduler</code> 还提供了多种调度优先级供任务设置。</p>
<h3 id="Reconciler（协调-器）"><a href="#Reconciler（协调-器）" class="headerlink" title="Reconciler（协调 器）"></a>Reconciler（协调 器）</h3><p>通过下面代码可以看出，更新工作从<code>递归</code>变成了<code>可中断的循环过程</code>。每次循环都会调用 shouldYield 判断当前是否有剩余时间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@noinline</span> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopConcurrent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Perform work until Scheduler asks us to yield</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !<span class="title function_">shouldYield</span>()) &#123;</span><br><span class="line">    workInProgress = <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么 React16 是如何解决中断更新时 DOM 渲染不完全的问题呢？</p>
<p>在 React16 中，Reconciler 与 Renderer 不再是交替工作，而是通过一次又一次在时间片段中对比，只有当全部组件都完成 Reconciler 对比完后，才会统一交给 Renderer。其中每一片时间片段的对比，Reconciler 都会为变化的虚拟 DOM 打上代表增&#x2F;删&#x2F;更新的标记，类似这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Placement</span> = <span class="comment">/*             */</span> <span class="number">0b0000000000010</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Update</span> = <span class="comment">/*                */</span> <span class="number">0b0000000000100</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">PlacementAndUpdate</span> = <span class="comment">/*    */</span> <span class="number">0b0000000000110</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Deletion</span> = <span class="comment">/*              */</span> <span class="number">0b0000000001000</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Renderer（渲染-器）"><a href="#Renderer（渲染-器）" class="headerlink" title="Renderer（渲染 器）"></a>Renderer（渲染 器）</h3><p>Renderer 根据 Reconciler 在虚拟 DOM 上打的标记，<code>同步执行</code>对应的 DOM 操作，这个过程不可被打断。</p>
<h2 id="为什么要引入-fiber"><a href="#为什么要引入-fiber" class="headerlink" title="为什么要引入 fiber"></a>为什么要引入 fiber</h2><p>React16 将递归的<code>无法中断的同步更新</code>重构为<code>异步的可中断更新</code>，由于曾经用于递归的虚拟 DOM 数据结构已经无法满足需要。于是，全新的 Fiber 架构应运而生</p>
<h3 id="什么是-fiber"><a href="#什么是-fiber" class="headerlink" title="什么是 fiber"></a>什么是 fiber</h3><p>Fiber 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fiber = &#123;</span><br><span class="line">    stateNode,    <span class="comment">// 节点实例</span></span><br><span class="line">    child,        <span class="comment">// 子节点</span></span><br><span class="line">    sibling,      <span class="comment">// 兄弟节点</span></span><br><span class="line">    <span class="keyword">return</span>,       <span class="comment">// 父节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>react fiber</code> 没法缩短整颗树的渲染时间，但它使得渲染过程被分成一小段、一小段的，相当于有了“保存工作进度”的能力，js 每渲染完一个单元节点，就让出主线程，丢给浏览器去做其他工作，然后再回来继续渲染，依次往复，直至比较完成，最后一次性的更新到视图上。</p>
<h3 id="fiber-的数据结构"><a href="#fiber-的数据结构" class="headerlink" title="fiber 的数据结构"></a>fiber 的数据结构</h3><p>为了能拆分成上面的单元任务，我们需要一种新的数据结构——fiber 链表，例如我们要渲染如下元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">  container</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>它被转化成的 fiber 链表的结构如下：<br><img data-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57137a19680747a985cdf30b90427ad8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"></p>
<ul>
<li>我们用 fiber 来代指一个要处理的单元任务，如：上面的一个 h1 就是一个 fiber</li>
<li>几乎每一个 fiber 都有 3 个指针，所以每个 fiber 都可以找到它的父、子、兄弟元素（这也是渲染可以中断的原因）</li>
<li>每当渲染完一个 fiber，performUnitOfWork 都会返回下一个待处理的 fiber，浏览器闲时就会去处理下一个 fiber，以此循环</li>
<li>遍历的顺序如下：<ul>
<li>从顶点开始遍历</li>
<li>如果有第一个儿子，先遍历第一个儿子</li>
<li>如果没有第一个儿子，标志着此节点遍历完成，然后去找叔叔</li>
<li>如果没有叔叔，则返回父节点，再找父节点的叔叔，若还没有，则一直往上递归</li>
<li>往上找时，没有父节点遍历结束</li>
</ul>
</li>
</ul>
<p>React 目前的做法是使用链表，每个 VirtualDOM 节点内部表示为一个 Fiber</p>
<p>例如：</p>
<ul>
<li>当前渲染了 <code>div</code>，那么下一个要处理的就是 <code>h1 fiber</code></li>
<li>如果 <code>child fiber</code> 不存在，如 <code>p fiber</code>，则下一个要处理的是兄弟 <code>a fiber</code></li>
<li>如果 <code>child fiber</code> 和兄弟 <code>fiber</code> 都不存在，如：<code>a fiber</code>，则往上找叔叔 <code>fiber</code>，即 <code>h2 fiber</code></li>
</ul>
<h3 id="为何-fiber-这种结构可被中断"><a href="#为何-fiber-这种结构可被中断" class="headerlink" title="为何 fiber 这种结构可被中断"></a>为何 fiber 这种结构可被中断</h3><p>对于 v16 之前的 dom 递归，假设遍历发生了中断，虽然可以保留当下进行中节点的索引，下次继续时，我们的确可以继续遍历该节点下面的所有子节点，但是没有办法找到其父节点——因为每个节点只有其子节点的指向。断点没有办法恢复，只能从头再来一遍。以该树为例：</p>
<p><img data-src="https://mmbiz.qpic.cn/mmbiz_png/cpWiaicnZTaua9skyECBhK8fmn4VYgeH2AcV58DPcjH4HYcLf7ZMwXjBXQ4vyg5GFZpuBfpmRjkVfcDKSbdk7lAw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1"></p>
<p>在遍历到节点 2 时发生了中断，我们保存对节点 2 的索引，下次恢复时可以把它下面的 3、4 节点遍历到，但是却无法找回 5、6、7、8 节点。</p>
<p><img data-src="https://mmbiz.qpic.cn/mmbiz_png/cpWiaicnZTaua9skyECBhK8fmn4VYgeH2AhanHpDdsPw9A2GIt1H8kbmBlPfc4td6etg3ibjaOic0BZzVl4ew6uz2A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1"></p>
<p>在新的架构中，每个节点有三个指针：分别指向第一个子节点、下一个兄弟节点、父节点。这种数据结构就是 fiber，它的遍历规则如下：</p>
<p>从根节点开始，依次遍历该节点的子节点、兄弟节点，如果两者都遍历了，则回到它的父节点；<br>当一个节点的所有子节点遍历完成，才认为该节点遍历完成；<br>根据这个规则，同样在图中标出了节点遍历完成的顺序。跟树结构对比会发现，虽然数据结构不同，但是节点的遍历开始和完成顺序一模一样。不同的是，当遍历发生中断时，只要保留下当前节点的索引，断点是可以恢复的——因为每个节点都保持着对其父节点的索引。</p>
<p><img data-src="https://mmbiz.qpic.cn/mmbiz_png/cpWiaicnZTaua9skyECBhK8fmn4VYgeH2ATfic9Tp6vWsohm1gTeUcADSCB1zTmUQHuKRtN1AcIBTnib0MRQ4wYjMg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1"></p>
<p>同样在遍历到节点 2 时中断，fiber 结构使得剩下的所有节点依旧能全部被走到。</p>
<p>这就是 react fiber 的渲染可以被中断的原因。树和 fiber 虽然看起来很像，但本质上来说，一个是树，一个是链表。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/K8mHbIwR6NMaIrutDzg61A">有 React fiber，为什么不需要 Vue fiber？</a></li>
<li><a href="https://mp.weixin.qq.com/s/kQJ2YVQ2dn-4STFosriLzw">Fiber 的深度理解</a></li>
</ul>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>从 0 到 1 实现 React（二）实现 fiber</title>
    <url>/2022/02/06/react/%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0React2/</url>
    <content><![CDATA[<h2 id="实现-render-方法"><a href="#实现-render-方法" class="headerlink" title="实现 render 方法"></a>实现 render 方法</h2><p>这里要实现的是和 <code>ReactDOM.render</code>同样的功能，代码如下：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// ...</span><br><span class="line"></span><br><span class="line"><span class="addition">+ function render(element, container) &#123;</span></span><br><span class="line"><span class="addition">+   const dom = element.type == &quot;TEXT_ELEMENT&quot;</span></span><br><span class="line"><span class="addition">+     ? document.createTextNode(&quot;&quot;)</span></span><br><span class="line"><span class="addition">+     : document.createElement(element.type)</span></span><br><span class="line"><span class="addition">+ </span></span><br><span class="line"><span class="addition">+   // children 被放到了 props 属性里，这里过滤掉 children</span></span><br><span class="line"><span class="addition">+   const isProperty = key =&gt; key !== &quot;children&quot;</span></span><br><span class="line"><span class="addition">+ </span></span><br><span class="line"><span class="addition">+   Object.keys(element.props)</span></span><br><span class="line"><span class="addition">+     .filter(isProperty)</span></span><br><span class="line"><span class="addition">+     // 设置 dom 元素的属性，这里是简化版意思一下，直接赋值</span></span><br><span class="line"><span class="addition">+     .forEach(name =&gt; dom[name] = element.props[name])</span></span><br><span class="line"><span class="addition">+   </span></span><br><span class="line"><span class="addition">+   // 递归子元素</span></span><br><span class="line"><span class="addition">+   element.props.children.forEach(child =&gt;render(child, dom))</span></span><br><span class="line"><span class="addition">+ </span></span><br><span class="line"><span class="addition">+   container.appendChild(dom)</span></span><br><span class="line"><span class="addition">+ &#125;</span></span><br><span class="line"></span><br><span class="line">const profile = (</span><br><span class="line">  &lt;div className=&quot;profile&quot;&gt;</span><br><span class="line">    &lt;span className=&quot;profile-title&quot;&gt;title&lt;/span&gt;</span><br><span class="line">    &lt;h3 className=&quot;profile-content&quot;&gt;content&lt;/h3&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(&#x27;成功启动&#x27;, profile);</span><br><span class="line"></span><br><span class="line"><span class="addition">+ const container = document.getElementById(&quot;root&quot;)</span></span><br><span class="line"><span class="addition">+ Didact.render(profile, container)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建节点时，不同类型的节点用不同方法创建，文本节点用<code>createTextNode</code>，其他节点用<code>createElement</code></li>
<li>我们创建 jsx 数据结构时，将<code>children</code>统一放到了<code>props</code>属性里，所以给 dom 添加<code>props</code>前，遍历<code>props</code>时，需过滤掉<code>props</code>里的<code>children</code></li>
<li>这里给 dom 添加<code>props</code>属性的实现非常简单，只有一个赋值表达式<code>dom[name] = element.props[name]</code>，其实是想用一行代码来代表此处还有着冗杂的属性处理，但写太复杂对理解整体 react 源码没有帮助，但感兴趣可以<a href="https://stackoverflow.com/questions/6003819/what-is-the-difference-between-properties-and-attributes-in-html">阅读</a>。</li>
</ul>
<p>这样大家就可以看到页面已经被渲染出来了，如下图：</p>
<p><img data-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d28d2cef7770440995c29d81f2d793bf~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>截止到此处的<a href="https://github.com/chao31/Didact/blob/feature/chao31_render/index.js">源码</a></p>
<h2 id="为什么要引入-fiber"><a href="#为什么要引入-fiber" class="headerlink" title="为什么要引入 fiber"></a>为什么要引入 fiber</h2><p>我们的<code>render</code>方法是用<code>递归</code>实现的，那么问题就来了，一旦开始递归，就不会停止，直至渲染完整个 dom 树。</p>
<p>那如果 dom 树很大，js 就会占据着主线程，而无法做其他工作，比如<code>用户的交互得不到响应</code>、<code>动画不能保持流畅</code>，因为它们必须等待渲染完成。为了展示这个问题，下面有个<a href="https://pomber.github.io/incremental-rendering-demo/react-sync.html">小演示</a>：</p>
<blockquote>
<p>为了保持行星的旋转，主线程需要在每 16ms 左右就要运行一次。如果主线程被其他东西阻塞，比如设置了主线程占用 200 毫秒，大家就会发现动画开始丢失帧的现象——行星会发生冻结、卡顿，直到主线程再次被释放。</p>
</blockquote>
<p>正是因为 react 的渲染会阻塞主线程太久，所以出现了<code>react fiber</code>。</p>
<h2 id="fiber-是什么"><a href="#fiber-是什么" class="headerlink" title="fiber 是什么"></a>fiber 是什么</h2><p><code>react fiber</code>没法<code>缩短</code>整颗树的渲染时间，但它使得渲染过程被分成一小段、一小段的，相当于有了“保存工作进度”的能力，js 每渲染完一个单元节点，就让出主线程，丢给浏览器去做其他工作，然后再回来继续渲染，依次往复，直至比较完成，最后一次性的更新到视图上。</p>
<p>下面用一段伪代码来理解这个拆分过程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被拆分成的一个一个单元的小任务</span></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoop</span>(<span class="params">deadline</span>) &#123;</span><br><span class="line">  <span class="comment">// requestIdleCallback 给 shouldYield 赋值，告诉我们浏览器是否空闲</span></span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    nextUnitOfWork = <span class="title function_">performUnitOfWork</span>(nextUnitOfWork)</span><br><span class="line">    shouldYield = deadline.<span class="title function_">timeRemaining</span>() &lt; <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环调用 workLoop</span></span><br><span class="line">  <span class="title function_">requestIdleCallback</span>(workLoop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">requestIdleCallback</span>(workLoop)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次执行完一个单元任务，会返回下一个单元任务</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOfWork</span>(<span class="params">nextUnitOfWork</span>) &#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不熟悉 <strong>requestIdleCallback</strong> 可以<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback">点这里查看</a>，这个方法很简单：它需要传入一个 <strong>callback</strong>，浏览器会在空闲时去调用这个 <strong>callback</strong>，然后给这个<strong>callback</strong> 传入一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IdleDeadline">IdleDeadline</a>，<code>IdleDeadline</code> 会预估一个剩余闲置时间，我们可以通过还剩多少闲置时间去判断，是否足够去执行下一个<code>单元任务</code>。</p>
<h2 id="fiber-的数据结构"><a href="#fiber-的数据结构" class="headerlink" title="fiber 的数据结构"></a>fiber 的数据结构</h2><p>为了能拆分成上面的<code>单元任务</code>，我们需要一种新的数据结构——<code>fiber链表</code>，例如我们要渲染如下元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Didact</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">  container</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>它被转化成的<code>fiber 链表</code>的结构如下：</p>
<p><img data-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57137a19680747a985cdf30b90427ad8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>我们用<code>fiber</code>来代指一个要处理的<code>单元任务</code>，如：上面的一个<code>h1</code>就是一个<code>fiber</code></li>
<li>几乎每一个<code>fiber</code>都有 3 个指针，所以每个<code>fiber</code>都可以找到它的父、子 (第一个子元素)、兄弟元素（这也是渲染可以中断的原因）</li>
<li>每当渲染完一个<code>fiber</code>，<code>performUnitOfWork</code>都会返回下一个待处理的<code>fiber</code>，浏览器闲时就会去处理下一个<code>fiber</code>，以此循环</li>
<li>优先返回<code>child fiber</code>做为下一个待处理的<code>fiber</code>；若<code>child fiber</code>不存在，则返回<code>兄弟 fiber</code>；若<code>兄弟 fiber</code>不存在，则往上递归，找父元素的<code>兄弟 fiber</code>；以此循环…</li>
</ul>
<p>例如：</p>
<ul>
<li>当前渲染了<code>div</code>，那么下一个要处理的就是<code>h1 fiber</code></li>
<li>如果<code>child fiber</code>不存在，如 <code>p fiber</code>,则下一个要处理的是兄弟<code>a fiber</code></li>
<li>如果<code>child fiber</code>和<code>兄弟 fiber</code>都不存在，如：<code>a fiber</code>，则往上找<code>叔叔 fiber</code>，即<code>h2 fiber</code></li>
</ul>
<h2 id="实现-fiber"><a href="#实现-fiber" class="headerlink" title="实现 fiber"></a>实现 fiber</h2><p>在<code>render</code>方法里为<code>nextUnitOfWork</code>赋值第一个<code>fiber</code>，待浏览器闲时检测到了<code>nextUnitOfWork</code>有值，就会启动 loop 循环，不断地设置下一个<code>fiber</code>，也不断的遍历全部节点，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createDom</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dom =</span><br><span class="line">      fiber.<span class="property">type</span> == <span class="string">&quot;TEXT_ELEMENT&quot;</span></span><br><span class="line">        ? <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        : <span class="variable language_">document</span>.<span class="title function_">createElement</span>(fiber.<span class="property">type</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// children 被放到了 props 属性里，这里过滤掉 children</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">isProperty</span> = key =&gt; key !== <span class="string">&quot;children&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(fiber.<span class="property">props</span>)</span><br><span class="line">    .<span class="title function_">filter</span>(isProperty)</span><br><span class="line">    <span class="comment">// 设置 dom 元素的属性，这里是简化版意思一下，直接赋值</span></span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="function"><span class="params">name</span> =&gt;</span> dom[name] = fiber.<span class="property">props</span>[name])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> dom</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">element, container</span>) &#123;</span><br><span class="line">  <span class="comment">// 虽然后面会给这个对象添加更多属性，但这里是第一个 fiber</span></span><br><span class="line">  nextUnitOfWork = &#123;</span><br><span class="line">    <span class="attr">dom</span>: container,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">children</span>: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改<code>render</code>方法：设置待执行的初始<code>fiber</code></li>
<li>新增<code>createDom</code>方法：将原 <code>render</code> 方法里的主要逻辑移到 <code>createDom</code> 中，即根据 <code>fiber</code> 的属性，创建 <code>dom节点</code></li>
</ul>
<p>实现 <code>performUnitOfWork</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每次执行完一个单元任务（做了以下 3 件事），会返回下一个单元任务</span></span><br><span class="line"><span class="comment">// 1. 给 fiber 添加 dom，并插入父元素</span></span><br><span class="line"><span class="comment">// 2. 给当前 fiber 的每一个子元素生成 fiber 节点</span></span><br><span class="line"><span class="comment">// 3. 找到要返回的下一个 unitOfWork</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOfWork</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber.<span class="property">dom</span>) &#123;</span><br><span class="line">    fiber.<span class="property">dom</span> = <span class="title function_">createDom</span>(fiber)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.<span class="property">parent</span>) &#123;</span><br><span class="line">    fiber.<span class="property">parent</span>.<span class="property">dom</span>.<span class="title function_">appendChild</span>(fiber.<span class="property">dom</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> elements = fiber.<span class="property">props</span>.<span class="property">children</span></span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> prevSibling = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 遍历当前 fiber 的 children</span></span><br><span class="line">  <span class="comment">// 2. 给 children 里的每个 child 指定 3 个指针，分别指向其 父、子、兄弟三个节点</span></span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newFiber = &#123;</span><br><span class="line">      <span class="attr">type</span>: element.<span class="property">type</span>,</span><br><span class="line">      <span class="attr">props</span>: element.<span class="property">props</span>,</span><br><span class="line">      <span class="attr">parent</span>: fiber,</span><br><span class="line">      <span class="attr">dom</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      fiber.<span class="property">child</span> = newFiber</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prevSibling.<span class="property">sibling</span> = newFiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prevSibling = newFiber</span><br><span class="line">    index++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面的操作是返回下一个单元——nextUnitOfWork</span></span><br><span class="line">  <span class="comment">// 1. 优先找 child</span></span><br><span class="line">  <span class="comment">// 2. 没有 child 找兄弟</span></span><br><span class="line">  <span class="comment">// 3. 没有兄弟，找叔叔，也就是递归到父元素的兄弟</span></span><br><span class="line">  <span class="comment">// 4. 没有叔叔就一直往上递归...</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.<span class="property">child</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.<span class="property">child</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> nextFiber = fiber</span><br><span class="line">  <span class="keyword">while</span> (nextFiber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextFiber.<span class="property">sibling</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextFiber.<span class="property">sibling</span></span><br><span class="line">    &#125;</span><br><span class="line">    nextFiber = nextFiber.<span class="property">parent</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面的注释很详尽，就不再讲述 <code>performUnitOfWork</code> 的实现了。</p>
<h2 id="UI-展示不完整问题"><a href="#UI-展示不完整问题" class="headerlink" title="UI 展示不完整问题"></a>UI 展示不完整问题</h2><p>从下面代码可以看出，每个<code>fiber</code>都会执行一次插入 dom，但因渲染是会被打断的，所以就会出现只插入部分 dom 的情况，使某一刻的 UI 完整不展示。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">function performUnitOfWork(fiber) &#123;</span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line"><span class="deletion">- if (fiber.parent) &#123;</span></span><br><span class="line"><span class="deletion">-     fiber.parent.dom.appendChild(fiber.dom)</span></span><br><span class="line"><span class="deletion">- &#125;</span></span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>所以要删除上面的实现，转而通过判断 root 节点是否全部渲染完成，若全部完成，再将整个<code>root fiber</code>插入 dom，实现如下：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">function render(element, container) &#123;</span><br><span class="line"><span class="deletion">-  nextUnitOfWork = &#123;</span></span><br><span class="line"><span class="addition">+  wipRoot = &#123;</span></span><br><span class="line">     dom: container,</span><br><span class="line">     props: &#123;</span><br><span class="line">       children: [element],</span><br><span class="line">     &#125;,</span><br><span class="line">   &#125;</span><br><span class="line"><span class="addition">+  nextUnitOfWork = wipRoot</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+ function commitRoot() &#123;</span></span><br><span class="line"><span class="addition">+   commitWork(wipRoot.child)</span></span><br><span class="line"><span class="addition">+   wipRoot = null</span></span><br><span class="line"><span class="addition">+ &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ // 递归插入所有dom</span></span><br><span class="line"><span class="addition">+ function commitWork(fiber) &#123;</span></span><br><span class="line"><span class="addition">+   if (!fiber) return</span></span><br><span class="line"><span class="addition">+   </span></span><br><span class="line"><span class="addition">+   const domParent = fiber.parent.dom</span></span><br><span class="line"><span class="addition">+   domParent.appendChild(fiber.dom)</span></span><br><span class="line"><span class="addition">+   commitWork(fiber.child)</span></span><br><span class="line"><span class="addition">+   commitWork(fiber.sibling)</span></span><br><span class="line"><span class="addition">+ &#125;</span></span><br><span class="line"></span><br><span class="line">// 被拆分成的一个一个单元的小任务</span><br><span class="line">let nextUnitOfWork = null</span><br><span class="line"></span><br><span class="line"><span class="addition">+ let wipRoot = null</span></span><br><span class="line"></span><br><span class="line">function workLoop(deadline) &#123;</span><br><span class="line">  // requestIdleCallback 给 shouldYield 赋值，告诉我们浏览器是否空闲</span><br><span class="line">  let shouldYield = false</span><br><span class="line">  while (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    nextUnitOfWork = performUnitOfWork(nextUnitOfWork)</span><br><span class="line">    shouldYield = deadline.timeRemaining() &lt; 1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+ // 没有下一个待渲染的fiber，表示所有dom渲染完成，commit到root</span></span><br><span class="line"><span class="addition">+ if (!nextUnitOfWork &amp;&amp; wipRoot) &#123;</span></span><br><span class="line"><span class="addition">+   commitRoot()</span></span><br><span class="line"><span class="addition">+ &#125;</span></span><br><span class="line">  </span><br><span class="line">  // 循环调用 workLoop</span><br><span class="line">  requestIdleCallback(workLoop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过上面最后的 <code>commitRoot</code> 方法，将完整的 <code>root fiber</code> 里的所有 <code>dom</code> 通过递归插入到了页面，就修复了 UI 出现不完整展示的问题。</p>
<p><a href="https://github.com/chao31/Didact/blob/feature/chao31_fiber/index.js">本章源码</a></p>
<hr>
<p>参考：</p>
<ol>
<li><a href="https://pomb.us/build-your-own-react/">build your own react</a></li>
<li><a href="https://github.com/chinanf-boy/didact-explain/blob/master/5.Fibre.readme.md">Fibre-递增对比</a></li>
<li><a href="https://mp.weixin.qq.com/s/K8mHbIwR6NMaIrutDzg61A">有 React fiber，为什么不需要 Vue fiber？</a></li>
</ol>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>从 0 到 1 系列</tag>
      </tags>
  </entry>
  <entry>
    <title>一文讲通 React 的 diff 过程</title>
    <url>/2022/03/27/react/%E4%B8%80%E6%96%87%E8%AE%B2%E9%80%9AReact%E7%9A%84diff%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>看完这篇文章，我们可以弄明白下面这几个问题：</p>
<ol>
<li>传统<code>diff</code> 算法的瓶颈是什么？</li>
<li><code>React</code> 的 <code>diff</code> 算法是怎么实现的？</li>
<li><code>React</code> 的 <code>diff</code> 算法发生在哪个阶段？</li>
<li><code>React</code> 的元素的 <code>key</code> 是做什么的？</li>
<li><code>React</code> 是怎么通过 <code>key</code> 实现高效 <code>diff</code> 的？</li>
</ol>
<h2 id="Fiber-节点的构建"><a href="#Fiber-节点的构建" class="headerlink" title="Fiber 节点的构建"></a>Fiber 节点的构建</h2><p>下面的伪代码展示了 <code>fiber</code> 构建的过程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">workLoop</span>(<span class="params">deadline</span>) &#123;</span><br><span class="line">  <span class="comment">// requestIdleCallback 给 shouldYield 赋值，告诉我们浏览器是否空闲</span></span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    nextUnitOfWork = <span class="title function_">performUnitOfWork</span>(nextUnitOfWork)</span><br><span class="line">    shouldYield = deadline.<span class="title function_">timeRemaining</span>() &lt; <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环调用 workLoop</span></span><br><span class="line">  <span class="title function_">requestIdleCallback</span>(workLoop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">requestIdleCallback</span>(workLoop)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建完当前 fiber 节点后，会返回下一个待构建的节点 如：fiber.sibling、fiber.parent...</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOfWork</span>(<span class="params">nextUnitOfWork</span>) &#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不熟悉 <code>requestIdleCallback</code> 可以点<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback">这里查看</a>，这个方法很简单：它需要传入一个 <code>callback</code>，浏览器会在空闲时去调用这个 <code>callback</code>，然后给这个 <code>callback</code> 传入一个 <code>IdleDeadline</code>，<code>IdleDeadline</code> 会预估一个剩余闲置时间，我们可以通过还剩多少闲置时间去判断，是否足够去执行下一个单元任务。</li>
<li><code>performUnitOfWork</code> 方法将传入的<code>节点</code>创建为 <code>Fiber</code> ，然后返回下一个待构建的<code>节点</code>并赋值给 <code>nextUnitOfWork</code>，同时还会将刚创建的 <code>fiber</code> 与已创建的 <code>fiber</code> 连接起来构成 <code>Fiber</code> 树。</li>
</ul>
<p><code>performUnitOfWork</code> 的工作可以分为两部分：“<code>递</code>”和“<code>归</code>”。</p>
<h2 id="render-阶段"><a href="#render-阶段" class="headerlink" title="render 阶段"></a>render 阶段</h2><p>render 阶段的开始，首先从 <code>rootFiber</code> 开始向下<code>深度优先</code>遍历，也就是不断 <code>while</code> 循环执行 <code>performUnitOfWork</code>，会经历<code>递</code>和<code>归</code>两个阶段。</p>
<h3 id="“递”阶段"><a href="#“递”阶段" class="headerlink" title="“递”阶段"></a>“递”阶段</h3><ul>
<li>向下遍历，每个遍历到的 <code>Fiber</code> 节点会调用 <code>beginWork</code> 方法。</li>
<li>该方法会根据传入的 <code>Fiber</code> 节点创建<code>子Fiber</code> 节点，并将这两个 <code>Fiber</code> 节点<code>连接</code>起来。</li>
<li>当遍历到没有 <code>child</code> 的节点时就会进入“归”阶段。</li>
</ul>
<h3 id="“归”阶段"><a href="#“归”阶段" class="headerlink" title="“归”阶段"></a>“归”阶段</h3><ul>
<li>在“归”阶段会调用 <code>completeWork</code>  处理 <code>Fiber</code> 节点。</li>
<li>当某个 <code>Fiber</code> 节点执行完 <code>completeWork</code>，如果其存在<code>兄弟Fiber</code>节点，会进入其<code>兄弟Fiber</code>的“递”阶段。</li>
<li>如果不存在<code>兄弟Fiber</code>，会进入<code>父Fiber</code>的“归”阶段。</li>
</ul>
<h3 id="递和归举例"><a href="#递和归举例" class="headerlink" title="递和归举例"></a>递和归举例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      i am</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>KaSong<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>对应的 Fiber 树结构：</p>
<p><img data-src="https://chao31.github.io/pics/img/202303211355838.png"></p>
<p>render 阶段会依次执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> rootFiber beginWork</span><br><span class="line"><span class="number">2.</span> <span class="title class_">App</span> <span class="title class_">Fiber</span> beginWork</span><br><span class="line"><span class="number">3.</span> div <span class="title class_">Fiber</span> beginWork</span><br><span class="line"><span class="number">4.</span> <span class="string">&quot;i am&quot;</span> <span class="title class_">Fiber</span> beginWork</span><br><span class="line"><span class="number">5.</span> <span class="string">&quot;i am&quot;</span> <span class="title class_">Fiber</span> completeWork</span><br><span class="line"><span class="number">6.</span> span <span class="title class_">Fiber</span> beginWork</span><br><span class="line"><span class="number">7.</span> span <span class="title class_">Fiber</span> completeWork</span><br><span class="line"><span class="number">8.</span> div <span class="title class_">Fiber</span> completeWork</span><br><span class="line"><span class="number">9.</span> <span class="title class_">App</span> <span class="title class_">Fiber</span> completeWork</span><br><span class="line"><span class="number">10.</span> rootFiber completeWork</span><br></pre></td></tr></table></figure>

<p>注意：之所以没有<code>“KaSong”</code>Fiber 的 <code>beginWork/completeWork</code>，是因为作为一种性能优化手段，针对只有单一文本子节点的 <code>Fiber</code>，<code>React</code> 会特殊处理。</p>
<h3 id="render-完成"><a href="#render-完成" class="headerlink" title="render 完成"></a>render 完成</h3><p>“递”和“归”阶段会交错执行直到“归”到 <code>rootFiber</code>。至此，<code>render</code> 阶段的工作就结束了。</p>
<h2 id="Diff"><a href="#Diff" class="headerlink" title="Diff"></a>Diff</h2><p><code>diff 算法</code>发生在两个阶段，分别是 <code>beginWork</code> 和 <code>completeWork</code> 阶段。</p>
<h3 id="Diff-的瓶颈以及-React-如何应对"><a href="#Diff-的瓶颈以及-React-如何应对" class="headerlink" title="Diff 的瓶颈以及 React 如何应对"></a>Diff 的瓶颈以及 React 如何应对</h3><p>由于 <code>Diff</code> 操作本身也会带来性能损耗，<code>React</code> 文档中提到，即使在最前沿的算法中，将前后两棵树完全比对的算法的复杂程度为 O(n 3 )，其中 n 是树中元素的数量。<br>如果在 React 中使用了该算法，那么展示 1000 个元素所需要执行的计算量将在十亿的量级范围。这个开销实在是太过高昂。<br>为了降低算法复杂度，React 的 diff 会预设三个限制：</p>
<ol>
<li>只进行<code>同层比较</code>。</li>
<li>新、旧节点的 <code>type</code> 不同，直接<code>删除</code>旧节点，<code>创建</code>新节点。如：元素由 <code>div</code> 变为 <code>p</code>，React<code>会销毁</code>div<code>及其子孙节点，并新建</code>p&#96; 及其子孙节点。</li>
<li>通过 <code>key</code> 来<code>复用</code>节点。</li>
</ol>
<p>所以 <code>react</code> 中 <code>diff</code> 算法主要遵循上面的三个层级的策略：</p>
<ol>
<li><code>tree</code> 层级</li>
<li><code>conponent</code> 层级</li>
<li><code>element</code> 层级</li>
</ol>
<h4 id="tree-层级"><a href="#tree-层级" class="headerlink" title="tree 层级"></a>tree 层级</h4><p><code>DOM</code> 节点跨层级的操作不做优化，只会对相同层级的节点进行比较</p>
<p><img data-src="https://chao31.github.io/pics/img/202303211415634.png"></p>
<p>只有删除、创建操作，没有移动操作，如下图：<br><img data-src="https://chao31.github.io/pics/img/202303211416464.png"></p>
<p><code>react</code> 发现新树中，<code>R</code> 节点下没有了 <code>A</code>，那么直接删除 <code>A</code>，在 <code>D</code> 节点下创建 <code>A</code> 以及下属节点，上述操作中，只有删除和创建操作</p>
<h4 id="component-层级"><a href="#component-层级" class="headerlink" title="component 层级"></a>component 层级</h4><p>如果是同一个类的组件，则会继续往下 <code>diff</code> 运算，如果不是一个类的组件，那么直接删除这个组件下的所有子节点，创建新的</p>
<p><img data-src="https://chao31.github.io/pics/img/202303211418926.png"></p>
<p>当 component D 换成了 component G 后，即使两者的结构非常类似，也会将 D 删除再重新创建 G</p>
<h4 id="element-层级"><a href="#element-层级" class="headerlink" title="element 层级"></a>element 层级</h4><p>对于比较同一层级的节点们，每个节点在对应的层级用唯一的 <code>key</code> 作为标识</p>
<p>提供了 3 种节点操作，分别为 <code>INSERT_MARKUP</code>(插入)、<code>MOVE_EXISTING</code> (移动) 和 <code>REMOVE_NODE</code> (删除)</p>
<p>如下场景：</p>
<p><img data-src="https://chao31.github.io/pics/img/202303211419967.png"></p>
<p>通过 <code>key</code> 可以准确地发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置</p>
<h2 id="Diff-是如何实现的"><a href="#Diff-是如何实现的" class="headerlink" title="Diff 是如何实现的"></a>Diff 是如何实现的</h2><p>我们从 <code>Diff</code> 的入口函数 <code>reconcileChildFibers</code> 出发，该函数会根据 <code>newChild</code>（即 JSX 对象）类型调用不同的处理函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 newChild 类型选择不同 diff 函数处理</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileChildFibers</span>(<span class="params"></span></span><br><span class="line"><span class="params">  returnFiber: Fiber,</span></span><br><span class="line"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  newChild: any,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isObject = <span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">    <span class="comment">// object 类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE</span></span><br><span class="line">    <span class="keyword">switch</span> (newChild.<span class="property">$$typeof</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="attr">REACT_ELEMENT_TYPE</span>:</span><br><span class="line">        <span class="comment">// 调用 reconcileSingleElement 处理</span></span><br><span class="line">      <span class="comment">// // ...省略其他 case</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> newChild === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 reconcileSingleTextNode 处理</span></span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isArray</span>(newChild)) &#123;</span><br><span class="line">    <span class="comment">// 调用 reconcileChildrenArray 处理</span></span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一些其他情况调用处理函数</span></span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以上都没有命中，删除节点</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">deleteRemainingChildren</span>(returnFiber, currentFirstChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以从同级的节点数量将 <code>Diff</code> 分为两类：</p>
<ul>
<li>当 <code>newChild</code> 类型为 <code>object</code>、<code>number</code>、<code>string</code>，代表同级只有一个节点</li>
<li>当 <code>newChild</code> 类型为 <code>Array</code>，同级有多个节点</li>
</ul>
<p>在接下来两节我们会分别讨论这两类节点的 <code>Diff</code></p>
<h3 id="单节点-diff"><a href="#单节点-diff" class="headerlink" title="单节点 diff"></a>单节点 diff</h3><p>对于单个节点，我们以类型 <code>object</code> 为例，会进入 <code>reconcileSingleElement</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isObject = <span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">    <span class="comment">// 对象类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE</span></span><br><span class="line">    <span class="keyword">switch</span> (newChild.<span class="property">$$typeof</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="attr">REACT_ELEMENT_TYPE</span>:</span><br><span class="line">        <span class="comment">// 调用 reconcileSingleElement 处理</span></span><br><span class="line">      <span class="comment">// ...其他 case</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>React 通过先判断 key 是否相同，如果 key 相同则判断 type 是否相同，只有都相同时一个 DOM 节点才能复用。</p>
<p>这里有个细节需要关注下：</p>
<ul>
<li><p>当 <code>key 相同</code>且 <code>type 不同</code>时，执行 <code>deleteRemainingChildren</code> 将 <code>child</code> 及其<code>兄弟 fiber</code> 都标记删除。</p>
</li>
<li><p>当 <code>key 不同</code>时仅将 <code>child</code> 标记删除 (后面还有<code>兄弟 fiber</code> 还没有遍历到。所以仅仅标记该 <code>fiber</code> 删除。)</p>
</li>
</ul>
<p>考虑如下例子：当前页面有 3 个 li，我们要全部删除，再插入一个 p。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 当前页面显示的</span><br><span class="line">ul &gt; li * 3</span><br><span class="line"></span><br><span class="line">// 这次需要更新的</span><br><span class="line">ul &gt; p</span><br></pre></td></tr></table></figure>
<ul>
<li>由于检测<code>新节点</code>只有一个 <code>p</code>，属于<code>单节点</code>比较。</li>
<li>在 <code>reconcileSingleElement</code> 中遍历之前的 3 个 <code>fiber（对应的</code> <code>DOM</code> 为 3 个 <code>li</code>），寻找本次更新的 <code>p</code> 是否可以复用之前的 3 个 <code>fiber</code> 中某个的 <code>DOM</code>。</li>
<li>当 <code>key</code> 相同且 <code>type</code> 不同时，代表我们已经找到本次更新的 p 对应的上次的 <code>fiber</code>，但是 p 与 li <code>type</code> 不同，不能复用。既然唯一的可能性已经不能复用，则剩下的 <code>fiber</code> 都没有机会了，所以都需要标记删除。</li>
<li>当 <code>key</code> 不同时只代表遍历到的该 <code>fiber</code> 不能被 <code>p</code> 复用，后面还有兄弟 <code>fiber</code> 还没有遍历到。所以仅仅标记该 <code>fiber</code> 删除</li>
</ul>
<h3 id="多节点-diff"><a href="#多节点-diff" class="headerlink" title="多节点 diff"></a>多节点 diff</h3><p>这种情况下，<code>reconcileChildFibers</code> 的 <code>newChild</code> 参数类型为 <code>Array</code>，在 <code>reconcileChildFibers</code> 函数内部对应如下情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isArray</span>(newChild)) &#123;</span><br><span class="line">    <span class="comment">// 调用 reconcileChildrenArray 处理</span></span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后归纳要处理的情况：</p>
<ol>
<li>节点<code>更新</code></li>
<li>节点<code>新增</code>或<code>减少</code></li>
<li>节点<code>位置变化</code></li>
</ol>
<p>同级多个节点的 <code>Diff</code>，一定属于以上三种情况中的一种或多种。</p>
<h4 id="diff-思路"><a href="#diff-思路" class="headerlink" title="diff 思路"></a>diff 思路</h4><p>该如何设计算法呢？如果让我设计一个 Diff 算法，我首先想到的方案是：</p>
<ol>
<li>判断当前节点的更新属于哪种情况</li>
<li>如果是新增，执行新增逻辑</li>
<li>如果是删除，执行删除逻辑</li>
<li>如果是更新，执行更新逻辑</li>
</ol>
<p>按这个方案，其实有个隐含的前提——<code>不同操作的优先级是相同的</code></p>
<blockquote>
<p>但是 <code>React</code> 团队发现，在日常开发中，相较于<code>新增</code>和<code>删除</code>，更新组件发生的<code>频率</code>更高。所以 Diff 会优先判断当前节点是否属于<code>更新</code>。</p>
</blockquote>
<h3 id="为什么不能用双指针遍历"><a href="#为什么不能用双指针遍历" class="headerlink" title="为什么不能用双指针遍历"></a>为什么不能用双指针遍历</h3><p>在我们做数组相关的算法题时，经常使用双指针从数组头和尾同时遍历以提高效率，但是这里却不行。</p>
<p>虽然 <code>newChildren</code> 为<code>数组</code>形式，但是老节点是 <code>fiber</code>链表，同级的 <code>Fiber</code> 节点是由 <code>sibling</code> 指针链接形成的单链表，即不支持双指针遍历。即 <code>newChildren[0]与fiber比较，newChildren[1]与fiber.sibling比较</code>。</p>
<p>所以无法使用双指针优化，基于以上原因，Diff 算法的整体逻辑会经历两轮遍历：</p>
<ul>
<li>第一轮遍历：处理更新的节点。</li>
<li>第二轮遍历：处理剩下的不属于更新的节点。</li>
</ul>
<h4 id="第一轮遍历"><a href="#第一轮遍历" class="headerlink" title="第一轮遍历"></a>第一轮遍历</h4><p>第一轮遍历步骤如下：</p>
<ol>
<li><code>let i = 0</code>，遍历 <code>newChildren</code>，将 <code>newChildren[i]</code>与<code>oldFiber</code>比较，判断 DOM 节点是否可复用。</li>
<li>如果可复用，<code>i++</code>，继续比较 <code>newChildren[i]</code>与<code>oldFiber.sibling</code>，可以复用则继续遍历。</li>
<li>如果不可复用，分两种情况：<ul>
<li><code>key 不同</code>导致不可复用，立即跳出整个遍历，第一轮遍历结束。</li>
<li><code>key 相同</code> 而<code>type 不同</code>导致不可复用，会将 <code>oldFiber</code> 标记为 <code>DELETION</code>，并继续遍历</li>
</ul>
</li>
<li>如果 <code>newChildren</code> 遍历完（即 <code>i === newChildren.length - 1</code>）或者 <code>oldFiber</code> 遍历完（即 <code>oldFiber.sibling === null</code>），跳出遍历，第一轮遍历结束。</li>
</ol>
<p>当遍历结束后，会有两种结果：</p>
<h5 id="步骤-3-跳出的遍历"><a href="#步骤-3-跳出的遍历" class="headerlink" title="步骤 3 跳出的遍历"></a>步骤 3 跳出的遍历</h5><p>此时 newChildren 没有遍历完，oldFiber 也没有遍历完。</p>
<p>举个例子，考虑如下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 之前</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">// 之后</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第一个节点可复用，遍历到 <code>key === 2</code> 的节点发现 <code>key</code> 改变，不可复用，跳出遍历，等待第二轮遍历处理。</p>
<p>此时 <code>oldFiber</code> 剩下 <code>key === 1</code>、<code>key === 2</code> 未遍历，<code>newChildren</code> 剩下 <code>key === 2</code>、<code>key === 1</code> 未遍历。</p>
<h5 id="步骤-4-跳出的遍历"><a href="#步骤-4-跳出的遍历" class="headerlink" title="步骤 4 跳出的遍历"></a>步骤 4 跳出的遍历</h5><p>可能 <code>newChildren</code> 遍历完，或 <code>oldFiber</code> 遍历完，或他们同时遍历完。</p>
<p>举个例子，考虑如下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 之前</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span> <span class="attr">className</span>=<span class="string">&quot;a&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span> <span class="attr">className</span>=<span class="string">&quot;b&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">// 之后 情况 1 —— newChildren 与 oldFiber 都遍历完</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span> <span class="attr">className</span>=<span class="string">&quot;aa&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span> <span class="attr">className</span>=<span class="string">&quot;bb&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">// 之后 情况 2 —— newChildren 没遍历完，oldFiber 遍历完</span><br><span class="line">// newChildren 剩下 key===&quot;2&quot; 未遍历</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span> <span class="attr">className</span>=<span class="string">&quot;aa&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span> <span class="attr">className</span>=<span class="string">&quot;bb&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span> <span class="attr">className</span>=<span class="string">&quot;cc&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">// 之后 情况 3 —— newChildren 遍历完，oldFiber 没遍历完</span><br><span class="line">// oldFiber 剩下 key===&quot;1&quot; 未遍历</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span> <span class="attr">className</span>=<span class="string">&quot;aa&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>带着第一轮遍历的结果，我们开始第二轮遍历。</p>
<h4 id="第二轮遍历"><a href="#第二轮遍历" class="headerlink" title="第二轮遍历"></a>第二轮遍历</h4><p>对于第一轮遍历的结果，我们分别讨论：</p>
<ol>
<li><code>newChildren</code> 与 <code>oldFiber</code> 同时遍历完</li>
</ol>
<p>那就是最理想的情况：只需在第一轮遍历进行组件更新。此时 <code>Diff</code> 结束。</p>
<ol start="2">
<li><code>newChildren</code> 没遍历完，<code>oldFiber</code> 遍历完</li>
</ol>
<p>已有的 <code>DOM</code> 节点都复用了，这时还有新加入的节点，意味着本次更新有新节点插入，我们只需要遍历剩下的 <code>newChildren</code> 为生成的 <code>fiber</code> 依次标记 <code>Placement。</code></p>
<ol start="3">
<li><code>newChildren</code> <code>遍历完，oldFiber</code> 没遍历完</li>
</ol>
<p>意味着本次更新比之前的节点数量少，有节点被删除了。所以需要遍历剩下的 <code>oldFiber</code>，依次标记 <code>Deletion</code>。</p>
<ol start="4">
<li><code>newChildren</code> 与 <code>oldFiber</code> 都没遍历完</li>
</ol>
<p>这意味着有节点在这次更新中改变了位置。</p>
<p>这是 Diff 算法最精髓也是最难懂的部分。我们接下来会重点讲解。</p>
<h4 id="处理移动的节点"><a href="#处理移动的节点" class="headerlink" title="处理移动的节点"></a>处理移动的节点</h4><blockquote>
<p>移动的思想：如果当前节点在新集合中的位置比老集合中的位置靠前的话，是不会影响后续节点操作的，这时候不用动</p>
</blockquote>
<p>操作过程中只比较 <code>oldIndex</code> 和 <code>maxIndex</code>，规则如下：</p>
<ul>
<li>当 <code>oldIndex&gt;maxIndex</code> 时，将 <code>oldIndex</code> 的值赋值给 <code>maxIndex</code></li>
<li>当 <code>oldIndex=maxIndex</code> 时，不操作</li>
<li>当 <code>oldIndex&lt;maxIndex</code> 时，将当前节点移动到 <code>index</code> 的位置</li>
</ul>
<blockquote>
<p>即：遍历新节点，每个新节点有 2 个 index，一个是在旧节点的位置，另一个是遇到的最大旧节点的位置，然后根据上面判断决定旧节点是否右移。</p>
</blockquote>
<p>还是举上面的例子</p>
<p><img data-src="https://chao31.github.io/pics/img/202303211419967.png"></p>
<p>diff 过程如下：</p>
<ol>
<li>节点 B：此时 maxIndex&#x3D;0，oldIndex&#x3D;1；满足 maxIndex&lt; oldIndex，因此 B 节点不动，此时 maxIndex&#x3D; Math.max(oldIndex, maxIndex)，就是 1</li>
<li>节点 A：此时 maxIndex&#x3D;1，oldIndex&#x3D;0；不满足 maxIndex&lt; oldIndex，因此 A 节点进行移动操作，此时 maxIndex&#x3D; Math.max(oldIndex, maxIndex)，还是 1</li>
<li>节点 D：此时 maxIndex&#x3D;1, oldIndex&#x3D;3；满足 maxIndex&lt; oldIndex，因此 D 节点不动，此时 maxIndex&#x3D; Math.max(oldIndex, maxIndex)，就是 3</li>
<li>节点 C：此时 maxIndex&#x3D;3，oldIndex&#x3D;2；不满足 maxIndex&lt; oldIndex，因此 C 节点进行移动操作，当前已经比较完了</li>
</ol>
<p>当 ABCD 节点比较完成后，diff 过程还没完，还会整体遍历老集合中节点，看有没有没用到的节点，有的话，就删除</p>
<p><img data-src="https://chao31.github.io/pics/img/202303211512561.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>传统 diff 算法通过<code>循环递归</code>对节点进行依次对比，复杂度过高，为了降低算法复杂度，diff 遵循了 3 个层级的优化策略： <ol>
<li>只进行同层比较。</li>
<li>新、旧节点的 type 不同，直接删除旧节点，创建新节点。</li>
<li>通过 key 来复用节点。</li>
</ol>
</li>
<li>从 <code>Diff</code> 的入口函数 <code>reconcileChildFibers</code> 出发，判断子元素的类型，若不是数组进入<code>单节点diff</code>，否则进入<code>多节点diff</code></li>
<li><code>单节点diff</code>：先判断 <code>key</code> 是否相同，<ul>
<li>如果 <code>key</code> 相同，再看 <code>type</code><ul>
<li><code>type</code> 相同，复用；</li>
<li><code>type</code> 不同，全部删掉（包括它和它的兄弟元素，因为既然 key 一样，唯一的可能性都不能复用，则剩下的 fiber 都没有机会了）；</li>
</ul>
</li>
<li>如果 <code>key</code> 不同，只删除该<code>child</code>，再找到它的兄弟节点（<code>child.silbing</code>）的 <code>key</code>，直到找到<code>key</code>相同的节点，再同上操作</li>
</ul>
</li>
<li><code>多节点diff</code>：归纳只有 3 种情况，更新节点、增减节点、位置变化，由于是单向的链表（<code>newChildren[0]</code>与<code>fiber</code>比较，<code>newChildren[1]</code>与<code>fiber.sibling</code>比较），所以不能像 vue 一样用双指针遍历，所以这里逻辑要经过两轮遍历：<ul>
<li>第一轮遍历：比较 key，<ul>
<li>可复用，继续遍历 (新节点 <code>i++</code>，老节点<code>child.silbing</code>)，</li>
<li>不可复用，就停止第一轮遍历，进入第二轮遍历，有 2 种不可复用的情况：<ul>
<li><ol>
<li>key 不同，直接停止</li>
</ol>
</li>
<li><ol start="2">
<li>key 相同，type 不同，标记删除，停止</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>第二轮遍历： <ul>
<li>老节点遍历完了，新节点还有，则将剩下的新节点<code>插入</code></li>
<li>新节点遍历完了，老节点还有，则将剩下的老节点<code>删除</code></li>
<li>新老节点都还有，则<code>移动顺序</code>，这是 diff 算法最精髓也是最难懂的部分，规则：遍历新节点，每个新节点有 2 个 index，一个 index 表示它在旧节点的位置，另一个 index 表示遍历中遇到的最大旧节点的位置，用 <code>oldIndex</code> 和 <code>maxIndex</code> 表示<ul>
<li>当 <code>oldIndex&gt;maxIndex</code> 时，将 <code>oldIndex</code> 的值赋值给 <code>maxIndex</code></li>
<li>当 <code>oldIndex=maxIndex</code> 时，不操作</li>
<li>当 <code>oldIndex&lt;maxIndex</code> 时，将当前节点移动到 <code>index</code> 的位置</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>参考：</p>
<ol>
<li><a href="https://react.iamkasong.com/diff/prepare.html#diff%E7%9A%84%E7%93%B6%E9%A2%88%E4%BB%A5%E5%8F%8Areact%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9">React 技术揭秘</a></li>
<li><a href="https://mp.weixin.qq.com/s/Xxm7ok-m9hdufn6ui10lMQ">面试官：说说你对 React diff 的理解？原理是什么？</a></li>
<li><a href="https://juejin.cn/post/6994767057774444574#heading-10">React 源码系列之八：React 的 diff 算法</a></li>
<li><a href="https://mp.weixin.qq.com/s/K8mHbIwR6NMaIrutDzg61A">有 React fiber，为什么不需要 Vue fiber？</a></li>
</ol>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>从 0 到 1 系列</tag>
      </tags>
  </entry>
  <entry>
    <title>从 0 到 1 实现 React（四）final</title>
    <url>/2022/02/18/react/%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0React4/</url>
    <content><![CDATA[<p>截止目前，我们已经可以渲染 html 标签组件了，但还不支持 react 的函数组件，我们替换一下试试</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">- const profile = (</span></span><br><span class="line"><span class="deletion">-  &lt;div className=&quot;profile&quot;&gt;</span></span><br><span class="line"><span class="deletion">-    &lt;span className=&quot;profile-title&quot;&gt;title&lt;/span&gt;</span></span><br><span class="line"><span class="deletion">-     &lt;h3 className=&quot;profile-content&quot;&gt;content&lt;/h3&gt;</span></span><br><span class="line"><span class="deletion">-     我是一段文本</span></span><br><span class="line"><span class="deletion">-  &lt;/div&gt;</span></span><br><span class="line"><span class="deletion">- );</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ function App(props) &#123;</span></span><br><span class="line"><span class="addition">+   return &lt;h1&gt;Hi &#123;props.name&#125;&lt;/h1&gt;</span></span><br><span class="line"><span class="addition">+ &#125;</span></span><br><span class="line"><span class="addition">+ const profile = &lt;App name=&quot;foo&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line">const container = document.getElementById(&quot;root&quot;)</span><br><span class="line">Didact.render(profile, container)</span><br></pre></td></tr></table></figure>
<p>会发现报错了，因为函数组件要执行一下，才会返回 jsx</p>
<h2 id="支持函数组件"><a href="#支持函数组件" class="headerlink" title="支持函数组件"></a>支持函数组件</h2><p>函数组件有两个地方不同：</p>
<ul>
<li>函数组件的 fiber 没有 dom 节点</li>
<li>执行一下函数组件，才有 children</li>
</ul>
<h3 id="判断是否是函数组件"><a href="#判断是否是函数组件" class="headerlink" title="判断是否是函数组件"></a>判断是否是函数组件</h3><p>所以在 <code>performUnitOfWork</code> 方法中，我们要先检测组件是否是函数组件，然后将分别处理的逻辑提取到两个函数 <code>updateHostComponent</code> 和 <code>updateFunctionComponent</code> 内：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">function performUnitOfWork(fiber) &#123;</span><br><span class="line"><span class="deletion">-  if (!fiber.dom) &#123;</span></span><br><span class="line"><span class="deletion">-    fiber.dom = createDom(fiber)</span></span><br><span class="line"><span class="deletion">-  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-  const elements = fiber.props.children</span></span><br><span class="line"><span class="deletion">-  reconcileChildren(fiber, elements)</span></span><br><span class="line">  </span><br><span class="line"><span class="addition">+  const isFunctionComponent =</span></span><br><span class="line"><span class="addition">+    fiber.type instanceof Function</span></span><br><span class="line"><span class="addition">+  if (isFunctionComponent) &#123;</span></span><br><span class="line"><span class="addition">+    updateFunctionComponent(fiber)</span></span><br><span class="line"><span class="addition">+  &#125; else &#123;</span></span><br><span class="line"><span class="addition">+    updateHostComponent(fiber)</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"></span><br><span class="line">  if (fiber.child) &#123;</span><br><span class="line">    return fiber.child</span><br><span class="line">  &#125;</span><br><span class="line">  let nextFiber = fiber</span><br><span class="line">  while (nextFiber) &#123;</span><br><span class="line">    if (nextFiber.sibling) &#123;</span><br><span class="line">      return nextFiber.sibling</span><br><span class="line">    &#125;</span><br><span class="line">    nextFiber = nextFiber.parent</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 处理普通组件</span><br><span class="line"><span class="addition">+ function updateHostComponent(fiber) &#123;</span></span><br><span class="line"><span class="addition">+   if (!fiber.dom) &#123;</span></span><br><span class="line"><span class="addition">+     fiber.dom = createDom(fiber)</span></span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line"><span class="addition">+   reconcileChildren(fiber, fiber.props.children)</span></span><br><span class="line"><span class="addition">+ &#125;</span></span><br><span class="line"></span><br><span class="line">// 处理函数组件</span><br><span class="line"><span class="addition">+ function updateFunctionComponent(fiber) &#123;</span></span><br><span class="line"><span class="addition">+   // 执行函数组件，返回jsx</span></span><br><span class="line"><span class="addition">+   const children = [fiber.type(fiber.props)]</span></span><br><span class="line"><span class="addition">+   reconcileChildren(fiber, children)</span></span><br><span class="line"><span class="addition">+ &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="处理函数组件没有-dom-的问题"><a href="#处理函数组件没有-dom-的问题" class="headerlink" title="处理函数组件没有 dom 的问题"></a>处理函数组件没有 dom 的问题</h3><p>因为函数组件会出现没有 dom 的情况，那 <code>commitWork</code> 方法的逻辑就要修正一下，通过<code>递归</code>往上去找有 dom 的父元素</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// 递归插入所有 dom</span><br><span class="line">function commitWork(fiber) &#123;</span><br><span class="line">  if (!fiber) return</span><br><span class="line"></span><br><span class="line"><span class="deletion">-  const domParent = fiber.parent.dom</span></span><br><span class="line"><span class="addition">+  let domParentFiber = fiber.parent</span></span><br><span class="line"><span class="addition">+  while (!domParentFiber.dom) &#123;</span></span><br><span class="line"><span class="addition">+    domParentFiber = domParentFiber.parent</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+  const domParent = domParentFiber.dom</span></span><br><span class="line"></span><br><span class="line">  if ( fiber.effectTag <span class="comment">=== &quot;PLACEMENT&quot; &amp;&amp; fiber.dom != null) &#123;</span></span><br><span class="line">    // 插入新 dom</span><br><span class="line">    domParent.appendChild(fiber.dom)</span><br><span class="line">    </span><br><span class="line">  // ...</span><br><span class="line">  </span><br><span class="line">   &#125; else if (fiber.effectTag <span class="comment">=== &quot;DELETION&quot;) &#123;</span></span><br><span class="line">    // 删除 dom</span><br><span class="line">    domParent.removeChild(fiber.dom)</span><br><span class="line">  &#125;</span><br><span class="line">  commitWork(fiber.child)</span><br><span class="line">  commitWork(fiber.sibling)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+ // 函数组件没有 dom，需要一直往上递归找父 dom</span></span><br><span class="line"><span class="addition">+ function commitDeletion(fiber, domParent) &#123;</span></span><br><span class="line"><span class="addition">+  if (fiber.dom) &#123;</span></span><br><span class="line"><span class="addition">+    domParent.removeChild(fiber.dom)</span></span><br><span class="line"><span class="addition">+  &#125; else &#123;</span></span><br><span class="line"><span class="addition">+    commitDeletion(fiber.child, domParent)</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h2><p>截止目前，我们还不支持 <code>hooks</code>，我们替换一个有 hooks 的 demo 来支持一下：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">- function App(props) &#123;</span></span><br><span class="line"><span class="deletion">-   return &lt;h1&gt;Hi &#123;props.name&#125;&lt;/h1&gt;</span></span><br><span class="line"><span class="deletion">- &#125;</span></span><br><span class="line"><span class="deletion">- const profile = &lt;App name=&quot;foo&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ function Counter() &#123;</span></span><br><span class="line"><span class="addition">+   const [state, setState] = Didact.useState(1)</span></span><br><span class="line"><span class="addition">+   return (</span></span><br><span class="line"><span class="addition">+     &lt;div&gt;</span></span><br><span class="line"><span class="addition">+       &lt;button onClick=&#123;() =&gt; setState(c =&gt; c + 1)&#125;&gt;</span></span><br><span class="line"><span class="addition">+         点击 + 1</span></span><br><span class="line"><span class="addition">+       &lt;/button&gt;</span></span><br><span class="line"><span class="addition">+       &lt;p&gt;Count: &#123;state&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="addition">+     &lt;/div&gt;</span></span><br><span class="line"><span class="addition">+   )</span></span><br><span class="line"><span class="addition">+ &#125;</span></span><br><span class="line"><span class="addition">+ const profile = &lt;Counter /&gt;</span></span><br><span class="line"></span><br><span class="line">const container = document.getElementById(&quot;root&quot;)</span><br><span class="line">Didact.render(profile, container)</span><br></pre></td></tr></table></figure>

<h3 id="fiber-新增-hooks-属性"><a href="#fiber-新增-hooks-属性" class="headerlink" title="fiber 新增 hooks 属性"></a>fiber 新增 hooks 属性</h3><p>保存当前被设置 <code>hooks</code> 的 <code>fiber</code>，因为 <code>useState</code> 可以调用多次，所以需要维护一个 <code>hooks</code> 队列，用来存放多个<code>hook</code>，修改 <code>updateFunctionComponent</code>方法：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+ let wipFiber = null</span></span><br><span class="line"><span class="addition">+ let hookIndex = null</span></span><br><span class="line"></span><br><span class="line">function updateFunctionComponent(fiber) &#123;</span><br><span class="line"><span class="addition">+   wipFiber = fiber</span></span><br><span class="line"><span class="addition">+   hookIndex = 0</span></span><br><span class="line"><span class="addition">+   wipFiber.hooks = []</span></span><br><span class="line">    // 执行函数组件，返回jsx</span><br><span class="line">    const children = [fiber.type(fiber.props)]</span><br><span class="line">    reconcileChildren(fiber, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现-useState"><a href="#实现-useState" class="headerlink" title="实现 useState"></a>实现 useState</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useState</span>(<span class="params">initial</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> oldFiber = wipFiber.<span class="property">alternate</span>;</span><br><span class="line">  <span class="keyword">const</span> oldHook = oldFiber?.<span class="property">hooks</span> &amp;&amp; oldFiber.<span class="property">hooks</span>[hookIndex];</span><br><span class="line">  <span class="comment">// 设置新 hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = &#123;</span><br><span class="line">    <span class="attr">state</span>: oldHook ? oldHook.<span class="property">state</span> : initial,</span><br><span class="line">    <span class="attr">queue</span>: [],</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行老 hook 队列里的 setState 方法</span></span><br><span class="line">  <span class="keyword">const</span> actions = oldHook ? oldHook.<span class="property">queue</span> : []</span><br><span class="line">  actions.<span class="title function_">forEach</span>(<span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    hook.<span class="property">state</span> = <span class="title function_">action</span>(hook.<span class="property">state</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">setState</span> = action =&gt; &#123;</span><br><span class="line">    hook.<span class="property">queue</span>.<span class="title function_">push</span>(action)</span><br><span class="line">    <span class="comment">// 设置 nextUnitOfWork，从而在下一次闲时启动更新</span></span><br><span class="line">    wipRoot = &#123;</span><br><span class="line">      <span class="attr">dom</span>: currentRoot.<span class="property">dom</span>,</span><br><span class="line">      <span class="attr">props</span>: currentRoot.<span class="property">props</span>,</span><br><span class="line">      <span class="attr">alternate</span>: currentRoot,</span><br><span class="line">    &#125;</span><br><span class="line">    nextUnitOfWork = wipRoot</span><br><span class="line">    deletions = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wipFiber.<span class="property">hooks</span>.<span class="title function_">push</span>(hook)</span><br><span class="line">  hookIndex++</span><br><span class="line">  <span class="keyword">return</span> [hook.<span class="property">state</span>, setState]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>因为是通过当前 <code>index</code> 去找 <code>老hooks</code> 数组里对应的 <code>hook</code>，<code>新老hooks</code>数组里的<code>hook</code>是一一对应的，所以在 react 中 hook 不能放在条件判断语句内，这样 hook 在数组里的位置就会有变化，新旧的 index 不能对应起来</li>
<li><code>useState</code> 除了要返回最后计算的<code>state</code>和对应的<code>setState</code>方法，还要在这之前执行上一次<code>hooks</code>队列里的任务</li>
<li>每调用一次<code>useState</code>，<code>hook</code>队列就又入列一个任务</li>
<li>执行<code>setState</code>，会赋值<code>nextUnitOfWork</code>，这样就启动了浏览器闲时处理的开关，下一次闲时就会更新<code>diff</code></li>
<li>为了简单，这里的<code>setState</code>只支持传入一个函数，不能传入一个值，但要支持其实也很简单，判断一下是个值就转换成一个返回该值的函数，即可</li>
</ul>
<p>到这里，我们就实现了自己的一个 react——<code>Didact</code></p>
<p><a href="https://github.com/chao31/Didact/blob/feature/chao31_final/index.js">整体源码</a></p>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>从 0 到 1 系列</tag>
      </tags>
  </entry>
  <entry>
    <title>如何写出高质量的 React 代码</title>
    <url>/2021/04/10/react/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84React%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="样式与-CSS"><a href="#样式与-CSS" class="headerlink" title="样式与 CSS"></a>样式与 CSS</h2><h3 id="style"><a href="#style" class="headerlink" title="style"></a>style</h3><p>👎🏼 👎🏼 👎🏼：不推荐将 <code>style</code> 作为设置样式的主要方式，一般用在<code>动态计算样式</code>的时候</p>
<p>👍🏽 👍🏽 👍🏽：推荐在多数情况下使用<code>className</code>属性，从性能角度来说，CSS 的 class 通常比行内样式更好。</p>
<h3 id="当-className-条件判断较多时"><a href="#当-className-条件判断较多时" class="headerlink" title="当 className 条件判断较多时"></a>当 <code>className</code> 条件判断较多时</h3><p>通过引入<a href="https://www.npmjs.com/package/classnames#usage-with-reactjs">classnames</a>来简化自己的代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install classnames</span><br></pre></td></tr></table></figure>

<p>Usage:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">&#x27;classnames&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; isHovered, buttonType &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">    <span class="keyword">var</span> btnClass = <span class="title function_">classNames</span>(&#123;</span><br><span class="line">      <span class="attr">btn</span>: <span class="literal">true</span>,</span><br><span class="line">      isHovered,</span><br><span class="line">      [<span class="string">`btn-<span class="subst">$&#123;buttonType&#125;</span>`</span>]: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&#123;btnClass&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出 setState</title>
    <url>/2022/12/27/react/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAsetState/</url>
    <content><![CDATA[<p>读完本文你将知道：</p>
<ul>
<li><code>setState</code> 不会立即改变 <code>React</code> 组件中 <code>state</code> 的值 (异步)<ul>
<li><code>setState</code>是<code>异步</code>的，包括在<code>setTimeout</code>里也是异步的 (很多文章说在 <code>setTimeout</code> 里是<code>同步</code>的，我这里用 <code>react18</code> 测试依然是<code>异步</code>)</li>
</ul>
</li>
<li><code>setState</code> 通过引发一次组件的更新过程来引发重新绘制</li>
<li>多次 <code>setState</code> 函数调用产生的效果会合并（批处理）</li>
</ul>
<h2 id="setState-的特性——批处理"><a href="#setState-的特性——批处理" class="headerlink" title="setState 的特性——批处理"></a>setState 的特性——批处理</h2><p>如果在<code>同一周期</code>多次调用 <code>setState</code> ，后调用的 <code>setState</code> 将覆盖先调用的 <code>setState</code> 的值，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// state.count === 0</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span>&#125;);</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span>&#125;);</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span>&#125;);</span><br><span class="line"><span class="comment">// state.count === 1</span></span><br></pre></td></tr></table></figure>
<p>执行 <code>3</code> 次 <code>+1</code>，但最后只加了 <code>1</code> 次；若在 <code>setTimeout</code> 中多次调用，结果也一样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// state.count === 0</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span>&#125;);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// state.count === 1</span></span><br></pre></td></tr></table></figure>
<p>因为这样的操作相当于 <code>Object.assign</code>,最后一个会把前面的都给覆盖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(</span><br><span class="line">  state,</span><br><span class="line">  &#123;<span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span>&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="同一个时期，多次调用，会合并"><a href="#同一个时期，多次调用，会合并" class="headerlink" title="同一个时期，多次调用，会合并"></a>同一个时期，多次调用，会合并</h3><p><code>函数组件</code>和<code>类组件</code>在同一时期，多次调用<code>setState</code>，会合并。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">DemoState</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> [number, setNumber] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setNumber</span>(number+<span class="number">1</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(number); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">setNumber</span>(number+<span class="number">1</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(number); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">setNumber</span>(number+<span class="number">1</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(number); <span class="comment">// 0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123; number &#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123; add() &#125;&#125; &gt;点击加 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面展示 number 为 1</span></span><br></pre></td></tr></table></figure>
<p>若上面的 <code>3</code> 次 <code>+1</code> 都放在 <code>setTimeout</code> 执行，也是会<code>合并</code>的，并且仍然是异步 (很多文章说在 <code>setTimeout</code> 里是<code>同步</code>的，我这里用 <code>react18</code> 测试依然是<code>异步</code>)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">DemoState</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> [number, setNumber] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setNumber</span>(number+<span class="number">1</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(number); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">      <span class="title function_">setNumber</span>(number+<span class="number">1</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(number); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">      <span class="title function_">setNumber</span>(number+<span class="number">1</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(number); <span class="comment">// 0</span></span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123; number &#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123; add() &#125;&#125; &gt;点击加 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面展示 number 为 1</span></span><br></pre></td></tr></table></figure>

<h3 id="函数组件在不同时期，会合并"><a href="#函数组件在不同时期，会合并" class="headerlink" title="函数组件在不同时期，会合并"></a>函数组件在不同时期，会合并</h3><p><code>函数组件</code>多次调用 <code>+1</code> 操作，分别在不用时期：一个在 setTimeout <code>外</code>调用，另一个在 setTimeout <code>内</code>调用。最后<code>合并</code>了，<code>只调用了 1 次 +1</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">DemoState</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> [number, setNumber] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setNumber</span>(number+<span class="number">1</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(number); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setNumber</span>(number+<span class="number">1</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(number); <span class="comment">// 0</span></span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123; number &#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123; add() &#125;&#125; &gt;点击加 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面展示 number 为 1</span></span><br></pre></td></tr></table></figure>

<h3 id="类组件在不同时期，不会合并"><a href="#类组件在不同时期，不会合并" class="headerlink" title="类组件在不同时期，不会合并"></a>类组件在不同时期，不会合并</h3><p><code>类组件</code>多次调用 <code>+1</code> 操作，分别在不用时期：一个在 setTimeout <code>外</code>调用，另一个在 setTimeout <code>内</code>调用。最后<code>没合并</code>，<code>2 次 +1 都被调用</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DemoState2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">number</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">number</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">number</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span>&#125;);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>); <span class="comment">// 1</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123; this.state.number &#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.add&#125;</span> &gt;</span>点击加 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面展示 number 为 2</span></span><br></pre></td></tr></table></figure>

<p>当前测试 <code>react</code> 版本：<code>18.1.0</code>。</p>
<p>这可能是 react 的一个 bug，看看后面会不会在函数组件和类组件中保持一致。</p>
<p>下面看看由<code>批处理</code>引发的问题：</p>
<h2 id="问题-1：连续使用-setState，为什么不能实时改变"><a href="#问题-1：连续使用-setState，为什么不能实时改变" class="headerlink" title="问题 1：连续使用 setState，为什么不能实时改变"></a>问题 1：连续使用 setState，为什么不能实时改变</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">state.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span>&#125;); </span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span>&#125;); </span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span>&#125;); </span><br><span class="line"><span class="comment">// state.count === 1，不是 3</span></span><br></pre></td></tr></table></figure>

<p>因为 <code>this.setState</code> 方法为会进行批处理，后调的 <code>setState</code> 会覆盖统一周期内先调用的 <code>setState</code> 的值，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">state.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">2</span>&#125;); </span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">3</span>&#125;); </span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">4</span>&#125;); </span><br><span class="line"><span class="comment">// state.count === 4</span></span><br></pre></td></tr></table></figure>

<h2 id="问题-2：为什么要-setState，而不是直接-this-state-xx-x3D-oo"><a href="#问题-2：为什么要-setState，而不是直接-this-state-xx-x3D-oo" class="headerlink" title="问题 2：为什么要 setState，而不是直接 this.state.xx &#x3D; oo?"></a>问题 2：为什么要 setState，而不是直接 this.state.xx &#x3D; oo?</h2><ol>
<li><code>setState</code> 不仅仅修改了 <code>this.state</code> 的值，更重要的是它会触发 <code>React</code> 的<code>更新机制</code>，会进行 <code>diff</code>，然后将 <code>patch</code> 部分更新到真实 <code>dom</code> 里</li>
<li>如果直接 <code>this.state.xx = oo</code> 的话，<code>state</code> 的值确实会改，但是它不会驱动 <code>React</code> 重渲染，不会触发后续生命周期，如 <code>shouldComponentUpdate</code>、<code>render</code> 等一系列函数的调用。</li>
<li>对于<code>批处理</code>，多次<code>setState</code> 只产生<code>一次</code>重新渲染，将对 <code>Virtual DOM</code> 和 <code>DOM 树</code>操作降到<code>最小</code>，用于<code>提高性能</code></li>
</ol>
<h2 id="问题-3：那为什么会出现异步的情况呢？（为什么这么设计？）"><a href="#问题-3：那为什么会出现异步的情况呢？（为什么这么设计？）" class="headerlink" title="问题 3：那为什么会出现异步的情况呢？（为什么这么设计？）"></a>问题 3：那为什么会出现异步的情况呢？（为什么这么设计？）</h2><p>因为<code>性能优化</code>。假如每次 <code>setState</code> 都要更新数据，更新过程就要走五个生命周期，走完一轮生命周期再拿 <code>render</code> 函数的结果去做 <code>diff</code> 对比和更新真实 <code>DOM</code>，会很耗时间。所以将每次调用都放一起做一次性处理，能降低对 DOM 的操作，提高应用性能</p>
<h2 id="问题-4：那如何在表现出异步的函数里可以准确拿到更新后的-state-呢？"><a href="#问题-4：那如何在表现出异步的函数里可以准确拿到更新后的-state-呢？" class="headerlink" title="问题 4：那如何在表现出异步的函数里可以准确拿到更新后的 state 呢？"></a>问题 4：那如何在表现出异步的函数里可以准确拿到更新后的 state 呢？</h2><ul>
<li><code>setState(stateChange[, callback])</code></li>
<li><code>setState((state, props) =&gt; stateChange[, callback])</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">onHandleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(</span><br><span class="line">    &#123;<span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span>,&#125;,</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;点击之后的回调&quot;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>); <span class="comment">// 最新值</span></span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;函数模式&quot;</span>, state.<span class="property">count</span>);</span><br><span class="line"> <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span> &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>从 0 到 1 系列</tag>
      </tags>
  </entry>
  <entry>
    <title>从 0 到 1 实现 React（三）实现 diff</title>
    <url>/2022/02/15/react/%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0React3/</url>
    <content><![CDATA[<p>截止到目前，我们的 react 已经可以完成首次渲染，但还不能响应式更新和删除，下面我们来实现一下。</p>
<h2 id="保存-old-fiber"><a href="#保存-old-fiber" class="headerlink" title="保存 old fiber"></a>保存 old fiber</h2><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// ...</span><br><span class="line"></span><br><span class="line">function render(element, container) &#123;</span><br><span class="line">  // 虽然后面会给这个对象添加更多属性，但这里是第一个 fiber</span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    dom: container,</span><br><span class="line">    props: &#123;</span><br><span class="line">      children: [element],</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="addition">+   alternate: currentRoot,</span></span><br><span class="line">  &#125;</span><br><span class="line">  nextUnitOfWork = wipRoot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> function commitRoot() &#123;</span><br><span class="line">   commitWork(wipRoot.child)</span><br><span class="line"><span class="addition">+  // commit 后，新 fiber 就变成了旧 fiber，更新一下旧 fiber</span></span><br><span class="line"><span class="addition">+  currentRoot = wipRoot</span></span><br><span class="line">   wipRoot = null</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">let nextUnitOfWork = null</span><br><span class="line"><span class="addition">+ // 当有新 fiber root 后，会拿它跟当前 root fiber 做对比，所以需要缓存当前 root fiber</span></span><br><span class="line"><span class="addition">+ let currentRoot = null</span></span><br><span class="line">let wipRoot = null</span><br><span class="line"></span><br><span class="line">//...</span><br></pre></td></tr></table></figure>
<ul>
<li>缓存当前的<code>root fiber</code>，以便有了新的<code>root fiber</code>后可以进行<code>diff</code></li>
<li>给每一个 fiber 都新增一个<code>alternate</code>属性，用于存放旧 fiber</li>
</ul>
<h2 id="提取-diff-部分并进行封装"><a href="#提取-diff-部分并进行封装" class="headerlink" title="提取 diff 部分并进行封装"></a>提取 diff 部分并进行封装</h2><p>之前我们处理 diff 部分是在<code>performUnitOfWork</code>方法里，现在将其提出来，封装到新方法<code>reconcileChildren</code>里</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">function performUnitOfWork(fiber) &#123;</span><br><span class="line">  if (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDom(fiber)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const elements = fiber.props.children</span><br><span class="line"></span><br><span class="line"><span class="addition">+  reconcileChildren(fiber, elements)</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-    let index = 0</span></span><br><span class="line"><span class="deletion">-    let prevSibling = null</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-    // 1. 遍历当前fiber的children</span></span><br><span class="line"><span class="deletion">-    // 2. 给children里的每个child指定3个指针，分别指向其 父、子、兄弟三个节点</span></span><br><span class="line"><span class="deletion">-    while (index &lt; elements.length) &#123;</span></span><br><span class="line"><span class="deletion">-      const element = elements[index]</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-      const newFiber = &#123;</span></span><br><span class="line"><span class="deletion">-        type: element.type,</span></span><br><span class="line"><span class="deletion">-        props: element.props,</span></span><br><span class="line"><span class="deletion">-        parent: fiber,</span></span><br><span class="line"><span class="deletion">-        dom: null,</span></span><br><span class="line"><span class="deletion">-      &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-      if (index === 0) &#123;</span></span><br><span class="line"><span class="deletion">-        fiber.child = newFiber</span></span><br><span class="line"><span class="deletion">-      &#125; else &#123;</span></span><br><span class="line"><span class="deletion">-        prevSibling.sibling = newFiber</span></span><br><span class="line"><span class="deletion">-      &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-      prevSibling = newFiber</span></span><br><span class="line"><span class="deletion">-      index++</span></span><br><span class="line"><span class="deletion">-    &#125;</span></span><br><span class="line"></span><br><span class="line">  // 下面的操作是返回下一个单元——nextUnitOfWork</span><br><span class="line">  // 1. 优先找child</span><br><span class="line">  // 2. 没有child找兄弟</span><br><span class="line">  // 3. 没有兄弟，找叔叔，也就是递归到父元素的兄弟</span><br><span class="line">  // 4. 没有叔叔就一直往上递归...</span><br><span class="line">  if (fiber.child) &#123;</span><br><span class="line">    return fiber.child</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="addition">+ function reconcileChildren(wipFiber, elements) &#123;</span></span><br><span class="line"><span class="addition">+     let index = 0</span></span><br><span class="line"><span class="addition">+     let prevSibling = null</span></span><br><span class="line"><span class="addition">+     ...</span></span><br><span class="line"><span class="addition">+ &#125;</span></span><br></pre></td></tr></table></figure>

<p>在 <code>reconcileChildren</code> 方法中，把 <code>new fiber</code> 和 <code>old fiber</code> 表示出来 (便于 TODO 部分进行对比)，并将<code>old fiber</code>的变化也加入到<code>while</code>迭代中来</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">function reconcileChildren(wipFiber, elements) &#123;</span><br><span class="line">  let index = 0</span><br><span class="line"><span class="addition">+ // 从 alternate 找到旧父fiber的第一个child，作为第一个要对比的old fiber</span></span><br><span class="line"><span class="addition">+ let oldFiber = wipFiber.alternate &amp;&amp; wipFiber.alternate.child</span></span><br><span class="line">  let prevSibling = null</span><br><span class="line"></span><br><span class="line">  // 1. 遍历当前fiber的children</span><br><span class="line">  // 2. 给children里的每个child指定3个指针，分别指向其 父、子、兄弟三个节点</span><br><span class="line"><span class="deletion">-  while (index &lt; elements.length) &#123;</span></span><br><span class="line"><span class="addition">+  while (index &lt; elements.length || oldFiber != null) &#123;</span></span><br><span class="line">    const element = elements[index]</span><br><span class="line"></span><br><span class="line"><span class="addition">+    let newFiber = null</span></span><br><span class="line"><span class="deletion">-    const newFiber = &#123;</span></span><br><span class="line"><span class="deletion">-      type: element.type,</span></span><br><span class="line"><span class="deletion">-      props: element.props,</span></span><br><span class="line"><span class="deletion">-      parent: wipFiber,</span></span><br><span class="line"><span class="deletion">-      dom: null,</span></span><br><span class="line"><span class="deletion">-    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ // TODO diff部分将在这里实现</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+    if (oldFiber) &#123;</span></span><br><span class="line"><span class="addition">+        oldFiber = oldFiber.sibling</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">    </span><br><span class="line">    if (index <span class="comment">=== 0) &#123;</span></span><br><span class="line">      wipFiber.child = newFiber</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      prevSibling.sibling = newFiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prevSibling = newFiber</span><br><span class="line">    index++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们来完成 <code>reconcileChildren</code> 方法里的<em>TODO</em>部分，也就是 diff</p>
<h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p>这里的 diff 主要是更新 fiber 的属性，还没有到真实的操作 dom</p>
<h3 id="对比的策略"><a href="#对比的策略" class="headerlink" title="对比的策略"></a>对比的策略</h3><ul>
<li>新、老 fiber 的 type 相同：保留 dom，更新属性</li>
<li>新、老 fiber 的 type 不同：创建新 fiber，删除旧 fiber</li>
</ul>
<p>下面写出大体框架</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">while (index &lt; elements.length || oldFiber != null) &#123;</span><br><span class="line">    const element = elements[index]</span><br><span class="line"></span><br><span class="line">    let newFiber = null</span><br><span class="line">    </span><br><span class="line"><span class="addition">+   const sameType =</span></span><br><span class="line"><span class="addition">+   oldFiber &amp;&amp;</span></span><br><span class="line"><span class="addition">+   element &amp;&amp;</span></span><br><span class="line"><span class="addition">+   element.type == oldFiber.type</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   if (sameType) &#123;</span></span><br><span class="line">     // TODO update the node</span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line"><span class="addition">+   if (element &amp;&amp; !sameType) &#123;</span></span><br><span class="line">     // TODO add this node</span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line"><span class="addition">+   if (oldFiber &amp;&amp; !sameType) &#123;</span></span><br><span class="line">     // TODO delete the oldFiber&#x27;s node</span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line">    </span><br><span class="line">    if (oldFiber) &#123;</span><br><span class="line">      oldFiber = oldFiber.sibling</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (index <span class="comment">=== 0) &#123;</span></span><br><span class="line">      wipFiber.child = newFiber</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      prevSibling.sibling = newFiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prevSibling = newFiber</span><br><span class="line">    index++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对比旧-fiber，创建新-fiber"><a href="#对比旧-fiber，创建新-fiber" class="headerlink" title="对比旧 fiber，创建新 fiber"></a>对比旧 fiber，创建新 fiber</h3><p>下面我们来完成上面 3 个 <em>TODO</em> 部分：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sameType =</span><br><span class="line">  oldFiber &amp;&amp;</span><br><span class="line">  element &amp;&amp;</span><br><span class="line">  element.<span class="property">type</span> == oldFiber.<span class="property">type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">  newFiber = &#123;</span><br><span class="line">    <span class="attr">type</span>: oldFiber.<span class="property">type</span>,</span><br><span class="line">    <span class="attr">props</span>: element.<span class="property">props</span>,</span><br><span class="line">    <span class="attr">dom</span>: oldFiber.<span class="property">dom</span>,</span><br><span class="line">    <span class="attr">parent</span>: wipFiber,</span><br><span class="line">    <span class="attr">alternate</span>: oldFiber,</span><br><span class="line">    <span class="attr">effectTag</span>: <span class="string">&quot;UPDATE&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">  newFiber = &#123;</span><br><span class="line">    <span class="attr">type</span>: element.<span class="property">type</span>,</span><br><span class="line">    <span class="attr">props</span>: element.<span class="property">props</span>,</span><br><span class="line">    <span class="attr">dom</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">parent</span>: wipFiber,</span><br><span class="line">    <span class="attr">alternate</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">effectTag</span>: <span class="string">&quot;PLACEMENT&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">  oldFiber.<span class="property">effectTag</span> = <span class="string">&quot;DELETION&quot;</span></span><br><span class="line">  deletions.<span class="title function_">push</span>(oldFiber)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>给每个 fiber 新增了<code>effectTag</code>属性，后面统一处理的时候，就知道是<code>更新</code>、<code>删除</code>还是<code>插入</code></li>
<li>新增了<code>deletions</code>数组，存放所有待删除的<code>fiber</code>，后面统一删除里面的<code>dom</code></li>
</ul>
<p>上面的代码已经完成了迭代所有旧 fiber，并将其更新为了新 fiber</p>
<h3 id="处理-deletions-数组"><a href="#处理-deletions-数组" class="headerlink" title="处理 deletions 数组"></a>处理 deletions 数组</h3><p>清空<code>deletions</code>数组将在 <code>commit</code> 这个阶段进行处理，而我们会将包括删除在内的所有更新操作都放到<code>commitWork</code>方法里去做</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">function render(element, container) &#123;</span><br><span class="line">  // 虽然后面会给这个对象添加更多属性，但这里是第一个 fiber</span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    dom: container,</span><br><span class="line">    props: &#123;</span><br><span class="line">      children: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">    alternate: currentRoot,</span><br><span class="line">  &#125;</span><br><span class="line"><span class="addition">+ deletions = []</span></span><br><span class="line">  nextUnitOfWork = wipRoot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function commitRoot() &#123;</span><br><span class="line"><span class="addition">+  deletions.forEach(commitWork)</span></span><br><span class="line">  commitWork(wipRoot.child)</span><br><span class="line">  currentRoot = wipRoot</span><br><span class="line">  wipRoot = null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let nextUnitOfWork = null</span><br><span class="line">let currentRoot = null</span><br><span class="line">let wipRoot = null</span><br><span class="line"><span class="addition">+ let deletions = null</span></span><br></pre></td></tr></table></figure>

<h3 id="commitWork"><a href="#commitWork" class="headerlink" title="commitWork"></a>commitWork</h3><p>下面我们来完善 <code>commitWork</code> 方法，<code>commitWork</code>除了插入，还有删除和更新</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">function commitWork(fiber) &#123;</span><br><span class="line">  if (!fiber) return</span><br><span class="line"></span><br><span class="line">  const domParent = fiber.parent.dom</span><br><span class="line"><span class="deletion">- domParent.appendChild(fiber.dom)</span></span><br><span class="line"><span class="addition">+ if ( fiber.effectTag === &quot;PLACEMENT&quot; &amp;&amp; fiber.dom != null) &#123;</span></span><br><span class="line"><span class="addition">+   // 插入新dom</span></span><br><span class="line"><span class="addition">+   domParent.appendChild(fiber.dom)</span></span><br><span class="line"><span class="addition">+ &#125; else if (fiber.effectTag === &quot;UPDATE&quot; &amp;&amp; fiber.dom != null) &#123;</span></span><br><span class="line"><span class="addition">+   // 更新dom属性</span></span><br><span class="line"><span class="addition">+   updateDom(</span></span><br><span class="line"><span class="addition">+     fiber.dom,</span></span><br><span class="line"><span class="addition">+     fiber.alternate.props,</span></span><br><span class="line"><span class="addition">+     fiber.props</span></span><br><span class="line"><span class="addition">+   )</span></span><br><span class="line"><span class="addition">+ &#125; else if (fiber.effectTag === &quot;DELETION&quot;) &#123;</span></span><br><span class="line"><span class="addition">+   // 删除dom</span></span><br><span class="line"><span class="addition">+   domParent.removeChild(fiber.dom)</span></span><br><span class="line"><span class="addition">+ &#125;</span></span><br><span class="line">  commitWork(fiber.child)</span><br><span class="line">  commitWork(fiber.sibling)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+ function updateDom(dom, prevProps, nextProps) &#123;</span></span><br><span class="line"><span class="addition">+   // TODO</span></span><br><span class="line"><span class="addition">+ &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="updateDom"><a href="#updateDom" class="headerlink" title="updateDom"></a>updateDom</h3><p>上面新增了一个 <code>updateDom</code> 方法，<code>updateDom</code> 会将所有的 diff 真实反应到的 dom 上，现在我们来实现它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否是 dom 事件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isEvent</span> = key =&gt; key.<span class="title function_">startsWith</span>(<span class="string">&quot;on&quot;</span>)</span><br><span class="line"><span class="comment">// 不是 dom 事件，也不是 children 属性，才是要更新的属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isProperty</span> = key =&gt;</span><br><span class="line">  key !== <span class="string">&quot;children&quot;</span> &amp;&amp; !<span class="title function_">isEvent</span>(key)</span><br><span class="line"><span class="comment">// 判断是否是新属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isNew</span> = (<span class="params">prev, next</span>) =&gt; <span class="function"><span class="params">key</span> =&gt;</span></span><br><span class="line">  prev[key] !== next[key]</span><br><span class="line"><span class="comment">// 判断属性是否被删除</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isGone</span> = (<span class="params">prev, next</span>) =&gt; <span class="function"><span class="params">key</span> =&gt;</span> !(key <span class="keyword">in</span> next)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateDom</span>(<span class="params">dom, prevProps, nextProps</span>) &#123;</span><br><span class="line">  <span class="comment">// 删除旧的 dom 事件监听函数</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(prevProps)</span><br><span class="line">    .<span class="title function_">filter</span>(isEvent)</span><br><span class="line">    .<span class="title function_">filter</span>(</span><br><span class="line">      <span class="function"><span class="params">key</span> =&gt;</span></span><br><span class="line">        !(key <span class="keyword">in</span> nextProps) ||</span><br><span class="line">        <span class="title function_">isNew</span>(prevProps, nextProps)(key)</span><br><span class="line">    )</span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> eventType = name</span><br><span class="line">        .<span class="title function_">toLowerCase</span>()</span><br><span class="line">        .<span class="title function_">substring</span>(<span class="number">2</span>)</span><br><span class="line">      dom.<span class="title function_">removeEventListener</span>(</span><br><span class="line">        eventType,</span><br><span class="line">        prevProps[name]</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除旧的属性</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(prevProps)</span><br><span class="line">    .<span class="title function_">filter</span>(isProperty)</span><br><span class="line">    .<span class="title function_">filter</span>(<span class="title function_">isGone</span>(prevProps, nextProps))</span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom[name] = <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置新的属性</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(nextProps)</span><br><span class="line">    .<span class="title function_">filter</span>(isProperty)</span><br><span class="line">    .<span class="title function_">filter</span>(<span class="title function_">isNew</span>(prevProps, nextProps))</span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom[name] = nextProps[name]</span><br><span class="line">    &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置新的 dom 事件监听函数</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(nextProps)</span><br><span class="line">    .<span class="title function_">filter</span>(isEvent)</span><br><span class="line">    .<span class="title function_">filter</span>(<span class="title function_">isNew</span>(prevProps, nextProps))</span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> eventType = name</span><br><span class="line">        .<span class="title function_">toLowerCase</span>()</span><br><span class="line">        .<span class="title function_">substring</span>(<span class="number">2</span>)</span><br><span class="line">      dom.<span class="title function_">addEventListener</span>(</span><br><span class="line">        eventType,</span><br><span class="line">        nextProps[name]</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现很简单粗暴：删除旧属性，创建新属性</p>
<p>最后将 <code>createDom</code> 里的 dom 更新，也改为使用 <code>updateDom</code>：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">function createDom(fiber) &#123;</span><br><span class="line">  const dom =</span><br><span class="line">      fiber.type == &quot;TEXT_ELEMENT&quot;</span><br><span class="line">        ? document.createTextNode(&quot;&quot;)</span><br><span class="line">        : document.createElement(fiber.type)</span><br><span class="line"></span><br><span class="line"><span class="addition">+  updateDom(dom, &#123;&#125;, fiber.props);</span></span><br><span class="line"><span class="deletion">-  // children 被放到了 props 属性里，这里过滤掉 children</span></span><br><span class="line"><span class="deletion">-  const isProperty = key =&gt; key !== &quot;children&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-  Object.keys(fiber.props)</span></span><br><span class="line"><span class="deletion">-    .filter(isProperty)</span></span><br><span class="line"><span class="deletion">-    // 设置 dom 元素的属性，这里是简化版意思一下，直接赋值</span></span><br><span class="line"><span class="deletion">-    .forEach(name =&gt; dom[name] = fiber.props[name])</span></span><br><span class="line">  </span><br><span class="line">  return dom</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>现在，我们的 diff 基本实现</p>
<p><a href="https://github.com/chao31/Didact/blob/feature/chao31_diff/index.js">本章源码</a></p>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>从 0 到 1 系列</tag>
      </tags>
  </entry>
  <entry>
    <title>使用n来管理node版本</title>
    <url>/2019/03/08/node/%E4%BD%BF%E7%94%A8n%E6%9D%A5%E7%AE%A1%E7%90%86node%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<p>业务项目比较多，老项目使用的node版本比较低，为了管理多个版本的node，可以使用n工具来管理<br>n和nvm工具一样，但比它简洁</p>
<p>安装n</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install -g n</span><br></pre></td></tr></table></figure>

<p>下载特定版本的node</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会下载node/10.6.0</span></span><br><span class="line">n <span class="number">10.6</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<p>下载稳定版本</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">n stable</span><br></pre></td></tr></table></figure>

<p>删除特定版本</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">n rm <span class="number">10.6</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>

<p>切换版本</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">n</span><br><span class="line"></span><br><span class="line">   node/<span class="number">6.10</span><span class="number">.2</span></span><br><span class="line">   node/<span class="number">6.11</span><span class="number">.0</span></span><br><span class="line">   node/<span class="number">9.4</span><span class="number">.0</span></span><br><span class="line">o  node/<span class="number">10.6</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<p>使用特定版本来执行文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">n use <span class="number">10.6</span><span class="number">.0</span> index.<span class="property">js</span></span><br></pre></td></tr></table></figure>

<hr>
<p>若安装某个版本的node失败，发生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dyld: initializer function 0x0 not in mapped image for /usr/local/bin/node</span><br></pre></td></tr></table></figure>
<p>删除&#x2F;usr&#x2F;local&#x2F;n&#x2F;versions&#x2F;node下的所有node版本，然后重新使用n命令安装即可。</p>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>package.json和package-lock.json的区别</title>
    <url>/2017/08/11/node/package-json%E5%92%8Cpackage-lock-json%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>package.json文件记录项目中所需要的所有模块</p>
<blockquote>
<p>当你执行 <code>npm i</code>时，nodeJS会从你的package.json中读取所有的dependencies信息，package.json文件只记录你通过npm install方式安装的模块信息，而这些模块所依赖的其他子模块的信息不会记录。</p>
</blockquote>
<h3 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h3><p>package-lock.json文件锁定所有模块的版本号(包括主模块和所有依赖子模块)</p>
<blockquote>
<ul>
<li><code>package.json</code>文件只能锁定大版本，即版本号的第一位，不能锁定后面的小版本，你每次npm install时候拉取的该大版本下面最新的版本。所以为了稳定性考虑我们不能随意升级依赖包，而<code>package-lock.json</code>就是来解决包锁定不升级问题的。</li>
<li>从npm 5.x开始，项目中采用package-lock.json的方式来锁定依赖的方式来排除自动升级问题，原则上不允许删除以及不允许放入到.gitignore与.npmignore中。</li>
<li>为什么会有lock呢？“锁定依赖”。小王做一个项目，里边用到了node-sass，package.json文件里会有引用：“node-sass”: “^4.9.3”，假设4.9.3是最新版，发版之后，node-sass更新到4.9.4，这时，小张需要修改小王的项目，拉取代码，install，这时，小张拉取的项目的node-sass的版本会自动更新到大版本下的最新版4.9.4，可能这个版本会影响我们之前的功能，就有问题了。这时，lock文件就出现了，npm 5以上install都是走的lock文件版本，只要不是手动更新组件版本，都是不会自动更新依赖的，这就保证了应用程序依赖之间的关系是一致的，兼容的。</li>
</ul>
</blockquote>
<h3 id="升级package-lock-json"><a href="#升级package-lock-json" class="headerlink" title="升级package-lock.json"></a>升级package-lock.json</h3><p>如果要升级package-lock.json里面的库包，怎么操作呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install packageName </span><br><span class="line">// 或 </span><br><span class="line">npm install packageName@x.x.x</span><br></pre></td></tr></table></figure>

<h4 id="和-的区别"><a href="#和-的区别" class="headerlink" title="^和~的区别"></a>^和~的区别</h4><p>这里举个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">  &quot;classnames&quot;: &quot;2.2.5&quot;,   // 表示安装2.2.5的版本</span><br><span class="line">  &quot;antd&quot;: &quot;^3.1.4&quot;, // 表示安装3.1.4及以上的版本，但是不安装4.0.0</span><br><span class="line">  &quot;babel-plugin-import&quot;: &quot;~1.1.0&quot;, // &quot;~1.1.0&quot;,表示安装1.1.x的最新版本（不低于1.1.0），但是不安装1.2.x</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>指定版本：比如”classnames”: “2.2.5”，表示安装2.2.5的版本</li>
<li>波浪号<del>+指定版本：比如 “babel-plugin-import”: “</del>1.1.0”,表示安装1.1.x的最新版本（不低于1.1.0），但是不安装1.2.x，也就是说安装时不改变大版本号和次要版本号</li>
<li>^+指定版本：比如 “antd”: “^3.1.4”,，表示安装3.1.4及以上的版本，但是不安装4.0.0，也就是说安装时不改变大版本号。</li>
</ul>
</blockquote>
<p>大多数情况这种向新兼容依赖下载最新库包的时候都没有问题，可是因为npm是开源世界，各库包的版本语义可能并不相同，有的库包开发者并不遵守严格这一原则：相同大版本号的同一个库包，其接口符合兼容要求。这时候用户就很头疼了：在完全相同的一个nodejs的代码库，在不同时间或者不同npm下载源之下，下到的各依赖库包版本可能有所不同，因此其依赖库包行为特征也不同有时候甚至完全不兼容。</p>
<p>因此npm最新的版本就开始提供自动生成package-lock.json功能，为的是让开发者知道只要你保存了源文件，到一个新的机器上、或者新的下载源，只要按照这个package-lock.json所标示的具体版本下载依赖库包，就能确保所有库包与你上次安装的完全一样。</p>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue模板编译器原理</title>
    <url>/2020/06/14/vue/Vue%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E5%99%A8%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="模板渲染流程"><a href="#模板渲染流程" class="headerlink" title="模板渲染流程"></a>模板渲染流程</h2><ol>
<li>通过正则把模板转换成 AST 抽象语法树</li>
<li>优化器优化，标记所有的静态节点后，交由<code>代码生成器</code>生成渲染代码，</li>
<li>通过<code>渲染函数构建器</code>将渲染代码构建成一个<code>渲染函数</code>，</li>
<li>调用<code>渲染函数</code>，我们就可以得到目标模板的虚拟dom</li>
</ol>
<h2 id="AST抽象树的结构"><a href="#AST抽象树的结构" class="headerlink" title="AST抽象树的结构"></a>AST抽象树的结构</h2><p>AST的每个节点的结构如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">tag</span>: tagName, <span class="comment">// 标签名</span></span><br><span class="line">  <span class="attr">type</span>: <span class="number">1</span>, <span class="comment">// 元素类型</span></span><br><span class="line">  <span class="attr">children</span>: [], <span class="comment">// 孩子列表</span></span><br><span class="line">  attrs, <span class="comment">// 属性集合</span></span><br><span class="line">  <span class="attr">parent</span>: <span class="literal">null</span>, <span class="comment">// 父元素</span></span><br><span class="line">  <span class="attr">text</span>: <span class="literal">null</span> <span class="comment">// 文本节点内容</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>节点类型有：元素类型、文本类型、注释类型…</p>
<h2 id="生成AST抽象语法树"><a href="#生成AST抽象语法树" class="headerlink" title="生成AST抽象语法树"></a>生成AST抽象语法树</h2><p>模板引擎解析html字符串，每匹配到下面一种类型，就触发对应的钩子函数</p>
<ul>
<li>是否是开始标签，如：&lt;div …&gt; ；</li>
<li>是否是结束标签，如：</div> ;</li>
<li>是否是一段文本，如：<div>这是一段代码</div>中的文字；</li>
<li>是否是一个注释，如：<!--这是一个注释--></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">parseHTML</span>(html, &#123;</span><br><span class="line">    <span class="title function_">start</span>(<span class="params">tag, attrs, isUnary, startIndex, endIndex</span>) &#123;</span><br><span class="line">        <span class="comment">// 收集整理信息</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">end</span>(<span class="params">tag, startIndex, endIndex</span>) &#123;</span><br><span class="line">        <span class="comment">// 收集整理信息</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">chars</span>(<span class="params">text, startIndex, endIndex</span>) &#123;</span><br><span class="line">        <span class="comment">// 收集整理信息</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">comment</span>(<span class="params">text, startIndex, endIndex</span>) &#123;</span><br><span class="line">        <span class="comment">// 收集整理信息</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看到，我们将模板字符串是否存在作为while的终止条件，我们每匹配到 一种情况，就会将相应的文本从html中删除掉，这样不断循环下去，就会不断的触发响应的钩子函数收集数据，直至html变成空字符串退出循环，此时，我们已经将整个文本都解析完了。</p>
<h2 id="钩子函数start"><a href="#钩子函数start" class="headerlink" title="钩子函数start"></a>钩子函数start</h2><ul>
<li>根据传过来的标签名创建抽象语法树元素节点</li>
<li>检查一些非法属性或标签，并对一些特殊情况做预处理</li>
<li>解析attrs</li>
<li>解析指令v-if，v-for，v-once等</li>
<li>如果不是自闭标签的话，将当前元素加入到栈中，用于维护元素间的父子关系</li>
</ul>
<h2 id="钩子函数end"><a href="#钩子函数end" class="headerlink" title="钩子函数end"></a>钩子函数end</h2><ul>
<li>将栈顶元素弹出（因为当前标签已经结束后了，栈顶存的就是当前标签）</li>
<li>重新更正父级标签（因为当前标签已经结束，说明他的子节点也都解析完了，父标签不在是当前标签了，父级标签有重新变回当前标签的父级标签）</li>
<li>关闭标签，此时对if条件分支进行一些补充以及进行一些收尾工作等</li>
</ul>
<h2 id="钩子函数chars"><a href="#钩子函数chars" class="headerlink" title="钩子函数chars"></a>钩子函数chars</h2><ul>
<li>创建抽象语法树文本节点</li>
<li>将这个文本节点加入到父节点的children中</li>
</ul>
<h2 id="钩子函数comment"><a href="#钩子函数comment" class="headerlink" title="钩子函数comment"></a>钩子函数comment</h2><ul>
<li>创建抽象语法树注释节点</li>
<li>只要注释节点存在父级，就把注释节点加入到父级节点的children中</li>
</ul>
<p>举个例子:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当我们解析到<code>&lt;div&gt;</code>时，将div加入到栈中，此时栈中只有div一个元素，然后继续解析，解析到<code>&lt;p&gt;</code>s的时候，我们再把p也加入到栈中，此时栈中有div和p两个元素，栈顶的元素是p。再往下解析，解析到一段文字，触发chars收集并生成抽象语法树文本节点，那么，此时，这个文本节点的父级是什么呢？显而易见，就是我们栈顶的元素p。所以我们将这个文本节点加入到p的children中即可。继续解析，发现<code>&lt;/p&gt;</code>结束标签，我们将栈顶元素p弹出来，也就是说，现在我们的栈里又只有一个div了，同理，下面的ul和li也是这样操作。当最后解析到<code>&lt;/div&gt;</code>时，栈里也就只有一个div元素了，将栈顶的div弹出，栈空了，已经解析完了。流程如下：</p>
</blockquote>
<p>参考：</p>
<ol>
<li><p><a href="https://juejin.cn/post/6863241580753616903#heading-0">Vue模板编译原理</a></p>
</li>
<li><p><a href="https://blog.csdn.net/u010651383/article/details/104372265">Vue源码学习之模板编译器原理</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/cd8dedf489c1?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation">HTMLParser 的实现和使用</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6859182302979686414#heading-8">模板引擎实现原理（Vue篇）</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>npm和npx的区别</title>
    <url>/2019/03/08/node/npm%E5%92%8Cnpx%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>npm是Node.js的软件包管理器，其目标是自动化的依赖性和软件包管理</p>
<p>npm 允许在package.json文件里面，使用scripts字段定义脚本命令</p>
<h2 id="–save-dev-与-–save的区别"><a href="#–save-dev-与-–save的区别" class="headerlink" title="–save-dev 与 –save的区别"></a>–save-dev 与 –save的区别</h2><ul>
<li><code>npm install X</code>:<br>会把X包安装到node_modules目录中不会修改package.json,之后运行npm install命令时，不会自动安装X</li>
<li><code>npm install --save-dev *</code>:使用此命令安装，会将依赖安装到<code>devDependencies</code>目录下，该目录下都是开发时需要的依赖,如<code>npm install --save-dev gulp-uglify</code>，安装了js的压缩包<code>gulp-uglify</code>，而压缩插件只在开发时使用，项目发布后不需要</li>
<li><code>npm install --save *</code>:会将依赖安装到<code>description</code>目录下，该目录下都是发布后也需要的依赖，如<code>vue</code>这样的框架，项目发布后依然需要</li>
</ul>
<h2 id="简写-S与-D的区别"><a href="#简写-S与-D的区别" class="headerlink" title="简写-S与-D的区别"></a>简写-S与-D的区别</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -S会安装再dependencies目录下</span></span><br><span class="line">npm i -S xxx</span><br><span class="line"><span class="comment">// -D会安装在devDependencies目录下</span></span><br><span class="line">npm i -D xxx</span><br></pre></td></tr></table></figure>

<h2 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h2><p>npx是执行Node软件包的工具，它从 npm5.2版本开始，就与npm捆绑在一起。<br>如果不能用，手动安装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install -g npx</span><br></pre></td></tr></table></figure>

<p>npm与npx执行命令对比：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 免去了设置路径</span></span><br><span class="line">npx eslint --init</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若使用npm</span></span><br><span class="line">./node_modules/bin/eslint --init</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者在package.json设置好scripts脚本 </span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//  &quot;scripts&quot;: &#123;</span></span><br><span class="line"><span class="comment">//    &quot;eslint&quot;:&quot;eslint --init&quot;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//&#125; </span></span><br><span class="line">npm run eslint</span><br></pre></td></tr></table></figure>
<p>npx 的原理很简单，就是运行的时候，会到node_modules&#x2F;.bin路径和环境变量$PATH里面，检查命令是否存在</p>
<ol>
<li>默认情况下，首先检查路径中是否存在要执行的包（即在项目中）；</li>
<li>如果存在，它将执行；</li>
<li>若不存在，意味着尚未安装该软件包，npx将安装其最新版本，然后执行它；</li>
</ol>
<p>只执行，不安装(若未安装，会报错)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npx some-package --no-install</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3中双向绑定的实现</title>
    <url>/2020/12/25/vue/vue3%E4%B8%AD%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>vue3的双向绑定改变，用一句话来描述：vue3的双向绑定原理由<code>Object.defineProperty</code>改为基于ES6的<code>Proxy</code>代理来实现。</p>
<h3 id="为什么要替换Object-defineProperty"><a href="#为什么要替换Object-defineProperty" class="headerlink" title="为什么要替换Object.defineProperty"></a>为什么要替换Object.defineProperty</h3><ol>
<li>vue官网在<a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E6%A3%80%E6%B5%8B%E5%8F%98%E5%8C%96%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">深入响应式原理</a>中解释，由于 JavaScript 的限制，Vue 不能检测数组和对象的变化，也就是：</li>
</ol>
<ul>
<li>对象属性的添加和删除，无法监听</li>
<li>数组索引和长度的变更，无法监听</li>
</ul>
<ol start="2">
<li>vue2.x为了给每个属性添加setter&#x2F;getter，会递归调用，而Proxy能劫持整个对象，相比而言更高效</li>
</ol>
<h3 id="Proxy和Reflect"><a href="#Proxy和Reflect" class="headerlink" title="Proxy和Reflect"></a>Proxy和Reflect</h3><p>Proxy可以理解为“拦截”目标对象，外界对该对象的访问都会拦截，因此可以对外界的访问进行过滤和改写。<br>Reflect可以理解为一个方法的集合，一些明显属于语言层面的方法，被放到了Reflect上。现阶段，某些方法同时在Object和Reflect上部署，但未来一些新方法只在Reflect上部署。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">123</span>,</span><br><span class="line">    <span class="attr">arr</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// target：源对象，这里是obj</span></span><br><span class="line"><span class="comment">// key：属性，如name、arr</span></span><br><span class="line"><span class="comment">// value: get方法，设置的新值</span></span><br><span class="line"><span class="comment">// receiver: 返回的proxy对象，这里是p</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get:&#x27;</span>, target, key, receiver);</span><br><span class="line">        <span class="comment">// 通过Reflect，调用默认get方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set:&#x27;</span>, target, key, value, receiver);</span><br><span class="line">        <span class="comment">// 通过Reflect，调用默认set方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="property">name</span> = <span class="number">456</span>;</span><br><span class="line">p.<span class="property">name</span>;</span><br></pre></td></tr></table></figure>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>在上一篇《vue双向绑定原理》的基础上，重写监听器observe，上一篇observe的实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span> ($data, vm) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>($data).<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="title function_">defineReactive</span>(vm, key, $data[key]);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span> (obj, key, val) &#123;</span><br><span class="line">  <span class="keyword">var</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 添加订阅者 watcher 到主题对象 Dep</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) dep.<span class="title function_">addSub</span>(<span class="title class_">Dep</span>.<span class="property">target</span>);</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">newVal</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal === val) <span class="keyword">return</span></span><br><span class="line">      val = newVal;</span><br><span class="line">      <span class="comment">// 作为发布者发出通知</span></span><br><span class="line">      dep.<span class="title function_">notify</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Proxy数据劫持的方式来实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">observe</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">let</span> handler = &#123;</span><br><span class="line">   <span class="title function_">get</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[property];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value);</span><br><span class="line">      that.<span class="property">subscribe</span>[key].<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        item.<span class="title function_">update</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$data</span> = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码里把代理器返回的对象代理到this.$data，即this.$data是代理后的对象，外部每次对this.$data进行操作时，实际上执行的是这段代码里handler对象上的方法。</p>
<p>参考：</p>
<ol>
<li><a href="https://www.cnblogs.com/lyt0207/p/12540091.html">vue3中的双向绑定 proxy</a></li>
<li><a href="https://www.cnblogs.com/mlw1814011067/p/11283528.html">vue3.0中的双向数据绑定方法</a></li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>mustache模板引擎（二）</title>
    <url>/2020/10/26/vue/mustache%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E2/</url>
    <content><![CDATA[<h2 id="扫描器"><a href="#扫描器" class="headerlink" title="扫描器"></a>扫描器</h2><p>扫描器，主要作用是扫描到<code>&#123;&#123;`之前的数据，`&#125;&#125;</code>之后的数据，以及它们之间的数据，保存到token里，便于以后拼装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扫描器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Scanner</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">templateStr</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pos</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = templateStr;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">templateStr</span> = templateStr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 扫描到&#x27;&#123;&#123;&#x27;后，重新赋值pos和tail</span></span><br><span class="line">  <span class="comment">// pos和tail都从&#x27;&#123;&#123;&#x27;后重新开始</span></span><br><span class="line">  <span class="title function_">scan</span>(<span class="params">stopTag</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">tail</span>.<span class="title function_">indexOf</span>(stopTag) === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">pos</span> += stopTag.<span class="property">length</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="variable language_">this</span>.<span class="property">templateStr</span>.<span class="title function_">substring</span>(<span class="variable language_">this</span>.<span class="property">pos</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回&#x27;&#123;&#123;&#x27;之前的值</span></span><br><span class="line">  <span class="title function_">scanUtil</span>(<span class="params">stopTag</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> pos_backup = <span class="variable language_">this</span>.<span class="property">pos</span>; </span><br><span class="line">    <span class="comment">// 当尾巴的开头不是stopTag 的时候，就说明还没有扫描到stopTag</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">tail</span>.<span class="title function_">indexOf</span>(stopTag) !==<span class="number">0</span> &amp;&amp; !<span class="variable language_">this</span>.<span class="title function_">eos</span>())&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">pos</span>++;</span><br><span class="line">      <span class="comment">// 改变尾巴从当前指针的这个字符开始到最后</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="variable language_">this</span>.<span class="property">templateStr</span>.<span class="title function_">substr</span>(<span class="variable language_">this</span>.<span class="property">pos</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">templateStr</span>.<span class="title function_">substring</span>(pos_backup, <span class="variable language_">this</span>.<span class="property">pos</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断指针是否走到了头</span></span><br><span class="line">  <span class="title function_">eos</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">pos</span> &gt;= <span class="variable language_">this</span>.<span class="property">templateStr</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将模板转换成token"><a href="#将模板转换成token" class="headerlink" title="将模板转换成token"></a>将模板转换成token</h2><p>什么是tokens，也就是将模板转换成如下数组结构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`</span></span><br><span class="line"><span class="string">  &lt;ol&gt;</span></span><br><span class="line"><span class="string">    &#123;&#123;#students&#125;&#125;</span></span><br><span class="line"><span class="string">    &lt;li&gt; </span></span><br><span class="line"><span class="string">      学生&#123;&#123;name&#125;&#125; 好朋友是&#123;&#123;friend.name&#125;&#125;  自己的爱好是</span></span><br><span class="line"><span class="string">      &lt;ol&gt;</span></span><br><span class="line"><span class="string">        &#123;&#123;#hobbies&#125;&#125;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&#123;&#123;.&#125;&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &#123;&#123;/hobbies&#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;/ol&gt;</span></span><br><span class="line"><span class="string">    &lt;/li&gt;</span></span><br><span class="line"><span class="string">    &#123;&#123;/students&#125;&#125;</span></span><br><span class="line"><span class="string">  &lt;/ol&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>
<p><img data-src="/2020/10/26/vue/mustache%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E2/1.jpg"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将模板转换成tokens</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">parseTemplateToTokens</span>(<span class="params">templateStr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> tokens = [];</span><br><span class="line">  <span class="keyword">let</span> scanner = <span class="keyword">new</span> <span class="title class_">Scanner</span>(templateStr)</span><br><span class="line">  <span class="keyword">let</span> words;</span><br><span class="line">  <span class="keyword">while</span>(!scanner.<span class="title function_">eos</span>())&#123;</span><br><span class="line">    words = scanner.<span class="title function_">scanUtil</span>(<span class="string">&#x27;&#123;&#123;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (words !== <span class="string">&#x27;&#x27;</span> )&#123;</span><br><span class="line">      tokens.<span class="title function_">push</span>([<span class="string">&#x27;text&#x27;</span>,words.<span class="title function_">replace</span>(<span class="regexp">/\s+/g</span>,<span class="string">&#x27; &#x27;</span>)]) <span class="comment">// 将多个空格合并成一个</span></span><br><span class="line">    &#125;</span><br><span class="line">    scanner.<span class="title function_">scan</span>(<span class="string">&#x27;&#123;&#123;&#x27;</span>)</span><br><span class="line">    words = scanner.<span class="title function_">scanUtil</span>(<span class="string">&#x27;&#125;&#125;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (words!==<span class="string">&#x27;&#x27;</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (words[<span class="number">0</span>]===<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        tokens.<span class="title function_">push</span>([<span class="string">&#x27;#&#x27;</span>, words.<span class="title function_">substring</span>(<span class="number">1</span>)]);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (words[<span class="number">0</span>] === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        tokens.<span class="title function_">push</span>([<span class="string">&#x27;/&#x27;</span>, words.<span class="title function_">substring</span>(<span class="number">1</span>)]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tokens.<span class="title function_">push</span>([<span class="string">&#x27;name&#x27;</span>, words])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    scanner.<span class="title function_">scan</span>(<span class="string">&#x27;&#125;&#125;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">nestTokens</span>(tokens)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将tokens折叠"><a href="#将tokens折叠" class="headerlink" title="将tokens折叠"></a>将tokens折叠</h2><p><code>#</code>和<code>/</code>之间的token，是一个循环，应该属于上一个token的子项，折叠后的token结构如下：<br><img data-src="/2020/10/26/vue/mustache%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E2/2.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将#开头的token，折叠进多维数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">nestTokens</span>(<span class="params">tokens</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> nestedTokens = []; <span class="comment">// 结果数组</span></span><br><span class="line">  <span class="keyword">let</span> sections = []; <span class="comment">// 一个栈结构</span></span><br><span class="line">  <span class="keyword">let</span> collector = nestedTokens; <span class="comment">// 收集器</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>,len = tokens.<span class="property">length</span> ;i&lt;len ;++i) &#123;</span><br><span class="line">    <span class="keyword">let</span> token = tokens[i];</span><br><span class="line">    <span class="keyword">switch</span> (token[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">        collector.<span class="title function_">push</span>(token);</span><br><span class="line">        sections.<span class="title function_">push</span>(token);</span><br><span class="line">        collector = token[<span class="number">2</span>] = []; <span class="comment">// 给token 添加下标为2的项 并且让收集器指向它</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        sections.<span class="title function_">pop</span>();</span><br><span class="line">        collector = sections.<span class="property">length</span> &gt;<span class="number">0</span> ? sections[sections.<span class="property">length</span> - <span class="number">1</span>][<span class="number">2</span>]:nestedTokens;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        collector.<span class="title function_">push</span>(token);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nestedTokens</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="将tokens渲染成dom"><a href="#将tokens渲染成dom" class="headerlink" title="将tokens渲染成dom"></a>将tokens渲染成dom</h2><p>思路是将token里面的字符串连接起来，<code>双&#123;&#125;</code>之间的东西，要用data替换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">renderTemplate</span> (tokens, data) &#123;</span><br><span class="line">  <span class="keyword">let</span> resultStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>,len = tokens.<span class="property">length</span> ; i&lt;len ; ++i )&#123;</span><br><span class="line">    <span class="keyword">let</span> token = tokens[i]</span><br><span class="line">    <span class="keyword">if</span> (token[<span class="number">0</span>] === <span class="string">&#x27;text&#x27;</span>) &#123;</span><br><span class="line">      resultStr += token[<span class="number">1</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token[<span class="number">0</span>] === <span class="string">&#x27;name&#x27;</span>) &#123;</span><br><span class="line">      resultStr += lookup (data, token[<span class="number">1</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token[<span class="number">0</span>] === <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">      resultStr += <span class="title function_">parseArray</span>(token, data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resultStr</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="处理a-b-c"><a href="#处理a-b-c" class="headerlink" title="处理a.b.c"></a>处理a.b.c</h2><p>因为<code>a[b.c]</code>是不能取到<code>a.b.c</code>的，数据的，所以要对级联<code>.</code>取值，做处理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lookup</span> (dataObj, keyName) &#123;</span><br><span class="line">  <span class="comment">// 判断的时候不能是. 本身</span></span><br><span class="line">  <span class="keyword">if</span> (keyName.<span class="title function_">indexOf</span>(<span class="string">&#x27;.&#x27;</span>) !== -<span class="number">1</span> &amp;&amp; keyName !== <span class="string">&#x27;.&#x27;</span>)  &#123;</span><br><span class="line">    <span class="keyword">let</span> keys = keyName.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> temp = dataObj</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>, len = keys.<span class="property">length</span>; i&lt;len ; ++i) &#123;</span><br><span class="line">      temp = temp[keys[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dataObj[keyName] <span class="comment">// 没有&#x27;.&#x27;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="处理建议循环符"><a href="#处理建议循环符" class="headerlink" title="处理建议循环符."></a>处理建议循环符<code>.</code></h2><p>对于<code>.</code>代表，循环数组中的每一项，当访问父元素的点属性时，可以将数据本身复制给点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseArray</span>(<span class="params">token, data</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> v = <span class="title function_">lookup</span>(data, token[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">let</span> resultStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>, len = v.<span class="property">length</span> ;i&lt;len ;++i) &#123;</span><br><span class="line">    resultStr += <span class="title function_">renderTemplate</span>(token[<span class="number">2</span>], &#123;</span><br><span class="line">      ...v[i],</span><br><span class="line">      <span class="string">&#x27;.&#x27;</span>: v[i]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resultStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="render函数调用主流程"><a href="#render函数调用主流程" class="headerlink" title="render函数调用主流程"></a>render函数调用主流程</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span> (templateStr, data) &#123;</span><br><span class="line">  <span class="keyword">let</span> tokens = <span class="title function_">parseTemplateToTokens</span>(templateStr)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tokens)</span><br><span class="line">  <span class="keyword">let</span> result = <span class="title function_">renderTemplate</span>(tokens,data)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="property">log</span> (result)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>mustache<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> =<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;b.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    var templateStr = `</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">      <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        </span><span class="template-tag">&#123;&#123;#<span class="name">students</span>&#125;&#125;</span><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        <span class="tag">&lt;<span class="name">li</span>&gt;</span> </span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">          学生</span><span class="template-variable">&#123;&#123;<span class="name">name</span>&#125;&#125;</span><span class="language-xml"> 好朋友是</span><span class="template-variable">&#123;&#123;<span class="name">friend.name</span>&#125;&#125;</span><span class="language-xml">  自己的爱好是</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">          <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">            </span><span class="template-tag">&#123;&#123;#<span class="name">hobbies</span>&#125;&#125;</span><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><span class="template-variable">&#123;&#123;.&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">            </span><span class="template-tag">&#123;&#123;/<span class="name">hobbies</span>&#125;&#125;</span><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">          <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        </span><span class="template-tag">&#123;&#123;/<span class="name">students</span>&#125;&#125;</span><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">      <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    `</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    var data = &#123;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">      students: [</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        &#123;name: &quot;小明&quot;, hobbies: [&#x27;编程&#x27;, &#x27;打游戏&#x27;], friend: &#123;name: &#x27;小七&#x27;&#125;&#125;,</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        &#123;name: &quot;小红&quot;, hobbies: [&#x27;追剧&#x27;], friend: &#123;name: &#x27;小紫&#x27;&#125;&#125;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">      ]</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    &#125;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">   document.getElementById(&quot;container&quot;).innerHTML = render(templateStr,data)</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">  </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="/2020/10/26/vue/mustache%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E2/03.jpg"></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue双向绑定原理</title>
    <url>/2020/11/08/vue/vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>本文的双向绑定是简版的vue实现方式，不包含虚拟dom的实现等<br>原理图：<br><img data-src="/2020/11/08/vue/vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/2.png"><br>实现：<br>我们要实现的是将如下代码，最终渲染成dom节点</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; text &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="1-Vue构造函数的实现"><a href="#1-Vue构造函数的实现" class="headerlink" title="1.Vue构造函数的实现"></a>1.Vue构造函数的实现</h3><p>可以通过如下3大步来完成dom的渲染：</p>
<ol>
<li>添加监听器</li>
<li>遍历dom，编译模板</li>
<li>编译完成后，将dom插入到根节点<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span> (options) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = options.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="variable language_">this</span>.<span class="property">data</span>;</span><br><span class="line">  <span class="comment">// 1.添加监听器</span></span><br><span class="line">  <span class="title function_">observe</span>(data, <span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> id = options.<span class="property">el</span>;</span><br><span class="line">  <span class="comment">// 2.遍历dom，编译模板</span></span><br><span class="line">  <span class="keyword">var</span> dom = <span class="title function_">nodeToFragment</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id), <span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.编译完成后，将 dom 插入到根节点</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id).<span class="title function_">appendChild</span>(dom); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-使用observe，监听data"><a href="#2-使用observe，监听data" class="headerlink" title="2.使用observe，监听data"></a>2.使用observe，监听data</h3><p><code>observe</code>方法会枚举每一个<code>data</code>，利用<code>Object.defineProperty</code>将<code>data</code>中的数据全部转换成<code>getter/setter</code>，当有新值赋给<code>data</code>，就会触发<code>setter</code>函数，然后通知<code>订阅器Dep</code>有更新</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span> (obj, vm) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="title function_">defineReactive</span>(vm, key, obj[key]);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span> (obj, key, val) &#123;</span><br><span class="line">  <span class="keyword">var</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 添加订阅者 watcher 到主题对象 Dep</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) dep.<span class="title function_">addSub</span>(<span class="title class_">Dep</span>.<span class="property">target</span>);</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">newVal</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal === val) <span class="keyword">return</span></span><br><span class="line">      val = newVal;</span><br><span class="line">      <span class="comment">// 作为发布者发出通知</span></span><br><span class="line">      dep.<span class="title function_">notify</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-订阅器Dep（依赖收集器）"><a href="#3-订阅器Dep（依赖收集器）" class="headerlink" title="3.订阅器Dep（依赖收集器）"></a>3.订阅器Dep（依赖收集器）</h3><p>每个data都拥有一个<code>订阅器Dep</code>，<code>Dep</code>里面装着很多<code>订阅者Watcher</code>，当<code>订阅器Dep</code>收到<code>data</code>值改变的消息，就会通知所有<code>watcher</code>做更新</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dep</span> () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">subs</span> = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dep</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="comment">// 添加订阅者</span></span><br><span class="line">  <span class="attr">addSub</span>: <span class="keyword">function</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">notify</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 通知每一个订阅者更新</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">      sub.<span class="title function_">update</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-订阅者Watcher"><a href="#4-订阅者Watcher" class="headerlink" title="4.订阅者Watcher"></a>4.订阅者Watcher</h3><p><code>watcher</code>和使用该<code>data</code>的dom相关联，通过this可以访问该<code>dom节点</code>，所以可以通过<code>watcher</code>修改dom的文本属性，如，input组件:<code>this.value = newData</code>, 文本组件<code>this.nodeValue = newData</code>;当订阅器Dep收到data变化，就会通知里面的每一个watch改变dom值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Watcher</span> (vm, node, name, nodeType) &#123;</span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">node</span> = node;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">vm</span> = vm;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">nodeType</span> = nodeType;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">update</span>();</span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Watcher</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">update</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">get</span>();</span><br><span class="line">    <span class="comment">// 更新&#123;&#123;&#125;&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">nodeType</span> == <span class="string">&#x27;text&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">nodeValue</span> = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新v-model</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">nodeType</span> == <span class="string">&#x27;input&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 获取 data 中的属性值</span></span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">vm</span>[<span class="variable language_">this</span>.<span class="property">name</span>]; <span class="comment">// 触发相应属性的 get</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-模板解析器Compile"><a href="#4-模板解析器Compile" class="headerlink" title="4.模板解析器Compile"></a>4.模板解析器Compile</h3><p>遍历所有<code>dom</code>，分别处理有<code>v-model</code>属性的元素节点和<code>双花括号</code>的文本节点：</p>
<ol>
<li>将<code>data</code>值赋值给元素节点，如<code>input</code>赋值</li>
<li>替换文本节点的<code>双花括号</code></li>
<li>为元素节点如<code>input</code>添加<code>change</code>事件，当<code>value</code>值改变时，更新被关联的<code>data</code>(此时双向绑定之一的<code>view--&gt;model</code>已完成)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">nodeToFragment</span> (node, vm) &#123;</span><br><span class="line">  <span class="keyword">var</span> flag = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line">  <span class="keyword">var</span> child;</span><br><span class="line">  <span class="comment">// 许多同学反应看不懂这一段，这里有必要解释一下</span></span><br><span class="line">  <span class="comment">// 首先，所有表达式必然会返回一个值，赋值表达式亦不例外</span></span><br><span class="line">  <span class="comment">// 理解了上面这一点，就能理解 while (child = node.firstChild) 这种用法</span></span><br><span class="line">  <span class="comment">// 其次，appendChild 方法有个隐蔽的地方，就是调用以后 child 会从原来 DOM 中移除</span></span><br><span class="line">  <span class="comment">// 所以，第二次循环时，node.firstChild 已经不再是之前的第一个子元素了</span></span><br><span class="line">  <span class="keyword">while</span> (child = node.<span class="property">firstChild</span>) &#123;</span><br><span class="line">    <span class="title function_">compile</span>(child, vm);</span><br><span class="line">    flag.<span class="title function_">appendChild</span>(child); <span class="comment">// 将子节点劫持到文档片段中</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compile</span> (node, vm) &#123;</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>;</span><br><span class="line">  <span class="comment">// 节点类型为元素</span></span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> attr = node.<span class="property">attributes</span>;</span><br><span class="line">    <span class="comment">// 解析属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; attr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (attr[i].<span class="property">nodeName</span> == <span class="string">&#x27;v-model&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> name = attr[i].<span class="property">nodeValue</span>; <span class="comment">// 获取 v-model 绑定的属性名</span></span><br><span class="line">        node.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">          <span class="comment">// 给相应的 data 属性赋值，进而触发该属性的 set 方法</span></span><br><span class="line">          vm[name] = e.<span class="property">target</span>.<span class="property">value</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        node.<span class="property">value</span> = vm[name]; <span class="comment">// 将 data 的值赋给该 node</span></span><br><span class="line">        node.<span class="title function_">removeAttribute</span>(<span class="string">&#x27;v-model&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, node, name, <span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 节点类型为 text</span></span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (reg.<span class="title function_">test</span>(node.<span class="property">nodeValue</span>)) &#123;</span><br><span class="line">      <span class="keyword">var</span> name = <span class="title class_">RegExp</span>.<span class="property">$1</span>; <span class="comment">// 获取匹配到的字符串</span></span><br><span class="line">      name = name.<span class="title function_">trim</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, node, name, <span class="string">&#x27;text&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>附上一副官网流程图：<br><img data-src="/2020/11/08/vue/vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/1.png"></p>
<p>参考：</p>
<ol>
<li><a href="https://juejin.cn/post/6844903616046710791#comment">vue双向绑定原理</a></li>
<li><a href="https://juejin.cn/post/6844903942254510087#heading-11">Vue数据双向绑定</a></li>
<li><a href="https://juejin.cn/post/6844904185373130759#heading-3">解析vue双向绑定原理</a></li>
<li><a href="https://github.com/bison1994/two-way-data-binding">完整代码</a></li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue文档纪要</title>
    <url>/2020/01/20/vue/vue%E6%96%87%E6%A1%A3%E7%BA%AA%E8%A6%81/</url>
    <content><![CDATA[<h1 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h1><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><h3 id="计算属性的setter"><a href="#计算属性的setter" class="headerlink" title="计算属性的setter"></a>计算属性的setter</h3><p>计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">fullName</span>: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">newValue</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">firstName</span> = names[<span class="number">0</span>]</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">lastName</span> = names[names.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在再运行 <code>vm.fullName = &#39;John Doe&#39;</code> 时，<code>setter</code> 会被调用，<code>vm.firstName</code> 和 <code>vm.lastName</code> 也会相应地被更新</p>
<hr>
<h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><h2 id="用v-for把一个数组对应为一组元素"><a href="#用v-for把一个数组对应为一组元素" class="headerlink" title="用v-for把一个数组对应为一组元素"></a>用v-for把一个数组对应为一组元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">items</span> = [</span><br><span class="line">  &#123; <span class="attr">message</span>: <span class="string">&#x27;Foo&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">message</span>: <span class="string">&#x27;Bar&#x27;</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in items&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染结果：</span></span><br><span class="line"><span class="comment">// 0 - Foo,</span></span><br><span class="line"><span class="comment">// 1 - Bar</span></span><br></pre></td></tr></table></figure>
<h2 id="在v-for里使用对象"><a href="#在v-for里使用对象" class="headerlink" title="在v-for里使用对象"></a>在v-for里使用对象</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">object</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;How to do lists in Vue&#x27;</span>,</span><br><span class="line">  <span class="attr">author</span>: <span class="string">&#x27;Jane Doe&#x27;</span>,</span><br><span class="line">  <span class="attr">publishedAt</span>: <span class="string">&#x27;2016-04-10&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">&quot;(value, name, index) in object&quot;</span>&gt;</span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">// 渲染结果</span></span><br><span class="line"><span class="comment">// 1.title: &#x27;How to do lists in Vue&#x27;,</span></span><br><span class="line"><span class="comment">// 2.author: &#x27;Jane Doe&#x27;,</span></span><br><span class="line"><span class="comment">// 3.publishedAt: &#x27;2016-04-10&#x27;</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="深入了解组件"><a href="#深入了解组件" class="headerlink" title="深入了解组件"></a>深入了解组件</h1><h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><h3 id="组件名大小写"><a href="#组件名大小写" class="headerlink" title="组件名大小写"></a>组件名大小写</h3><p>我们强烈推荐遵循 W3C 规范中的自定义组件名 (字母全小写且必须包含一个连字符)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-component-name&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><h3 id="事件名"><a href="#事件名" class="headerlink" title="事件名"></a>事件名</h3><p>不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。举个例子，如果触发一个 camelCase 名字的事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有效果 </span></span><br><span class="line">&lt;my-component v-<span class="attr">on</span>:my-event=<span class="string">&quot;doSomething&quot;</span>&gt;&lt;/my-component&gt;</span><br><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;myEvent&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">post-title</span>=<span class="string">&quot;hello!&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span></span><br><span class="line"><span class="attr">props</span>: [<span class="string">&#x27;postTitle&#x27;</span>],</span><br></pre></td></tr></table></figure>


<hr>
<h1 id="内在"><a href="#内在" class="headerlink" title="内在"></a>内在</h1><h2 id="深入响应式原理"><a href="#深入响应式原理" class="headerlink" title="深入响应式原理"></a>深入响应式原理</h2><h3 id="检测变化的注意事项"><a href="#检测变化的注意事项" class="headerlink" title="检测变化的注意事项"></a>检测变化的注意事项</h3><h4 id="对于对象"><a href="#对于对象" class="headerlink" title="对于对象"></a>对于对象</h4><p>响应式与非响应式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>:&#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// `vm.a` 是响应式的</span></span><br><span class="line"></span><br><span class="line">vm.<span class="property">b</span> = <span class="number">2</span></span><br><span class="line"><span class="comment">// `vm.b` 是非响应式的</span></span><br></pre></td></tr></table></figure>
<p>给对象添加单个新属性：用<code>$set</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$set(<span class="variable language_">this</span>.<span class="property">someObject</span>,<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>给对象添加多个新属性：直接Object.assign()不会触发响应，需要原对象与要混合进去的对象的 property 一起创建一个新的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">someObject</span> = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, <span class="variable language_">this</span>.<span class="property">someObject</span>, &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;)</span><br></pre></td></tr></table></figure>
<h4 id="对于数组"><a href="#对于数组" class="headerlink" title="对于数组"></a>对于数组</h4><p>Vue 不能检测以下数组的变动：<br>1.当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code><br>2.当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></p>
<h2 id="但-set和数组的splice、shift等方法可以触发："><a href="#但-set和数组的splice、shift等方法可以触发：" class="headerlink" title="但$set和数组的splice、shift等方法可以触发："></a>但$set和数组的splice、shift等方法可以触发：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(vm.<span class="property">items</span>, indexOfItem, newValue);</span><br><span class="line">vm.<span class="property">items</span>.<span class="title function_">splice</span>(indexOfItem, <span class="number">1</span>, newValue);</span><br></pre></td></tr></table></figure></h2><h3 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h3><p><code>nextTick</code>：将回调延迟到下次 DOM 更新循环之后执行，下面是理解<code>nextTick</code>的很好的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.<span class="property">message</span> = <span class="string">&#x27;new message&#x27;</span> <span class="comment">// 更改数据</span></span><br><span class="line">vm.<span class="property">$el</span>.<span class="property">textContent</span> === <span class="string">&#x27;new message&#x27;</span> <span class="comment">// false,因为dom未更新</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">nextTick</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  vm.<span class="property">$el</span>.<span class="property">textContent</span> === <span class="string">&#x27;new message&#x27;</span> <span class="comment">// true，因为dom已更新</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>mustache模板引擎（一）</title>
    <url>/2020/10/24/vue/mustache%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E1/</url>
    <content><![CDATA[<h2 id="什么是模板引擎"><a href="#什么是模板引擎" class="headerlink" title="什么是模板引擎"></a>什么是模板引擎</h2><p>数据变成视图的最优雅的解决方案,vue的模板引擎也借鉴于此</p>
<h2 id="历史上曾经出现的数据变为视图的方法"><a href="#历史上曾经出现的数据变为视图的方法" class="headerlink" title="历史上曾经出现的数据变为视图的方法"></a>历史上曾经出现的数据变为视图的方法</h2><ol>
<li><p>纯DOM法：非常笨拙，没有实战价值</p>
</li>
<li><p>数组join法: 曾几何时非常流行，是曾经的前端必会知识</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>,len = arr.<span class="property">length</span>;i&lt;len;++i)&#123;</span><br><span class="line">  list.<span class="property">innerHTML</span> += [</span><br><span class="line">    <span class="string">&#x27;&lt;li&gt;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;  &lt;div class=&quot;hd&quot;&gt;&#x27;</span> +arr[i].<span class="property">name</span> + <span class="string">&#x27;的基本信息&lt;/div&gt;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;  &lt;div class=&quot;bd&quot;&gt;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;    &lt;p&gt;姓名：&#x27;</span>+arr[i].<span class="property">name</span>+<span class="string">&#x27;&lt;/p&gt;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;    &lt;p&gt;年龄：&#x27;</span>+arr[i].<span class="property">age</span>+<span class="string">&#x27;&lt;/p&gt;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;    &lt;p&gt;性别：&#x27;</span>+arr[i].<span class="property">sex</span>+<span class="string">&#x27;&lt;/p&gt;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;  &lt;/div&gt;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&lt;/li&gt;&#x27;</span></span><br><span class="line">  ].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6的反引号法：ES6中新增的${a}语法糖，很好用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>,len = arr.<span class="property">length</span>;i&lt;len;++i)&#123;</span><br><span class="line">  list.<span class="property">innerHTML</span> += <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;li&gt; </span></span><br><span class="line"><span class="string">      &lt;div class=&quot;hd&quot;&gt;<span class="subst">$&#123;arr[i].name&#125;</span>的基本信息&lt;/div&gt;  </span></span><br><span class="line"><span class="string">      &lt;div class=&quot;bd&quot;&gt;    </span></span><br><span class="line"><span class="string">        &lt;p&gt;姓名：<span class="subst">$&#123;arr[i].name&#125;</span>&lt;/p&gt;    </span></span><br><span class="line"><span class="string">        &lt;p&gt;年龄：<span class="subst">$&#123;arr[i].age&#125;</span>&lt;/p&gt;    </span></span><br><span class="line"><span class="string">        &lt;p&gt;性别：<span class="subst">$&#123;arr[i].sex&#125;</span>&lt;/p&gt;  </span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/li&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模板引擎：解决数据变为视图的最优雅的方法</p>
</li>
</ol>
<h2 id="使用主要方法"><a href="#使用主要方法" class="headerlink" title="使用主要方法"></a>使用主要方法</h2><p>1.循环<br>View:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;stooges&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Moe&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Larry&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Curly&quot;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Template:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;#stooges&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">&#123;&#123;/stooges&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>Moe<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>Larry<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>Curly<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>.</code>简化数组循环<br>View:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;musketeers&quot;</span>: [<span class="string">&quot;Athos&quot;</span>, <span class="string">&quot;Aramis&quot;</span>, <span class="string">&quot;Porthos&quot;</span>, <span class="string">&quot;D&#x27;Artagnan&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>Template:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;#musketeers&#125;&#125;</span><br><span class="line">* &#123;&#123;.&#125;&#125;</span><br><span class="line">&#123;&#123;/musketeers&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* Athos</span><br><span class="line">* Aramis</span><br><span class="line">* Porthos</span><br><span class="line">* D&#x27;Artagnan</span><br></pre></td></tr></table></figure>

<h2 id="实现需求"><a href="#实现需求" class="headerlink" title="实现需求"></a>实现需求</h2><p>实现一个建议的for循环模板，并支持<code>.</code>循环符</p>
<blockquote>
<p>实现需求，将下列模板，关联data后，渲染成dom<br>模板:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> templateStr = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;ol&gt;</span></span><br><span class="line"><span class="string">    &#123;&#123;#students&#125;&#125;</span></span><br><span class="line"><span class="string">    &lt;li&gt; </span></span><br><span class="line"><span class="string">      学生&#123;&#123;name&#125;&#125; 好朋友是&#123;&#123;friend.name&#125;&#125;  自己的爱好是</span></span><br><span class="line"><span class="string">      &lt;ol&gt;</span></span><br><span class="line"><span class="string">        &#123;&#123;#hobbies&#125;&#125;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&#123;&#123;.&#125;&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &#123;&#123;/hobbies&#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;/ol&gt;</span></span><br><span class="line"><span class="string">    &lt;/li&gt;</span></span><br><span class="line"><span class="string">    &#123;&#123;/students&#125;&#125;</span></span><br><span class="line"><span class="string">  &lt;/ol&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">数据：</span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">var data = &#123;</span></span><br><span class="line"><span class="string">  students: [</span></span><br><span class="line"><span class="string">    &#123;name: &quot;小明&quot;, hobbies: [&#x27;编程&#x27;, &#x27;打游戏&#x27;], friend: &#123;name: &#x27;小七&#x27;&#125;&#125;,</span></span><br><span class="line"><span class="string">    &#123;name: &quot;小红&quot;, hobbies: [&#x27;追剧&#x27;], friend: &#123;name: &#x27;小紫&#x27;&#125;&#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><p>看下一篇</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue的diff算法</title>
    <url>/2020/10/09/vue/vue%E7%9A%84diff%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="什么是diff算法"><a href="#什么是diff算法" class="headerlink" title="什么是diff算法"></a>什么是diff算法</h2><p>要知道渲染真实DOM的开销是很大的，比如有时候我们修改了某个数据，如果直接渲染到真实dom上会引起整个dom树的重绘和重排，有没有可能我们只更新我们修改的那一小块dom而不要更新整个dom呢？diff算法能够帮助我们。</p>
<p>我们先根据真实DOM生成一颗virtual DOM，当virtual DOM某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使oldVnode的值为Vnode。</p>
<p>diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁。</p>
<h2 id="virtual-DOM"><a href="#virtual-DOM" class="headerlink" title="virtual DOM"></a>virtual DOM</h2><p>虚拟dom的节点属性如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">sel</span>: <span class="string">&#x27;div&#x27;</span>, <span class="comment">// 选择器，是什么标签</span></span><br><span class="line">  <span class="attr">key</span>: <span class="string">&#x27;A&#x27;</span>, <span class="comment">// key</span></span><br><span class="line">  <span class="attr">children</span>: [], <span class="comment">// 子元素</span></span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;文本&#x27;</span>, <span class="comment">// 文本节点</span></span><br><span class="line">  <span class="attr">elem</span>: el <span class="comment">// 关联真实dom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="diff的主要流程"><a href="#diff的主要流程" class="headerlink" title="diff的主要流程"></a>diff的主要流程</h2><p><img data-src="/2020/10/09/vue/vue%E7%9A%84diff%E7%AE%97%E6%B3%95/01.png"></p>
<h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>来看看patch是怎么打补丁的（代码只保留核心部分）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patch</span> (oldVnode, vnode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldVnode, vnode)) &#123;</span><br><span class="line">      <span class="comment">// 相同节点（值得比较）</span></span><br><span class="line">        <span class="title function_">patchVnode</span>(oldVnode, vnode)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不同节点（暴力删除，替换新的，不复用）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> oEl = oldVnode.<span class="property">el</span> <span class="comment">// 当前oldVnode对应的真实元素节点</span></span><br><span class="line">        <span class="keyword">let</span> parentEle = api.<span class="title function_">parentNode</span>(oEl)  <span class="comment">// 父元素</span></span><br><span class="line">        <span class="title function_">createEle</span>(vnode)  <span class="comment">// 根据Vnode生成新元素</span></span><br><span class="line">        <span class="keyword">if</span> (parentEle !== <span class="literal">null</span>) &#123;</span><br><span class="line">            api.<span class="title function_">insertBefore</span>(parentEle, vnode.<span class="property">el</span>, api.<span class="title function_">nextSibling</span>(oEl)) <span class="comment">// 将新元素添加进父元素</span></span><br><span class="line">            api.<span class="title function_">removeChild</span>(parentEle, oldVnode.<span class="property">el</span>)  <span class="comment">// 移除以前的旧元素节点</span></span><br><span class="line">            oldVnode = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// some code </span></span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点</p>
<p>判断两节点是否值得比较，值得比较则执行patchVnode</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sameVnode</span> (a, b) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.<span class="property">key</span> === b.<span class="property">key</span> &amp;&amp;  <span class="comment">// key值</span></span><br><span class="line">    a.<span class="property">tag</span> === b.<span class="property">tag</span> &amp;&amp;  <span class="comment">// 标签名</span></span><br><span class="line">    a.<span class="property">isComment</span> === b.<span class="property">isComment</span> &amp;&amp;  <span class="comment">// 是否为注释节点</span></span><br><span class="line">    <span class="comment">// 是否都定义了data，data包含一些具体信息，例如onclick , style</span></span><br><span class="line">    <span class="title function_">isDef</span>(a.<span class="property">data</span>) === <span class="title function_">isDef</span>(b.<span class="property">data</span>) &amp;&amp;  </span><br><span class="line">    <span class="title function_">sameInputType</span>(a, b) <span class="comment">// 当标签是&lt;input&gt;的时候，type必须相同</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不值得比较则用Vnode替换oldVnode<br>如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。</p>
<p>虽然这两个节点不一样但是他们的子节点一样怎么办？别忘了，diff可是逐层比较的，如果第一层不一样那么就不会继续深入比较第二层了。（我在想这算是一个缺点吗？相同子节点不能重复利用了…）</p>
<h2 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h2><p>当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法。那么这个方法做了什么呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">patchVnode (oldVnode, vnode) &#123;</span><br><span class="line">    <span class="keyword">const</span> el = vnode.<span class="property">el</span> = oldVnode.<span class="property">el</span></span><br><span class="line">    <span class="keyword">let</span> i, oldCh = oldVnode.<span class="property">children</span>, ch = vnode.<span class="property">children</span></span><br><span class="line">    <span class="keyword">if</span> (oldVnode === vnode) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (oldVnode.<span class="property">text</span> !== <span class="literal">null</span> &amp;&amp; vnode.<span class="property">text</span> !== <span class="literal">null</span> &amp;&amp; oldVnode.<span class="property">text</span> !== vnode.<span class="property">text</span>) &#123;</span><br><span class="line">        api.<span class="title function_">setTextContent</span>(el, vnode.<span class="property">text</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">updateEle</span>(el, vnode, oldVnode)</span><br><span class="line">        <span class="keyword">if</span> (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) &#123;</span><br><span class="line">            <span class="title function_">updateChildren</span>(el, oldCh, ch)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ch)&#123;</span><br><span class="line">            <span class="title function_">createEle</span>(vnode) <span class="comment">//create el&#x27;s children dom</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oldCh)&#123;</span><br><span class="line">            api.<span class="title function_">removeChildren</span>(el)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数做了以下事情：</p>
<ul>
<li>找到对应的真实dom，称为el</li>
<li>判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return</li>
<li>如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。</li>
<li>如果oldVnode有子节点而Vnode没有，则删除el的子节点</li>
<li>如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el</li>
<li>如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要</li>
<li>其他几个点都很好理解，我们详细来讲一下updateChildren</li>
</ul>
<h2 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h2><p>updateChildren是diff算法的精髓</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">updateChildren (parentElm, oldCh, newCh) &#123;</span><br><span class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>, newStartIdx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> oldEndIdx = oldCh.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">    <span class="keyword">let</span> newEndIdx = newCh.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">    <span class="keyword">let</span> oldKeyToIdx</span><br><span class="line">    <span class="keyword">let</span> idxInOld</span><br><span class="line">    <span class="keyword">let</span> elmToMove</span><br><span class="line">    <span class="keyword">let</span> before</span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldStartVnode == <span class="literal">null</span>) &#123;   <span class="comment">// 对于vnode.key的比较，会把oldVnode = null</span></span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx] </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oldEndVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (newStartVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">            newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (newEndVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">            newEndVnode = newCh[--newEndIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">            <span class="title function_">patchVnode</span>(oldStartVnode, newStartVnode)</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">            newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">            <span class="title function_">patchVnode</span>(oldEndVnode, newEndVnode)</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">            newEndVnode = newCh[--newEndIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">            <span class="title function_">patchVnode</span>(oldStartVnode, newEndVnode)</span><br><span class="line">            api.<span class="title function_">insertBefore</span>(parentElm, oldStartVnode.<span class="property">el</span>, api.<span class="title function_">nextSibling</span>(oldEndVnode.<span class="property">el</span>))</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">            newEndVnode = newCh[--newEndIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">            <span class="title function_">patchVnode</span>(oldEndVnode, newStartVnode)</span><br><span class="line">            api.<span class="title function_">insertBefore</span>(parentElm, oldEndVnode.<span class="property">el</span>, oldStartVnode.<span class="property">el</span>)</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">            newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 使用key时的比较</span></span><br><span class="line">            <span class="keyword">if</span> (oldKeyToIdx === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                oldKeyToIdx = <span class="title function_">createKeyToOldIdx</span>(oldCh, oldStartIdx, oldEndIdx) <span class="comment">// 有key生成index表</span></span><br><span class="line">            &#125;</span><br><span class="line">            idxInOld = oldKeyToIdx[newStartVnode.<span class="property">key</span>]</span><br><span class="line">            <span class="keyword">if</span> (!idxInOld) &#123;</span><br><span class="line">                api.<span class="title function_">insertBefore</span>(parentElm, <span class="title function_">createEle</span>(newStartVnode).<span class="property">el</span>, oldStartVnode.<span class="property">el</span>)</span><br><span class="line">                newStartVnode = newCh[++newStartIdx]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                elmToMove = oldCh[idxInOld]</span><br><span class="line">                <span class="keyword">if</span> (elmToMove.<span class="property">sel</span> !== newStartVnode.<span class="property">sel</span>) &#123;</span><br><span class="line">                    api.<span class="title function_">insertBefore</span>(parentElm, <span class="title function_">createEle</span>(newStartVnode).<span class="property">el</span>, oldStartVnode.<span class="property">el</span>)</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="title function_">patchVnode</span>(elmToMove, newStartVnode)</span><br><span class="line">                    oldCh[idxInOld] = <span class="literal">null</span></span><br><span class="line">                    api.<span class="title function_">insertBefore</span>(parentElm, elmToMove.<span class="property">el</span>, oldStartVnode.<span class="property">el</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                newStartVnode = newCh[++newStartIdx]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">        before = newCh[newEndIdx + <span class="number">1</span>] == <span class="literal">null</span> ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].<span class="property">el</span></span><br><span class="line">        <span class="title function_">addVnodes</span>(parentElm, before, newCh, newStartIdx, newEndIdx)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">        <span class="title function_">removeVnodes</span>(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要做了这5个事：<br>1、旧头 &#x3D;&#x3D; 新头</p>
<p>2、旧尾 &#x3D;&#x3D; 新尾</p>
<p>3、旧头 &#x3D;&#x3D; 新尾</p>
<p>4、旧尾 &#x3D;&#x3D; 新头</p>
<p>5、单个查找</p>
<p>举个例子来说明一下：<br>真实: [A, B, C, D, E]<br>旧：  [A, B, C, D, E]<br>新:   [A, F, C, G, E]</p>
<p>下面用下表1，代表指针在的位置</p>
<p>1.<br>真实: [A, B, C, D, E]<br>旧：  [A1, B, C, D, E1]<br>新:   [A1, F, C, G, E1]</p>
<p>比较前4步，若头部指针匹配，则头部的指针往后移动；若尾部的指针匹配，则往前移动<br>A1 &#x3D;&#x3D; A1，头指针往后移动，再开始新一轮的5步比较；E1&#x3D;&#x3D;E1，尾指针往后迁，如下2：</p>
<ol start="2">
<li>真实: [A, B, C, D, E]<br>旧：  [A, B1, C, D1, E]<br>新:   [A, F1, C, G1, E]</li>
</ol>
<p>F1前4步都不匹配，就循环，发现没有，则新建F，插入已处理的节点后，也就是A后，并标记F&#96;,这一步直接在dom上操作，如下3：</p>
<ol start="3">
<li>真实: [A, F（新）, B, C, D, E]<br>旧：  [A, B1, C, D1, E]<br>新:   [A, F&#96;, C1, G1, E]</li>
</ol>
<p>新节点C的前4步都不匹配，则循环，在旧节点找到了C，则将C移动到已处理的节点后，即F(新)后</p>
<p>4.<br>真实: [A, F（新）, C（移动）, B, C, D, E]<br>旧：  [A, B1, C, D1, E]<br>新:   [A, F<code>, C</code>, G11, E]</p>
<p>G匹配5步都没有，则新建</p>
<p>5.<br>真实: [A, F（新）, C（移动）, G（新建）, B, C, D, E]<br>旧：  [A, B1, C, D1, E]<br>新:   [A, F<code>, C</code>, G1, E1]</p>
<p>G操作后，再往后移，此时，前指针移动到了后指针之后了，匹配结束，将旧节点两个之间的节点删除</p>
<ol start="6">
<li>真实: [A, F（新）, C（移动）, G（新建）, B删, C<code>删, D删, E] 旧：  [A, B1, C, D1, E] 新:   [A, F</code>, C&#96;, G1, E1]</li>
</ol>
<p>&#x3D;》 真实：[A, F, C, G, E]</p>
<h2 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h2><p>diff的比较方式<br>进行同层比较，不会进行跨层比较，如：给一个子节点加上一个父节点，会认为父节点和以前的子节点是同层但不同，不会利用之前的子节点，而是将其删除后再创建<br>vue的diff并不是“无微不至”，但上面的做法并不影响效率，因为实际代码很少有上面这种操作</p>
<p>在采取diff算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较，这样将时间复杂度为 O(n3),Vue进行了优化·O(n3) <em>复杂度</em>的问题转换成 O(n) <em>复杂度</em>的问题(只比较同级不考虑跨级问题)，因为你很少会跨越层级地移动Dom元素。 所以 Virtual Dom只会对同一个层级的元素进行对比</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈vue中key的作用</title>
    <url>/2020/06/12/vue/%E6%B5%85%E8%B0%88vue%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h2 id="举一个例子"><a href="#举一个例子" class="headerlink" title="举一个例子"></a>举一个例子</h2><p>例如：data数组从 [1,2,3] 变成了 [1,3]，也就是删除了中间的2，vue会如何处理？</p>
<h2 id="v-for不加key"><a href="#v-for不加key" class="headerlink" title="v-for不加key"></a>v-for不加key</h2><p><img data-src="/2020/06/12/vue/%E6%B5%85%E8%B0%88vue%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8/1.jpg"><br>注意看图中的绿色正方形没有被删除,原因很简单，你认为你删除了2，但Vue会认为你做了两件事：把2变成了3，然后把3删除了。<br>所以发现，此时vue的diff对比的过程如下：<br>首先对比 1 和 1，发现「1 没变」；然后对比 2 和 3发现「2 变成了 3」；最后对比 undefined 和 3，发现「3 被删除了」。</p>
<h2 id="v-for加key"><a href="#v-for加key" class="headerlink" title="v-for加key"></a>v-for加key</h2><p><img data-src="/2020/06/12/vue/%E6%B5%85%E8%B0%88vue%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8/2.jpg"><br>注意，这次vue把中间的2删除了，diff的过程详情参考后续对diff算法介绍的文章，但简单的讲，就是会先对比：<br>1.新头和旧头<br>2.新尾和旧尾<br>这里两步已经识别了，1，3相同，然后移动指针后移，发现对比结束，并删除多余的2<br>[1,2,3]–&gt;[1,3]</p>
<h2 id="为什么v-for不使用index做为key"><a href="#为什么v-for不使用index做为key" class="headerlink" title="为什么v-for不使用index做为key"></a>为什么v-for不使用index做为key</h2><p>如果你用 index 作为 key，那么在删除第二项的时候，index 就会从 1 2 3 变成 1 2（因为 index 永远都是连续的，所以不可能是 1 3），那么 Vue 依然会认为你删除的是第三项。也就是会遇到上面一样的 bug。<br>注意看官网中的demo，用的是data中的id，而不是v-for的index</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">&quot;item in items&quot;</span> v-<span class="attr">bind</span>:key=<span class="string">&quot;item.id&quot;</span>&gt;</span><br><span class="line">  &lt;!-- 内容 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="v-if中的key"><a href="#v-if中的key" class="headerlink" title="v-if中的key"></a>v-if中的key</h2><p>用 key 管理可复用的元素：<br>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，<code>&lt;input&gt;</code> 不会被替换掉——仅仅是替换了它的 placeholder<br>这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key attribute 即可</p>
<h2 id="v-for中的key"><a href="#v-for中的key" class="headerlink" title="v-for中的key"></a>v-for中的key</h2><p>当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。</p>
<p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key attribute：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">&quot;item in items&quot;</span> v-<span class="attr">bind</span>:key=<span class="string">&quot;item.id&quot;</span>&gt;</span><br><span class="line">  &lt;!-- 内容 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p>
<p>因为它是 Vue 识别节点的一个通用机制，key 并不仅与 v-for 特别关联。后面我们将在指南中看到，它还具有其它用途。</p>
<h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>key 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改&#x2F;复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p>
<p>有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。</p>
<p>最常见的用例是结合 v-for：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p>它也可以用于强制替换元素&#x2F;组件而不是重复使用它。当你遇到如下场景时它可能会很有用：</p>
<ul>
<li>完整地触发组件的生命周期钩子</li>
<li>触发过渡<br>例如：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">:key</span>=<span class="string">&quot;text&quot;</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>
当 text 发生改变时，<span> 总是会被替换而不是被修改，因此会触发过渡。</li>
</ul>
<p>参考：<br><a href="https://www.zhihu.com/question/61064119/answer/766607894">https://www.zhihu.com/question/61064119/answer/766607894</a></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack使用指南</title>
    <url>/2018/05/07/webpack/webpack%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="创建package-json"><a href="#创建package-json" class="headerlink" title="创建package.json"></a>创建package.json</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>
<p>在项目的根目录中执行这个命令，它会自动创建 <code>package.json</code>文件，然后终端会问诸如项目名称，项目描述，作者等信息，可默认回车</p>
<h2 id="安装Webpack依赖包"><a href="#安装Webpack依赖包" class="headerlink" title="安装Webpack依赖包"></a>安装Webpack依赖包</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack</span><br></pre></td></tr></table></figure>
<p>这时<code>package.json</code>里会增加两个属性：<code>description</code>和<code>devDependencies</code><br><img data-src="/2018/05/07/webpack/webpack%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/1.png"></p>
<h2 id="–save-dev-与-–save的区别"><a href="#–save-dev-与-–save的区别" class="headerlink" title="–save-dev 与 –save的区别"></a>–save-dev 与 –save的区别</h2><ul>
<li><code>npm install X</code>:<br>会把X包安装到node_modules目录中不会修改package.json,之后运行npm install命令时，不会自动安装X</li>
<li><code>npm install --save-dev *</code>:使用此命令安装，会将依赖安装到<code>devDependencies</code>目录下，该目录下都是开发时需要的依赖,如<code>npm install --save-dev gulp-uglify</code>，安装了js的压缩包<code>gulp-uglify</code>，而压缩插件只在开发时使用，项目发布后不需要</li>
<li><code>npm install --save *</code>:会将依赖安装到<code>description</code>目录下，该目录下都是发布后也需要的依赖，如<code>vue</code>这样的框架，项目发布后依然需要</li>
</ul>
<h2 id="S与-D的区别"><a href="#S与-D的区别" class="headerlink" title="-S与-D的区别"></a>-S与-D的区别</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -S会安装再dependencies目录下</span></span><br><span class="line">npm i -S xxx</span><br><span class="line"><span class="comment">// -D会安装在devDependencies目录下</span></span><br><span class="line">npm i -D xxx</span><br></pre></td></tr></table></figure>


<h2 id="简单的demo"><a href="#简单的demo" class="headerlink" title="简单的demo"></a>简单的demo</h2><p><img data-src="/2018/05/07/webpack/webpack%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/2.png"></p>
<ol>
<li><p><code>src/index.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;title&#x27;</span>).<span class="property">innerHTML</span> = <span class="string">&#x27;hello webpack&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>dist/index.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var path = require(&#x27;path&#x27;);</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: __dirname + <span class="string">&#x27;/src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: __dirname + <span class="string">&#x27;/dist&#x27;</span>,</span><br><span class="line">    <span class="comment">// path: path.resolve(__dirname, &#x27;dist&#x27;),</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/bundle.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：<code>__dirname</code>是node.js中的一个全局变量，它指向当前执行脚本所在的目录。</p>
</blockquote>
</li>
<li><p>执行<code>webpack</code>，<code>/dist/</code>目录下会打包生成<code>js/bundle.js</code>,同时出现警告：<br><img data-src="/2018/05/07/webpack/webpack%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/3.jpg"></p>
<blockquote>
<p>警告提示<code>mode</code>没有定义，这是 webpack  4x 引入的，有两个值，<code>development</code> 和 <code>production</code>，默认是<code>production</code>，可以用下面这两种方式指定：</p>
</blockquote>
</li>
</ol>
<ul>
<li>执行<code>webpack --mode development</code>，而不是执行<code>webpack</code></li>
<li>在webpack.config.js中指定mode属性，如：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  <span class="attr">entry</span>: __dirname + <span class="string">&#x27;/src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: __dirname + <span class="string">&#x27;/dist&#x27;</span>,</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/bundle.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="5">
<li>配置命令<br>通过在package.json中配置<code>script</code>，如：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack --mode development&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>就可以用命令 <code>npm run build</code> 替代  <code>webpack --mode development</code></p>
</blockquote>
</li>
</ol>
<h2 id="Source-Maps"><a href="#Source-Maps" class="headerlink" title="Source Maps"></a>Source Maps</h2><p><code>Source Maps</code>可以使调试更方便，当定位错误时，可以使编译文件与源文件一一对应，通过配置<code>webpack.config.js</code>中的<code>devtool</code>属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&#x27;eval-source-map&#x27;</span>,</span><br><span class="line">  <span class="attr">entry</span>: __dirname + <span class="string">&#x27;/src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: __dirname + <span class="string">&#x27;/dist&#x27;</span>,</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/bundle.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>devtool</code>有4个值，优缺点如下：</p>
<p>| devtool选项 |  配置结果 |<br>| —<br>| <code>source-map</code> | 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度 |<br>| <code>cheap-module-source-map</code> | 在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便 |<br>| <code>eval-source-map</code>| 使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项 |<br>| <code>cheap-module-eval-source-map</code> | 这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点 |</p>
<h2 id="使用webpack构建本地服务器"><a href="#使用webpack构建本地服务器" class="headerlink" title="使用webpack构建本地服务器"></a>使用webpack构建本地服务器</h2><p>Webpack提供了一个可选的本地开发服务器，可以让浏览器监听你的代码修改，并自动刷新显示修改后的结果<br>这个本地服务器基于node.js构建，它是一个单独的组件，在<code>webpack.config.js</code>中配置前，需要单独安装</p>
<ol>
<li><code>npm install --save-dev webpack-dev-server</code></li>
<li>然后配置<code>devServer</code>属性：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: __dirname + <span class="string">&#x27;/src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: __dirname + <span class="string">&#x27;/dist&#x27;</span>,</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">contentBase</span>: <span class="string">&quot;./dist&quot;</span>,<span class="comment">//本地服务器所加载的页面所在的目录</span></span><br><span class="line">    <span class="attr">historyApiFallback</span>: <span class="literal">true</span>,<span class="comment">//不跳转</span></span><br><span class="line">    <span class="attr">inline</span>: <span class="literal">true</span>,<span class="comment">//实时刷新</span></span><br><span class="line">    <span class="attr">port</span>: <span class="number">8080</span><span class="comment">//设置默认监听端口，如果省略，默认为”8080“</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在<code>package.json</code>中的<code>scripts</code>对象中添加如下命令，用以开启本地服务器：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;server&quot;</span>: <span class="string">&quot;webpack-dev-server --open&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在终端中输入 <code>npm run server</code>即可在本地的8080端口查看结果</li>
</ol>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>forEach 同/异步问题</title>
    <url>/2022/06/02/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/forEach%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>先说结论：</p>
<ul>
<li><code>forEach</code>是异步执行</li>
<li><code>for-in</code>、<code>for-of</code>是同步执行</li>
</ul>
<h2 id="forEach-是异步执行的"><a href="#forEach-是异步执行的" class="headerlink" title="forEach 是异步执行的"></a>forEach 是异步执行的</h2><p>借用网上一个例子：</p>
<p>我们写代码的时候，希望代码能按照<code>arr</code>数组的顺序执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params">x</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">			<span class="title function_">resolve</span>(x)</span><br><span class="line">		&#125;, <span class="number">1000</span> * x)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">	arr.<span class="title function_">forEach</span>(<span class="keyword">async</span> item =&gt; &#123;</span><br><span class="line">		<span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">handle</span>(item)</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;结束&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>()</span><br></pre></td></tr></table></figure>

<p>我们更希望上边的实行结果为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">结束</span><br></pre></td></tr></table></figure>

<p>但是，真实情况是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">结束</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="实现一个-forEach"><a href="#实现一个-forEach" class="headerlink" title="实现一个 forEach"></a>实现一个 forEach</h2><p>我们自己简单<code>polyfill</code>一个 <code>forEach</code>，用<code>for</code>循环实现（据说查<code>mdn</code>源代码是用<code>while</code>循环实现，不过都一样）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myForEach = <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="variable language_">this</span>.<span class="property">length</span>; i++)&#123;</span><br><span class="line">       <span class="title function_">fn</span>(<span class="variable language_">this</span>[i], i)</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>fn</code>函数就是我们例子中的 <code>async/await</code> 方法，<code>forEach</code>直接执行了<code>fn()</code>，而没有 await 就开始了下一次循环，或者换句话说，直接执行了<code>Promise的构造函数</code>部分代码，而<code>promise.then</code>代码没有被等待，就开始了下一次循环（执行下一个<code>Promise构造函数</code>的代码），而之前的<code>promise.then</code>都进入了<code>事件队列</code>，等循环结束后，再把所有<code>事件队列</code>里的任务拿出来执行，这就相当于同时发出去了好几个异步任务，哪个异步任务先执行完取决于自己执行多久。</p>
<p>比如，我们把数组的顺序<code>let arr = [3, 2, 1]</code>,改为<code>let arr = [3, 1, 2]</code>，再在构造函数里加一个<code>console.log(&#39;执行了构造函数&#39;, x)</code>，这样就能清楚的看到上面的解释了，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params">x</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行了构造函数&#x27;</span>, x);</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">			<span class="title function_">resolve</span>(x)</span><br><span class="line">		&#125;, <span class="number">1000</span> * x)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">	arr.<span class="title function_">forEach</span>(<span class="keyword">async</span> item =&gt; &#123;</span><br><span class="line">		<span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">handle</span>(item)</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;结束&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行了构造函数 3</span></span><br><span class="line"><span class="comment">// 执行了构造函数 1</span></span><br><span class="line"><span class="comment">// 执行了构造函数 2</span></span><br><span class="line"><span class="comment">// 结束</span></span><br><span class="line"><span class="comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>看执行结果你就懂了</p>
<h2 id="for-of-是同步执行的"><a href="#for-of-是同步执行的" class="headerlink" title="for of 是同步执行的"></a>for of 是同步执行的</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params">x</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    	    <span class="title function_">resolve</span>(x)</span><br><span class="line">           &#125;, <span class="number">1000</span> * x)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">handle</span>(item)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;结束&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>()</span><br></pre></td></tr></table></figure>

<p>结果： </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">结束</span><br></pre></td></tr></table></figure>

<p>因为<code>for...of</code>并不像<code>forEach</code>那么简单粗暴的方式去遍历执行，而是采用一种特别的手段——<code>迭代器</code> 去遍历。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 这就是迭代器</span></span><br><span class="line"><span class="keyword">let</span> iterator = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>好，现在我们把 iterator 用一到我们最开始的代码中；如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params">x</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">			<span class="title function_">resolve</span>(x)</span><br><span class="line">		&#125;, <span class="number">1000</span> * x)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">let</span> iterator = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line">  <span class="keyword">let</span> res = iterator.<span class="title function_">next</span>();</span><br><span class="line">  <span class="keyword">while</span>(!res.<span class="property">done</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = res.<span class="property">value</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">handle</span>(value);</span><br><span class="line">    res = iterator.<span class="title function_">next</span>();</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;结束&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>()</span><br></pre></td></tr></table></figure>

<p>打印一下结果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 3</span><br><span class="line">// 2</span><br><span class="line">// 1</span><br><span class="line">// 结束</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ol>
<li><a href="https://juejin.cn/post/6844904129471463432">forEach 和 for of 的执行异步顺序问题</a></li>
<li><a href="https://blog.csdn.net/song854601134/article/details/124707324">forEach 同&#x2F;异步问题</a></li>
</ol>
]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>内存泄漏和弱引用</title>
    <url>/2022/07/24/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%BC%B1%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>在本文中，你将了解：</p>
<ul>
<li>怎样避免内存泄漏：<code>解除引用</code> 和 <code>WeakMap</code></li>
<li>什么是<code>强引用</code>和<code>弱引用</code></li>
<li>2种垃圾回收策略（<code>标记清除</code>和<code>引用计数</code>），及其优缺点</li>
</ul>
<h2 id="怎样避免内存泄漏"><a href="#怎样避免内存泄漏" class="headerlink" title="怎样避免内存泄漏"></a>怎样避免内存泄漏</h2><ol>
<li>解除引用</li>
<li>利用<code>WeakMap</code>的弱引用</li>
</ol>
<h2 id="解除引用"><a href="#解除引用" class="headerlink" title="解除引用"></a>解除引用</h2><p>解除引用： 将不再使用的数据设置为<code>null</code>，从而<code>释放</code>其引用。先看一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;toto&#x27;</span> &#125;</span><br><span class="line"><span class="comment">// &#123; name: &#x27;toto&#x27; &#125;这个对象能够被读取到，因为obj这个变量名有对它的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将引用覆盖掉</span></span><br><span class="line">obj = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个对象将会被从内存中移除，因为我们已经失去了对它所有的引用</span></span><br></pre></td></tr></table></figure>

<h2 id="解除引用在强引用下失效"><a href="#解除引用在强引用下失效" class="headerlink" title="解除引用在强引用下失效"></a>解除引用在强引用下失效</h2><p>再来看另外一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;toto&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> arr = [ obj ]</span><br><span class="line"></span><br><span class="line">obj = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，对象 <code>&#123;name:&#39;toto&#39;&#125;</code> 不会被从内存中移除，因为数组<code>arr</code>保存了对它的引用</p>
<h2 id="强引用和弱引用的区别"><a href="#强引用和弱引用的区别" class="headerlink" title="强引用和弱引用的区别"></a>强引用和弱引用的区别</h2><p>事实上，<code>javascript</code>中的大多数<code>变量</code>都保存着对一个<code>对象</code>的<code>强引用</code>。比如上面这个数组保存着对对象<code>&#123;name:&#39;toto&#39;&#125;</code>的强引用。</p>
<p>如果一个<code>变量</code>保存着对一个对象的<code>强引用</code>，那么这个对象将<code>不会</code>被垃圾回收，但是如果一个<code>变量</code>只保存着对这个对象的<code>弱引用</code>，那么这个对象将会被垃圾回收，所以可以利用<code>WeakMap</code>。</p>
<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p>先来看看<code>mdn</code>对<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">WeakMap</a>的描述：</p>
<blockquote>
<p><code>WeakMap</code> 对象是一组键&#x2F;值对的集合，其中的键是<code>弱引用</code>的。其键必须是对象，而值可以是任意的。</p>
</blockquote>
<p>也就是说，<code>WeakMap</code> 的 <code>key</code> 只能是 <code>Object</code> 类型。 <code>原始数据类型</code> 是不能作为 <code>key</code> 的（比如 <code>Symbol</code>）。</p>
<h3 id="Map和Weakmap的比较"><a href="#Map和Weakmap的比较" class="headerlink" title="Map和Weakmap的比较"></a>Map和Weakmap的比较</h3><p>使用<code>map</code>，对象会占用内存，可能不会被垃圾回收。Map对一个对象是强引用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;toto&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> mapObj = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">mapObj.<span class="title function_">set</span>(obj, <span class="string">&#x27;any value&#x27;</span>)</span><br><span class="line"></span><br><span class="line">obj = <span class="literal">null</span></span><br><span class="line">mapObj.<span class="title function_">size</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><code>Weakmap</code>则完全不同，它只保存对对象的弱引用，所以不会阻止对对象的垃圾回收</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;toto&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> weakmapObj = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line">weakmapObj.<span class="title function_">set</span>(obj, <span class="string">&#x27;any value&#x27;</span>)</span><br><span class="line"></span><br><span class="line">obj = <span class="literal">null</span></span><br><span class="line">weakmapObj .<span class="title function_">size</span>() <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>对象被垃圾回收器删除，因为<code>weakmap</code>在对象<code>&#123; name: ‘toto’ &#125;</code>上只有弱引用，而这个对象已经没有强引用了。(只有变量<code>obj</code>有保持引用)</p>
<h3 id="WeakMap的应用场景"><a href="#WeakMap的应用场景" class="headerlink" title="WeakMap的应用场景"></a>WeakMap的应用场景</h3><ol>
<li>想临时记录数据或关系 </li>
<li>在vue3中大量使用了WeakMap</li>
</ol>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><blockquote>
<p>当一个对象不再被使用，但是由于某种原因，它的内存没有被释放，这就是内存泄漏。</p>
</blockquote>
<h3 id="为什么需要垃圾回收机制"><a href="#为什么需要垃圾回收机制" class="headerlink" title="为什么需要垃圾回收机制"></a>为什么需要垃圾回收机制</h3><ul>
<li><code>内存被消耗完</code>：JS里的<code>字符串</code>，<code>对象</code>，<code>数组</code>是没有固定大小的，<code>解释器</code>会动态分配内存来存储这些数据，当<code>解释器</code>消耗完系统中所有可用的内存时，就会造成系统崩溃。</li>
<li><code>内存过大</code>：在某些情况下，不再使用到的变量所占用内存没有及时释放，这种内存泄漏导致程序运行中，内存越占越大，极端情况下可以导致系统崩溃，服务器宕机。</li>
</ul>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><ul>
<li><code>JavaScript</code>有自己的一套垃圾回收机制，<code>JavaScript</code>的解释器可以检测到什么时候程序不再使用这个对象了（数据），就会把它所占用的内存释放掉。</li>
<li>垃圾回收机制有以下两种方法（常用）：<code>标记清除</code>（现代），<code>引用计数</code>（之前）</li>
</ul>
<h3 id="2种垃圾回收策略"><a href="#2种垃圾回收策略" class="headerlink" title="2种垃圾回收策略"></a>2种垃圾回收策略</h3><ol>
<li><code>标记清除</code>：<code>标记阶段</code>即为所有<code>活动对象</code>做上标记，<code>清除阶段</code>则把没有标记（也就是<code>非活动对象</code>）销毁。</li>
<li><code>引用计数</code>：它把对象是否还被需要，简化定义为，有没有被其它地方引用。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收。</li>
</ol>
<h4 id="标记清除的缺点"><a href="#标记清除的缺点" class="headerlink" title="标记清除的缺点"></a>标记清除的缺点</h4><ol>
<li><code>内存碎片化</code>，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块。</li>
<li><code>分配速度慢</code>，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。</li>
</ol>
<p>解决以上的缺点可以使用 <code>标记整理（Mark-Compact）算法</code> 标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）</p>
<p><img data-src="https://chao31.github.io/pics/img/202303061905790.png"></p>
<h4 id="引用计数的缺点"><a href="#引用计数的缺点" class="headerlink" title="引用计数的缺点"></a>引用计数的缺点</h4><ol>
<li>需要一个计数器，所占内存空间大，因为我们也不知道被引用数量的上限。</li>
<li>解决不了<code>循环引用</code>导致的无法回收问题(比如IE 6、7，JS对象和DOM对象循环引用，清除不了，导致内存泄露)</li>
</ol>
<h3 id="V8-的垃圾回收机制"><a href="#V8-的垃圾回收机制" class="headerlink" title="V8 的垃圾回收机制"></a>V8 的垃圾回收机制</h3><p>V8 的垃圾回收机制也是基于<code>标记清除算法</code>，不过对其做了一些优化。</p>
<ul>
<li>针对新生区采用并行回收。</li>
<li>针对老生区采用增量标记与惰性回收</li>
</ul>
<p>参考：</p>
<ol>
<li><a href="https://dev.to/codeoz/weakmap-in-javascript-35gi">Weakmap in javascript</a></li>
<li><a href="https://blog.csdn.net/qq_32925031/article/details/111032188">（翻译）Weakmap详解</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">mdn</a></li>
</ol>
]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>前端基础---位运算</title>
    <url>/2017/04/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h3 id="通过一道题来回顾下位运算"><a href="#通过一道题来回顾下位运算" class="headerlink" title="通过一道题来回顾下位运算"></a>通过一道题来回顾下位运算</h3><p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给出两个整数 x 和 y，计算它们之间的汉明距离。</p>
<p>示例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">输入: x = 1, y = 4</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure>
<p>答案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hammingDistance = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x !== <span class="number">0</span> || y !== <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">// 1001</span></span><br><span class="line">        <span class="comment">// 0001</span></span><br><span class="line">        <span class="comment">// x &amp; 1,其实比较的是x的最后一位数，</span></span><br><span class="line">        <span class="keyword">if</span>((x &amp; <span class="number">1</span>) !== (y &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        x = x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        y = y &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>思路其实很简单：遍历两个数值，位数不相同那么 +1</p>
<h3 id="负值如何用二进制表示"><a href="#负值如何用二进制表示" class="headerlink" title="负值如何用二进制表示"></a>负值如何用二进制表示</h3><p>通过3个步骤得到：</p>
<ol>
<li>确定绝对值的二进制表示（如-18，先确定18的二进制表示）</li>
<li>找到每一位数值的补数，也就是，每个0变1，1变0</li>
<li>给结果+1</li>
</ol>
<h3 id="有符号的整数"><a href="#有符号的整数" class="headerlink" title="有符号的整数"></a>有符号的整数</h3><p>有符号的整数：第32位是符号位，如0表示正，1表示负；使用剩余的31位表示数值大小。</p>
<h3 id="位运算规则"><a href="#位运算规则" class="headerlink" title="位运算规则"></a>位运算规则</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&amp; : 按二进制位进行 与运算，相同位同时为 1 时结果为 1，否则为 0</span><br><span class="line">| : 按二进制位进行 或运算，相同位有一个为 1 时结果为 1，否则为 0</span><br><span class="line">^ : 按二进制位进行 异或运算，相同位相同时结果为 0，否则为 1</span><br><span class="line">&gt;&gt; : 右移运算是将一个二进制位的操作数按指定移动的位数向右移动，移出位被丢弃，左边移出的空位用符号位来补</span><br><span class="line">&lt;&lt; : 左移运算是将一个二进制位的操作数按指定移动的位数向左移位，移出位被丢弃，右边的空位一律补 0</span><br></pre></td></tr></table></figure>
<h3 id="将-5右移1位"><a href="#将-5右移1位" class="headerlink" title="将-5右移1位"></a>将-5右移1位</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x = -5;</span><br><span class="line">x &gt;&gt;= 1;</span><br><span class="line">// -3</span><br></pre></td></tr></table></figure>
<p>发生了如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 如：-5</span><br><span class="line">// 1.找到5</span><br><span class="line">000...101</span><br><span class="line">// 2.找补数</span><br><span class="line">111...010</span><br><span class="line">// 3.补数+1,得到-5</span><br><span class="line">111...011</span><br><span class="line">// 4.右移1位</span><br><span class="line">1111..101</span><br><span class="line">// 5.减一</span><br><span class="line">1111..100</span><br><span class="line">// 6.取反，-3（符号位跟以前一样）</span><br><span class="line">0000..011</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
  </entry>
  <entry>
    <title>算法好文章</title>
    <url>/2019/10/12/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E5%A5%BD%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<ol>
<li><a href="https://segmentfault.com/a/1190000019916376?utm_source=sf-related">JavaScript 数据结构与算法之美 - 十大经典排序算法汇总</a></li>
<li><a href="https://segmentfault.com/a/1190000018682836">前端动画演绎排序算法</a></li>
<li><a href="https://juejin.im/post/6844903858502631432">JavaScript 数据结构与算法之美时间和空间复杂度</a></li>
<li><a href="https://github.com/janl/mustache.js">mustache js模板引擎</a></li>
<li><a href="https://www.npmjs.com/package/snabbdom">snabbdom虚拟dom库</a></li>
<li><a href="https://github.hubspot.com/pace/">pace js加载动画组件库</a></li>
<li><a href="https://www.npmjs.com/package/quicklink">quicklink预加载</a></li>
</ol>
]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>聊一聊:变量,作用域与内存</title>
    <url>/2017/06/23/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E8%81%8A%E4%B8%80%E8%81%8A-%E5%8F%98%E9%87%8F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>js数据类型分两种：</p>
<ol>
<li>基本数据类型：Undefined、 Null、 String、 Boolean、 Number、 String 和 Symbol(ES6新增)</li>
<li>复杂数据类型：Object</li>
</ol>
<blockquote>
<p>区别：内存的分配不同</p>
<ol>
<li>基本数据类型存储在栈中</li>
<li>复杂数据类型存储在堆中，栈中存储的变量，是指向堆中的引用地址</li>
</ol>
</blockquote>
<p>区分数据类型的方法：</p>
<ol>
<li>typeof：可以确定值是否是基本数据类型</li>
<li>instanceof：可以确定值是否是引用数据类型用 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// object</span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>区分数组和Object</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [Object, objct]、[Object, array]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>()  </span><br></pre></td></tr></table></figure>

<h3 id="null是一个对象吗？"><a href="#null是一个对象吗？" class="headerlink" title="null是一个对象吗？"></a>null是一个对象吗？</h3><blockquote>
<p>另外尽管 <code>typeof null === &#39;object&#39;</code>,但null 不是一个对象，这是一个历史遗留问题，JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，null 表示为全零，所以将它错误的判断为 object 。</p>
</blockquote>
<hr>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><blockquote>
<p>内部上下文可以通过作用域链访问外部上下文的一切，但外部上下文无法访问内部上下文中的东西。找一个变量，如果在局部找到，则搜索停止；否则，继续沿着作用域链向上搜（作用域链中的对象有原型链，因此搜索也可能涉及每一个对象的原型链），这个过程一直延续到全局上下文的变量对象；若仍找不到，则未声明。</p>
</blockquote>
<h3 id="js执行上下文"><a href="#js执行上下文" class="headerlink" title="js执行上下文"></a>js执行上下文</h3><p>执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。</p>
<blockquote>
<p>执行上下文分全局上下文、函数上下文和块级上下文</p>
</blockquote>
<h3 id="JS执行上下文栈-后面简称执行栈"><a href="#JS执行上下文栈-后面简称执行栈" class="headerlink" title="JS执行上下文栈(后面简称执行栈)"></a>JS执行上下文栈(后面简称执行栈)</h3><p>执行栈，也叫做调用栈，具有 LIFO (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。</p>
<blockquote>
<p>规则如下：<br>首次运行JavaScript代码的时候,会创建一个全局执行的上下文并Push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push当前执行栈的栈顶。<br>当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文的控制权将移动到当前执行栈的下一个执行上下文。</p>
</blockquote>
<p>以一段代码具体说明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun3</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fun3&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fun3</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fun2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fun1</span>();</span><br></pre></td></tr></table></figure>
<p><code>Global Execution Context</code> (即全局执行上下文)首先入栈，过程如下：<br><img data-src="/2017/06/23/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E8%81%8A%E4%B8%80%E8%81%8A-%E5%8F%98%E9%87%8F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/a.png"><br>伪代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局执行上下文首先入栈</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">push</span>(globalContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行fun1();</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">push</span>(&lt;fun1&gt; functionContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">//fun1中又调用了fun2;</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">push</span>(&lt;fun2&gt; functionContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">//fun2中又调用了fun3;</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">push</span>(&lt;fun3&gt; functionContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">//fun3执行完毕</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//fun2执行完毕</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//fun1执行完毕</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//javascript继续顺序执行下面的代码，但ECStack底部始终有一个 全局上下文（globalContext）;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://juejin.cn/post/6844903858645237767#heading-5">参考</a></p>
<h3 id="块级作用域的概念"><a href="#块级作用域的概念" class="headerlink" title="块级作用域的概念"></a>块级作用域的概念</h3><blockquote>
<p>由最近的一对{}界定</p>
</blockquote>
<h3 id="var、let-和-const"><a href="#var、let-和-const" class="headerlink" title="var、let 和 const"></a>var、let 和 const</h3><ol>
<li>var存在变量的提升</li>
<li>let也存在变量的提升，但因存在“暂时性死区”，故不能在声明前使用let变量</li>
<li>let与var不同在于，同一作用域内let不能重复声明，let有块级作用域；let在全局作用域声明的变量不会成为window的属性</li>
<li>const和let基本相同，除了一点，声明时必须初始化变量，且不能修改；但可以修改const对象的属性（<code>const a = Object.freeze(&#123;&#125;)</code>可以冻结）</li>
</ol>
<blockquote>
<p>js变量是松散类型，意思是可以保存任何类型的数据</p>
</blockquote>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>优化内存的手段：</p>
<ol>
<li>数据不再用，赋值null，释放其引用</li>
<li>let和const有块级作用域，有助于垃圾回收</li>
</ol>
]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript深入——call、apply和bind的底层实现</title>
    <url>/2018/06/16/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5/call-apply-bind%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="call、apply和bind的区别"><a href="#call、apply和bind的区别" class="headerlink" title="call、apply和bind的区别"></a>call、apply和bind的区别</h3><ol>
<li>三者都是this的绑定，第一个参数都需要传入要绑定的this</li>
<li>call和apply的区别是后面的参数，call是一个一个传入，而apply是通过一个数组传入</li>
<li>bind会返回一个函数，在需要的地方执行该函数；而call、apply会立即执行</li>
</ol>
<h3 id="call的Polyfill"><a href="#call的Polyfill" class="headerlink" title="call的Polyfill"></a>call的Polyfill</h3><p>函数都可以调用 call，说明 call 是函数原型上的方法，所有的实例都可以调用。即: <code>Function.prototype.call</code></p>
<p>call的实现需要注意以下几点：</p>
<ol>
<li>在 call 方法中获取调用call()函数</li>
<li>第一个参数可以不传或传null，此时this默认指向 window</li>
<li>从第二个参数起，可以向call传入不定长的参数</li>
<li>传入 call 的第一个参数是 this 指向的对象，根据隐式绑定的规则，我们知道 obj.foo(), foo() 中的 this 指向 obj;因此我们可以这样调用函数 context.fn(…args),即在上下文对象添加要执行的fn</li>
<li>执行完毕，delete添加的fn属性</li>
</ol>
<p>Polyfill:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call2</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化绑定的this对象(context)和参数args</span></span><br><span class="line">    <span class="keyword">let</span> [context, ...args] = [...<span class="variable language_">arguments</span>];</span><br><span class="line">    <span class="comment">// args没传或传null，绑定window</span></span><br><span class="line">    !context &amp;&amp; (context = <span class="variable language_">window</span>);</span><br><span class="line">    <span class="comment">// 将要执行的函数，绑定到context的fn属性上</span></span><br><span class="line">    context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">// 执行fn</span></span><br><span class="line">    <span class="keyword">let</span> result = context.<span class="title function_">fn</span>(...args); </span><br><span class="line">    <span class="comment">// 删除多余添加的属性</span></span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试一下</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.<span class="title function_">call2</span>(foo, <span class="string">&#x27;kevin&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="comment">// kevin</span></span><br><span class="line"><span class="comment">// 18</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>bind2的测试没问题了，就可以把它放进prototype.bind，Polyfill的写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span>)</span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="apply的Polyfill"><a href="#apply的Polyfill" class="headerlink" title="apply的Polyfill"></a>apply的Polyfill</h3><p>apply与call的实现，只有取参数的方式不同</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply2</span> = <span class="keyword">function</span>(<span class="params">context, args</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    !context &amp;&amp; (context = <span class="variable language_">window</span>);</span><br><span class="line">    context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">let</span> result = args ? context.<span class="title function_">fn</span>(...args) : context.<span class="title function_">fn</span>(); </span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试一下</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.<span class="title function_">apply2</span>(foo, [<span class="string">&#x27;kevin&#x27;</span>, <span class="number">18</span>]); </span><br><span class="line"><span class="comment">// kevin</span></span><br><span class="line"><span class="comment">// 18</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="bind的Polyfill"><a href="#bind的Polyfill" class="headerlink" title="bind的Polyfill"></a>bind的Polyfill</h3><p>bind和call的区别就是，返回一个函数，在这个函数里执行fn</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind2</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> [context, ...args] = [...<span class="variable language_">arguments</span>];</span><br><span class="line">    !context &amp;&amp; (context = <span class="variable language_">window</span>);</span><br><span class="line">    context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">        <span class="keyword">let</span> result = context.<span class="title function_">fn</span>(...args); </span><br><span class="line">        <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试一下</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = bar.<span class="title function_">bind2</span>(foo, <span class="string">&#x27;kevin&#x27;</span>, <span class="number">18</span>); </span><br><span class="line"><span class="title function_">func</span>();</span><br><span class="line"><span class="comment">// kevin</span></span><br><span class="line"><span class="comment">// 18</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">也可以参考MDN的Polyfill</a></p>
]]></content>
      <categories>
        <category>前端深入</category>
      </categories>
      <tags>
        <tag>前端深入</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端300ms点击延迟问题</title>
    <url>/2019/02/02/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5/%E7%A7%BB%E5%8A%A8%E7%AB%AF300ms%E7%82%B9%E5%87%BB%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在本文中，你将了解：</p>
<ul>
<li>移动端300ms延迟的原因：类似<code>双击缩放</code>这种操作，在点击了第一次后，浏览器需要判断是否<code>再点击</code>一次屏幕，所以<code>延迟300ms</code>响应。</li>
<li>解决方法：<ul>
<li><ol>
<li><code>禁用缩放</code>：此时浏览器会禁用默认的双击缩放行为并且去掉300ms的点击延迟。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;user-scalable=no&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=1,maximum-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li>更改默认的<code>视口宽度</code>：一开始，浏览器的默认视口宽度并不等于设备的宽度，比它要大，通常是980px，这样设置后，也会告诉浏览器这是一个响应式的网站，让它禁掉默认的双击缩放行为并且去掉300ms的点击延迟。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="3">
<li><code>FastClick</code>：一个专门解决移动端浏览器 300 毫秒点击延迟问题的轻量级的库。FastClick的实现原理是在检测到<code>touchend</code>事件的时候，会通过DOM自定义事件立即出发模拟一个<code>click</code>事件，并把浏览器在300ms之后的click事件阻<code>止掉</code>。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="300ms延迟"><a href="#300ms延迟" class="headerlink" title="300ms延迟"></a>300ms延迟</h2><p>一般情况下，如果没有经过特殊处理，移动端浏览器在派发点击事件的时候，通常会出现300ms左右的延迟。也就是说，当我们点击页面的时候移动端浏览器并不是立即作出反应，而是会等上一小会儿才会出现点击的效果。在移动WEB兴起的初期，用户对300ms的延迟感觉不明显。但是，随着用户对交互体验的要求越来越高，现今，移动端300ms的点击延迟逐渐变得明显而无法忍受。</p>
<p>那么，移动端300ms的点击延迟是怎么来的呢？</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><blockquote>
<p>问题由来:</br><br>这要追溯至 2007 年初。苹果公司在发布首款 iPhone 前夕，遇到一个问题：当时的网站都是为大屏幕设备所设计的。于是苹果的工程师们做了一些约定，应对 iPhone 这种小屏幕浏览桌面端站点的问题。<br>这当中最出名的，当属双击缩放(double tap to zoom)，这也是会有上述 300 毫秒延迟的主要原因。<br>双击缩放，顾名思义，即用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。 那么这和 300 毫秒延迟有什么联系呢？ 假定这么一个场景。用户在 iOS Safari 里边点击了一个链接。由于用户可以进行双击缩放或者双击滚动的操作，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕。 鉴于iPhone的成功，其他移动浏览器都复制了 iPhone Safari 浏览器的多数约定，包括双击缩放，几乎现在所有的移动端浏览器都有这个功能。之前人们刚刚接触移动端的页面，在欣喜的时候往往不会care这个300ms的延时问题，可是如今touch端界面如雨后春笋，用户对体验的要求也更高，这300ms带来的卡顿慢慢变得让人难以接受。</p>
</blockquote>
<p>也就是说，移动端浏览器会有一些默认的行为，比如双击缩放、双击滚动。这些行为，尤其是双击缩放，主要是为桌面网站在移动端的浏览体验设计的。而在用户对页面进行操作的时候，移动端浏览器会优先判断用户是否要触发默认的行为。</p>
<p>那有什么办法可以解决这个问题呢？</p>
<h2 id="浏览器开发商的解决方案"><a href="#浏览器开发商的解决方案" class="headerlink" title="浏览器开发商的解决方案"></a>浏览器开发商的解决方案</h2><p>浏览器开发商要对移动端浏览器本身的设计进行改善，以提供长远的解决方案。</p>
<p>目前，浏览器开发商的解决方案主要有一下三种方案：</p>
<h3 id="方案一：禁用缩放"><a href="#方案一：禁用缩放" class="headerlink" title="方案一：禁用缩放"></a>方案一：禁用缩放</h3><p>当HTML文档头部包含如下meta标签时：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;user-scalable=no&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=1,maximum-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>表明这个页面是不可缩放的，那双击缩放的功能就没有意义了，此时浏览器可以禁用默认的双击缩放行为并且去掉300ms的点击延迟。<br>这个方案有一个缺点，就是必须通过完全禁用缩放来达到去掉点击延迟的目的，然而完全禁用缩放并不是我们的初衷，我们只是想禁掉默认的双击缩放行为，这样就不用等待300ms来判断当前操作是否是双击。但是通常情况下，我们还是希望页面能通过双指缩放来进行缩放操作，比如放大一张图片，放大一段很小的文字。</p>
<h3 id="方案二：更改默认的视口宽度"><a href="#方案二：更改默认的视口宽度" class="headerlink" title="方案二：更改默认的视口宽度"></a>方案二：更改默认的视口宽度</h3><p>一开始，为了让桌面站点能在移动端浏览器正常显示，移动端浏览器默认的视口宽度并不等于设备浏览器视窗宽度，而是要比设备浏览器视窗宽度大，通常是980px。我们可以通过以下标签来设置视口宽度为设备宽度。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为双击缩放主要是用来改善桌面站点在移动端浏览体验的，而随着响应式设计的普及，很多站点都已经对移动端坐过适配和优化了，这个时候就不需要双击缩放了，如果能够识别出一个网站是响应式的网站，那么移动端浏览器就可以自动禁掉默认的双击缩放行为并且去掉300ms的点击延迟。如果设置了上述meta标签，那浏览器就可以认为该网站已经对移动端做过了适配和优化，就无需双击缩放操作了。<br>这个方案相比方案一的好处在于，它没有完全禁用缩放，而只是禁用了浏览器默认的双击缩放行为，但用户仍然可以通过双指缩放操作来缩放页面。</p>
<h3 id="方案三：CSS-touch-action"><a href="#方案三：CSS-touch-action" class="headerlink" title="方案三：CSS touch-action"></a>方案三：CSS touch-action</h3><p>网上很多文章把这个方案归结为指针事件，这令我很疑惑。</p>
<p>以我的理解来看，指针事件的提出并不是为了解决300ms点击延迟的，而是为了使用一个单独的事件模型，对鼠标、触摸、触控等多种输入类型进行统一的处理。也就是说，移动浏览器不用再为不同的输入设备设计不同的事件，网页的开发者也不用再为不同输入类型的设备写不同的事件响应代码，而是通过统一的指针事件就可以开发出跨不同输入类型终端的应用。</p>
<p>跟300ms点击延迟相关的，是touch-action这个CSS属性。这个属性指定了相应元素上能够触发的用户代理（也就是浏览器）的默认行为。如果将该属性值设置为touch-action: none，那么表示在该元素上的操作不会触发用户代理的任何默认行为，就无需进行300ms的延迟判断。</p>
<p>而设置这个CSS属性与否，指针事件应该都是可以工作的。所以，网上的文章令我很疑惑，希望有大神能给我指示~ 。。~</p>
<h2 id="现有的解决方案"><a href="#现有的解决方案" class="headerlink" title="现有的解决方案"></a>现有的解决方案</h2><p>要解决300ms点击延迟的问题，从长远来说，自然还是得浏览器开发商提供统一的最终的解决方案。但是，到目前为止，以上三种方案并不能提供很好的兼容性，对于方案一和方案二，Chrome是率先支持的，Firefox紧随其后，然而令Safari头疼的是，它除了双击缩放还有双击滚动操作，如果采用这种两种方案，那势必连双击滚动也要一起禁用；对于方案三，IE是支持的，但是其他浏览器支持不完善。具体请看这篇文章：移动端Click300毫秒点击延迟的来龙去脉(转)。</p>
<p>所以，在浏览器开发商最终统一的解决方案出来之前，我们还有一些基于Javascript的现成的解决方案可以用。</p>
<h3 id="方案一：指针事件的polyfill"><a href="#方案一：指针事件的polyfill" class="headerlink" title="方案一：指针事件的polyfill"></a>方案一：指针事件的polyfill</h3><p>现在除了IE，其他大部分浏览器都还不支持指针事件。有一些JS库，可以让我们提前使用指针事件，比如</p>
<p>Google 的 Polymer<br>微软的 HandJS<br>@Rich-Harris 的 Points<br>然而，我们现在关心的不是指针事件，而是与300ms延迟相关的CSS属性touch-action。由于除了IE之外的大部分浏览器都不支持这个新的CSS属性，所以这些指针事件的polyfill必须通过某种方式去模拟支持这个属性。一种方案是JS去请求解析所有的样式表，另一种方案是将touch-action作为html标签的属性。</p>
<h3 id="方案二：FastClick"><a href="#方案二：FastClick" class="headerlink" title="方案二：FastClick"></a>方案二：FastClick</h3><p>FastClick 是 FT Labs 专门为解决移动端浏览器 300 毫秒点击延迟问题所开发的一个轻量级的库。FastClick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后的click事件阻止掉。</p>
<h2 id="点击穿透问题"><a href="#点击穿透问题" class="headerlink" title="点击穿透问题"></a>点击穿透问题</h2><p>说完移动端点击300ms延迟的问题，还不得不提一下移动端点击穿透的问题。可能有人会想，既然click点击有300ms的延迟，那对于触摸屏，我们直接监听touchstart事件不就好了吗？<br>使用touchstart去代替click事件有两个不好的地方。<br>第一：touchstart是手指触摸屏幕就触发，有时候用户只是想滑动屏幕，却触发了touchstart事件，这不是我们想要的结果；<br>第二：使用touchstart事件在某些场景下可能会出现点击穿透的现象。</p>
<p>什么是点击穿透？<br>假如页面上有两个元素A和B。B元素在A元素之上。我们在B元素的touchstart事件上注册了一个回调函数，该回调函数的作用是隐藏B元素。我们发现，当我们点击B元素，B元素被隐藏了，随后，A元素触发了click事件。</p>
<p>这是因为在移动端浏览器，事件执行的顺序是touchstart &gt; touchend &gt; click。而click事件有300ms的延迟，当touchstart事件把B元素隐藏之后，隔了300ms，浏览器触发了click事件，但是此时B元素不见了，所以该事件被派发到了A元素身上。如果A元素是一个链接，那此时页面就会意外地跳转。</p>
<p><a href="https://www.ngui.cc/el/1800525.html">参考</a></p>
]]></content>
      <categories>
        <category>前端深入</category>
      </categories>
      <tags>
        <tag>前端深入</tag>
      </tags>
  </entry>
  <entry>
    <title>7 款最棒的 css 背景生成器 🎨✨</title>
    <url>/2022/05/25/%E5%B7%A5%E5%85%B7/7%E6%AC%BE%E6%9C%80%E6%A3%92%E7%9A%84css%E8%83%8C%E6%99%AF%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<p>下面是我整理的 7 款自己最喜欢的背景生成工具，帮助大家生成各种各样的 style 样式或背景图，可生成 png、svg、甚至 css 代码，解决写完博客不知道从哪找图的尴尬。</p>
<h2 id="pattern-css"><a href="#pattern-css" class="headerlink" title="pattern-css"></a><a href="https://bansal.io/pattern-css">pattern-css</a></h2><p><img data-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb53858bb8444df299bf645869f39d7b~tplv-k3u1fbpfcp-watermark.image"></p>
<p>引入 css，选择不同的 class 来生成很时尚的背景图</p>
<h2 id="svgwave"><a href="#svgwave" class="headerlink" title="svgwave"></a><a href="https://svgwave.in/">svgwave</a></h2><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af266eef667f414aa12408b8a0430d6f~tplv-k3u1fbpfcp-watermark.image"></p>
<p>生成波浪渐变背景，可生成 svg 代码，支持 chrome 下动态波动</p>
<h2 id="haikei-app"><a href="#haikei-app" class="headerlink" title="haikei.app"></a><a href="https://app.haikei.app/">haikei.app</a></h2><p><img data-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d0af2394a3943bd9a2898b2583d597d~tplv-k3u1fbpfcp-watermark.image"></p>
<p>各种渐变、波浪、气泡、想小方块、网格的背景，不仅可以生成 png，还可以生成 svg</p>
<h2 id="coolbackgrounds-io"><a href="#coolbackgrounds-io" class="headerlink" title="coolbackgrounds.io"></a><a href="https://coolbackgrounds.io/">coolbackgrounds.io</a></h2><p><img data-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3407eb803f440a386d4ecf97a25830e~tplv-k3u1fbpfcp-watermark.image"></p>
<p>主要有 5 种背景，三角渐变、动态点线图、梯田渐变、钢铁渐变</p>
<h2 id="gradienta"><a href="#gradienta" class="headerlink" title="gradienta"></a><a href="https://gradienta.io/editor">gradienta</a></h2><p><img data-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2537886283041e4a87d79432c9b3d5a~tplv-k3u1fbpfcp-watermark.image"></p>
<p>生成各种渐变背景，除了 svg、png、jpg 格式，还能生成 css</p>
<h2 id="graphics"><a href="#graphics" class="headerlink" title="graphics"></a><a href="https://products.ls.graphics/mesh-gradients/">graphics</a></h2><p><img data-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abb7104b66bf4483b221a98777fa4b0c~tplv-k3u1fbpfcp-watermark.image"><br>100 个免费的渐变背景图下载，只支持图片下载，图片体积还挺大</p>
<h2 id="pattern-monster"><a href="#pattern-monster" class="headerlink" title="pattern.monster"></a><a href="https://pattern.monster/">pattern.monster</a></h2><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed79d32a4cdc4806a3f367f01ce0be19~tplv-k3u1fbpfcp-watermark.image"><br>生成桌布一样的背景，可以增加点缀的色块个数，可以生成 svg、png、css</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工具集与环境搭建</title>
    <url>/2021/08/15/%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E9%9B%86%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>从 0 到 1 系列</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 PicGo + GitHub 自建免费图床</title>
    <url>/2021/01/01/%E5%B7%A5%E5%85%B7/%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h2 id="安装-PicGo"><a href="#安装-PicGo" class="headerlink" title="安装 PicGo"></a>安装 PicGo</h2><p><code>PicGo</code>安装，其它参考<a href="https://github.com/Molunerfinn/PicGo">PicGo 官网</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install picgo --cask</span><br></pre></td></tr></table></figure>

<h2 id="创建仓库和秘钥"><a href="#创建仓库和秘钥" class="headerlink" title="创建仓库和秘钥"></a>创建仓库和秘钥</h2><p>在 github 上创建一个仓库<code>pics</code>后，打开<a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a>, 点击<code>Generate new token</code>按照下图配置创建即可。</p>
<p><img data-src="https://chao31.github.io/pics/img/20220528163555.png"></p>
<p>生成的秘钥，记得保存好，因为这个秘钥只会出现这么一次。</p>
<h2 id="配置-PicGo"><a href="#配置-PicGo" class="headerlink" title="配置 PicGo"></a>配置 PicGo</h2><p><code>打开详细窗口</code> –&gt; <code>图床设置</code> –&gt; <code>GitHub 图床</code></p>
<p><img data-src="https://chao31.github.io/pics/img/20220528201246.png"></p>
<h2 id="github-图片资源无法访问问题"><a href="#github-图片资源无法访问问题" class="headerlink" title="github 图片资源无法访问问题"></a>github 图片资源无法访问问题</h2><p>不能访问的图片都是 <code>raw.githubusercontent.com</code> 域名下的，github 将图片资源通过 <code>https://raw.githubusercontent.com/</code>访问，可以避免图片跟仓库代码文件在同一域名下抢占负载，而不能访问的主要原因是因为 DNS 污染。</p>
<p><code>DNS 污染</code>：网域服务器缓存污染（DNS cache pollution），又称域名服务器缓存投毒（DNS cache poisoning）是指一些刻意制造或无意中制造出来的域名服务器数据包，把域名指往不正确的 IP 地址。一般来说，在互联网上都有可信赖的网域服务器，但为减低网络上的流量压力，一般的域名服务器都会把从上游的域名服务器获得的解析记录暂存起来，待下次有其他机器要求解析域名时，可以立即提供服务。一旦有关网域的局域域名服务器的缓存受到污染，就会把网域内的计算机导引往错误的服务器或服务器的网址。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>主要方法有 3 个：</p>
<ol>
<li><p>通过<a href="https://www.ipaddress.com/">https://www.ipaddress.com/</a>查询<code>raw.githubusercontent.com</code>的 ip，直接修改 hosts 文件如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">185.199</span><span class="number">.108</span><span class="number">.133</span> raw.<span class="property">githubusercontent</span>.<span class="property">com</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>开启 github page，通过<code>xxx.github.io</code>来访问图片</p>
</li>
<li><p>后面加个 s，<code>raw.githubusercontent.com</code>  –&gt; <code>raw.githubusercontents.com</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pace.js原理解析（一）</title>
    <url>/2020/09/23/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/pace-js%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%901/</url>
    <content><![CDATA[<h2 id="Pace-js是什么？"><a href="#Pace-js是什么？" class="headerlink" title="Pace.js是什么？"></a>Pace.js是什么？</h2><p>Pace能自动监控页面的加载进度，生成进度条。它能够自动监控ajax请求、事件循环延迟、document就绪状态和页面上的元素，并当再次发送ajax请求，也能够重启进度条。<br><a href="https://github.hubspot.com/pace/docs/welcome/">官网</a></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1.配置简单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/pace/pace.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/pace/themes/pace-theme-barber-shop.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.体积小<br>pace.js is 4kb minified and gzipped. The themes vary between 0.5 and 4kb.<br>1000行左右</p>
<p>3.能够自动收集页面4个方面的进度信息，对应着Pace的4个主要Collectors：</p>
<ul>
<li>ajax<br>监听所有页面的ajax请求进度</li>
<li>Elements<br>监听dom元素的是否渲染到页面的进度</li>
<li>Document<br>监听页面document的加载进度</li>
<li>Event Lag<br>只是一个“假的”监视器。它就在那里安静匀速的更新进度，这一小小的措施却带来了不错的用户体验，让用户不会因为加载“卡住了”而慌张<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">paceOptions = &#123;</span><br><span class="line">  <span class="attr">ajax</span>: <span class="literal">false</span>, <span class="comment">// disabled</span></span><br><span class="line">  <span class="attr">document</span>: <span class="literal">false</span>, <span class="comment">// disabled</span></span><br><span class="line">  <span class="attr">eventLag</span>: <span class="literal">false</span>, <span class="comment">// disabled</span></span><br><span class="line">  <span class="attr">elements</span>: &#123;</span><br><span class="line">    <span class="attr">selectors</span>: [<span class="string">&#x27;.my-page&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>仅仅引入了一个js，业务代码里也没有调用特殊的ajax请求方法，pace是如何监听ajax请求的？</li>
<li>如何监听document文档的载入进度？</li>
<li>怎样为了用户体验实现一个假的进度？</li>
<li>一个页面初始化时，并不止一个ajax请求，多个ajax的进度、document文档载入进度、dom渲染到页面的进度，这么多进度是如何整合成一个总进度的？</li>
<li>例如一个请求，请求时间是不确定的，pace是如何预知请求时长，并生成进度的？</li>
</ol>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>请看下一篇</p>
]]></content>
      <categories>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>pace.js原理解析（二）</title>
    <url>/2020/09/25/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/pace-js%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%902/</url>
    <content><![CDATA[<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><h2 id="Pace-sources"><a href="#Pace-sources" class="headerlink" title="Pace.sources"></a>Pace.sources</h2><p>Pace.sources &#x3D; [ ]<br>push进去4个实例：’ajax’, ‘elements’, ‘document’, ‘eventLag’</p>
<h3 id="AjaxMonitor"><a href="#AjaxMonitor" class="headerlink" title="AjaxMonitor"></a>AjaxMonitor</h3><h4 id="RequestIntercept"><a href="#RequestIntercept" class="headerlink" title="RequestIntercept"></a>RequestIntercept</h4><p>封装发送ajax请求的XMLHttpRequest，XDomainRequest 的代理 req.open方法调用时，触发了trigger(‘request’)事件<br>它有两个方法：<br>一、trigger(‘request’)<br>req.open方法时触发</p>
<p>二、on(‘request’）<br>1.监听req.open方法<br>2.遍历Pace.sources里的实例，若是AjaxMonitor的实例，调用其watch ()方法<br>3.watch方法会AjaxMonitor.elements.push(XHRRequestTracker) 总结：每发一个ajax请求，AjaxMonitor的elements属性就push进去一个tracker，</p>
<h4 id="AjaxMonitor-1"><a href="#AjaxMonitor-1" class="headerlink" title="AjaxMonitor"></a>AjaxMonitor</h4><p>this.elements &#x3D; []，里面保存有tracker实例，而tracker有progres属性</p>
<h4 id="XHRRequestTracker"><a href="#XHRRequestTracker" class="headerlink" title="XHRRequestTracker"></a>XHRRequestTracker</h4><p>监听xhr，request.addEventListener(‘progress’），根据浏览器是否支持ProgressEvent，算出进度，存储在this.progress </p>
<p>1.progress事件会在浏览器接收新数据期间周期性地触发。<br>2.而onprogress事件处理程序会接收到一个event对象，其target属性是XHR对象<br>3.但包含着三个额外的属性：lengthComputable、loaded和total。<br>4.lengthComputable：是一个表示进度信息是否可用的布尔值；loaded：表示已经接收的字节数，loaded：表示根据Content-Length响应头部确定的预期字节数<br>5.不支持ProgressEvent的浏览器，监听readyState为3、4分别对应50% 、100%</p>
<h3 id="ElementMonitor"><a href="#ElementMonitor" class="headerlink" title="ElementMonitor"></a>ElementMonitor</h3><p>Pace.options.selectors&#x3D;[]里面存的是要跟踪的doms元素，doms加载都成功，progress&#x3D;100% </p>
<p>ElementMonitor实例的this.elements里存着selectors里的dom对应的tracker（每个tracker映射着selectors里的dom），每个tracker都会每隔100ms，查询一次dom是否存在，若是则this.progress &#x3D; 100</p>
<h3 id="DocumentMonitor"><a href="#DocumentMonitor" class="headerlink" title="DocumentMonitor"></a>DocumentMonitor</h3><p>Document.readyState 属性描述了document 的加载状态 </p>
<p>1.loading:正在加载<br>2.interactive:可交互,文档已被解析，”正在加载”状态结束，但是诸如图像，样式表和框架之类的子资源仍在加载。 3. complete（完成）,文档和所有子资源已完成加载。表示 load 状态的事件即将被触发。 </p>
<p>这个三个状态分别对应的进度this.progresss &#x3D; 0% 、50% 、100%</p>
<h3 id="EventLagMonitor"><a href="#EventLagMonitor" class="headerlink" title="EventLagMonitor"></a>EventLagMonitor</h3><ol>
<li><p>EventLagMonitor其实只是一个“假的”监视器。它就在那里安静匀速的更新进度，这一小小的措施却带来了不错的用户体验，让用户不会因为加载“卡住了”而慌张 </p>
</li>
<li><p>感觉怎么计算进度是一个数学问题，求一个数组绝对值的和的平均值，大于几小于几时，_this.progress &#x3D; 100;​（具体见代码）</p>
</li>
</ol>
<h2 id="new-Bar"><a href="#new-Bar" class="headerlink" title="new Bar( )"></a>new Bar( )</h2><p>Bar就是进度条dom实例，进度百分比关联着progress的值</p>
<p>setAttribute(‘data-progress-text’, 10%)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/* 如果你不想把content内容在CSS里写死，那你可以使用attr表达式来从页面元素中动态的获取内容 */</span><br><span class="line">.pace-progress:before &#123;content: attr(data-progress-text);​</span><br></pre></td></tr></table></figure>

<h2 id="new-Scaler"><a href="#new-Scaler" class="headerlink" title="new Scaler( )"></a>new Scaler( )</h2><p>Scaler会取出实例的progress值，Scaler.tick()会将progress值增加一点后返回</p>
<p>Scaler.tick()：此方法主要用于返回this.progress，而progress需要不断增加，计算增加多少的方式很有意思，如果增量算的太多，不太合适，所以（初始progress + 20）和上面计算的progress取个最小值，也就是每次算的增量最大幅度是20（maxProgressPerFrame）</p>
<h2 id="pace-start"><a href="#pace-start" class="headerlink" title="pace.start( )"></a>pace.start( )</h2><p>主要做一件事，执行bar.render()，也就是插入bar的dom，​如果页面还未加载，则每隔50ms再Pace.start()一次</p>
<p>1.Pace.go()<br>每隔33ms执行一次runAnimation<br>window.performence. now() 比Date.now不同的是，window.performance.now()返回的时间戳没有被限制在一毫秒的精确度内，而它使用了一个浮点数来达到微秒级别的精确度</p>
<p>2.runAnimation( fn )<br>很有意思的一个函数：33ms后才会执行fn，否则一直等到33ms后；fn函数被执行后，若返回false，会在下一帧继续执行runAnimation（也就是再等33ms执行一次fn），直到返回true<br>总结：每间隔33ms执行一次fn（fn就是检测所有实例都为done），并在下一帧再次开始33ms递归，直到所有实例都为done​<br>3.fn</p>
<ol>
<li>取出所有实例的element，每个element都有一个Scaler实例(否则new一个存起来)，scaler.done表示实例的进度是否完成</li>
<li>for循环，done &amp;&#x3D; scaler.done（ a&amp;&#x3D;b就是a&#x3D;a&amp;b，有一个scaler.done不为true，done就不为true）<br>3.把不为done的实例， 对这些实例取出pregress，求平均进度，avg &#x3D; sum &#x2F; count; 再bar.update(avg)更新bar实例的进度</li>
<li>若所有done为true，bar.finish();</li>
</ol>
]]></content>
      <categories>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>pace.js原理解析（三）</title>
    <url>/2020/09/27/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/pace-js%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%903/</url>
    <content><![CDATA[<h2 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">AjaxMonitor</span>, <span class="title class_">Bar</span>, <span class="title class_">DocumentMonitor</span>, <span class="title class_">ElementMonitor</span>, <span class="title class_">ElementTracker</span>, <span class="title class_">EventLagMonitor</span>, <span class="title class_">Evented</span>, <span class="title class_">Events</span>, <span class="title class_">NoTargetError</span>, <span class="title class_">Pace</span>, <span class="title class_">RequestIntercept</span>, <span class="variable constant_">SOURCE_KEYS</span>, <span class="title class_">Scaler</span>, <span class="title class_">SocketRequestTracker</span>, <span class="title class_">XHRRequestTracker</span>, animation, avgAmplitude, bar, cancelAnimation, cancelAnimationFrame, defaultOptions, extend, extendNative, getFromDOM, getIntercept, handlePushState, ignoreStack, init, now, options, requestAnimationFrame, result, runAnimation, scalers, shouldIgnoreURL, shouldTrack, source, sources, uniScaler, _WebSocket, _XDomainRequest, _XMLHttpRequest, _i, _intercept, _len, _pushState, _ref, _ref1, _replaceState,</span><br><span class="line">  <span class="comment">// 1.[].slice === Array.prototype.slice   </span></span><br><span class="line">  <span class="comment">// 2.自身的属性不同(因为原型与[]的区别)</span></span><br><span class="line">  <span class="comment">// 3.所以在本质上[]和Array.prototype没有本质区别,但是调用上是有区别的,但是根据专业检测,[]要更快一点</span></span><br><span class="line">    __slice = [].<span class="property">slice</span>,</span><br><span class="line">    __hasProp = &#123;&#125;.<span class="property">hasOwnProperty</span>,</span><br><span class="line">    <span class="comment">// 没细看，感觉实现了一个继承</span></span><br><span class="line">    __extends = <span class="keyword">function</span>(<span class="params">child, parent</span>) &#123; <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> parent) &#123; <span class="keyword">if</span> (__hasProp.<span class="title function_">call</span>(parent, key)) child[key] = parent[key]; &#125; <span class="keyword">function</span> <span class="title function_">ctor</span>(<span class="params"></span>) &#123; <span class="variable language_">this</span>.<span class="property">constructor</span> = child; &#125; ctor.<span class="property"><span class="keyword">prototype</span></span> = parent.<span class="property"><span class="keyword">prototype</span></span>; child.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">ctor</span>(); child.<span class="property">__super__</span> = parent.<span class="property"><span class="keyword">prototype</span></span>; <span class="keyword">return</span> child; &#125;,</span><br><span class="line">    __indexOf = [].<span class="property">indexOf</span> || <span class="keyword">function</span>(<span class="params">item</span>) &#123; <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="variable language_">this</span>.<span class="property">length</span>; i &lt; l; i++) &#123; <span class="keyword">if</span> (i <span class="keyword">in</span> <span class="variable language_">this</span> &amp;&amp; <span class="variable language_">this</span>[i] === item) <span class="keyword">return</span> i; &#125; <span class="keyword">return</span> -<span class="number">1</span>; &#125;;</span><br><span class="line"></span><br><span class="line">  defaultOptions = &#123;</span><br><span class="line">    <span class="attr">catchupTime</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">initialRate</span>: <span class="number">.03</span>,</span><br><span class="line">    <span class="attr">minTime</span>: <span class="number">250</span>,</span><br><span class="line">    <span class="attr">ghostTime</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">maxProgressPerFrame</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">easeFactor</span>: <span class="number">1.25</span>,</span><br><span class="line">    <span class="attr">startOnPageLoad</span>: <span class="literal">true</span>, <span class="comment">// 源码没有用到这个属性做很有意义的事</span></span><br><span class="line">    <span class="attr">restartOnPushState</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">restartOnRequestAfter</span>: <span class="number">500</span>,</span><br><span class="line">    <span class="attr">target</span>: <span class="string">&#x27;body&#x27;</span>,</span><br><span class="line">    <span class="attr">elements</span>: &#123;</span><br><span class="line">      <span class="attr">checkInterval</span>: <span class="number">100</span>,</span><br><span class="line">      <span class="attr">selectors</span>: [<span class="string">&#x27;body&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">eventLag</span>: &#123;</span><br><span class="line">      <span class="attr">minSamples</span>: <span class="number">10</span>,</span><br><span class="line">      <span class="attr">sampleCount</span>: <span class="number">3</span>,</span><br><span class="line">      <span class="attr">lagThreshold</span>: <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">ajax</span>: &#123;</span><br><span class="line">      <span class="attr">trackMethods</span>: [<span class="string">&#x27;GET&#x27;</span>],</span><br><span class="line">      <span class="attr">trackWebSockets</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">ignoreURLs</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/now</span></span><br><span class="line"><span class="comment">  *和JavaScript中其他可用的时间类函数（比如Date.now）不同的是，</span></span><br><span class="line"><span class="comment">  *window.performance.now()返回的时间戳没有被限制在一毫秒的精确度内，而它使用了一个浮点数来达到微秒级别的精确度。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  now = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> _ref;</span><br><span class="line">    <span class="keyword">return</span> (_ref = <span class="keyword">typeof</span> performance !== <span class="string">&quot;undefined&quot;</span> &amp;&amp; performance !== <span class="literal">null</span> ? <span class="keyword">typeof</span> performance.<span class="property">now</span> === <span class="string">&quot;function&quot;</span> ? performance.<span class="title function_">now</span>() : <span class="keyword">void</span> <span class="number">0</span> : <span class="keyword">void</span> <span class="number">0</span>) != <span class="literal">null</span> ? _ref : +(<span class="keyword">new</span> <span class="title class_">Date</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  requestAnimationFrame = <span class="variable language_">window</span>.<span class="property">requestAnimationFrame</span> || <span class="variable language_">window</span>.<span class="property">mozRequestAnimationFrame</span> || <span class="variable language_">window</span>.<span class="property">webkitRequestAnimationFrame</span> || <span class="variable language_">window</span>.<span class="property">msRequestAnimationFrame</span>;</span><br><span class="line"></span><br><span class="line">  cancelAnimationFrame = <span class="variable language_">window</span>.<span class="property">cancelAnimationFrame</span> || <span class="variable language_">window</span>.<span class="property">mozCancelAnimationFrame</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (requestAnimationFrame == <span class="literal">null</span>) &#123;</span><br><span class="line">    requestAnimationFrame = <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">setTimeout</span>(fn, <span class="number">50</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    cancelAnimationFrame = <span class="keyword">function</span>(<span class="params">id</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">clearTimeout</span>(id);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ​每间隔33ms执行一次fn（fn就是检测所有实例都为done），并在下一帧再次开始33ms递归，直到所有实例都为done​</span></span><br><span class="line">  runAnimation = <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> last, tick;</span><br><span class="line">    last = <span class="title function_">now</span>();</span><br><span class="line">    tick = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> diff;</span><br><span class="line">      diff = <span class="title function_">now</span>() - last;</span><br><span class="line">      <span class="keyword">if</span> (diff &gt;= <span class="number">33</span>) &#123;</span><br><span class="line">        last = <span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>(diff, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="comment">// 下一帧执行tick，递归</span></span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">requestAnimationFrame</span>(tick);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不慢33ms，递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setTimeout</span>(tick, <span class="number">33</span> - diff);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">tick</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// obj = &#123;a: ()=&gt; &#123;&#125;, b: &#x27;string&#x27;&#125;, result(obj, a/b, arguments)等价于 obj.a() 或obj.b</span></span><br><span class="line">  result = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> args, key, obj;</span><br><span class="line">    obj = <span class="variable language_">arguments</span>[<span class="number">0</span>], key = <span class="variable language_">arguments</span>[<span class="number">1</span>], args = <span class="number">3</span> &lt;= <span class="variable language_">arguments</span>.<span class="property">length</span> ? __slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">2</span>) : [];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> obj[key].<span class="title function_">apply</span>(obj, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现一个extend</span></span><br><span class="line">  extend = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> key, out, source, sources, val, _i, _len;</span><br><span class="line">    out = <span class="variable language_">arguments</span>[<span class="number">0</span>], sources = <span class="number">2</span> &lt;= <span class="variable language_">arguments</span>.<span class="property">length</span> ? __slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>) : [];</span><br><span class="line">    <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = sources.<span class="property">length</span>; _i &lt; _len; _i++) &#123;</span><br><span class="line">      source = sources[_i];</span><br><span class="line">      <span class="keyword">if</span> (source) &#123;</span><br><span class="line">        <span class="keyword">for</span> (key <span class="keyword">in</span> source) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!__hasProp.<span class="title function_">call</span>(source, key)) <span class="keyword">continue</span>;</span><br><span class="line">          val = source[key];</span><br><span class="line">          <span class="keyword">if</span> ((out[key] != <span class="literal">null</span>) &amp;&amp; <span class="keyword">typeof</span> out[key] === <span class="string">&#x27;object&#x27;</span> &amp;&amp; (val != <span class="literal">null</span>) &amp;&amp; <span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">extend</span>(out[key], val);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out[key] = val;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 求数组每一项绝对值的和的平均值</span></span><br><span class="line">  <span class="comment">// avgAmplitude([1, -1, 2, -2])  = 1.5</span></span><br><span class="line">  avgAmplitude = <span class="keyword">function</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> count, sum, v, _i, _len;</span><br><span class="line">    sum = count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = arr.<span class="property">length</span>; _i &lt; _len; _i++) &#123;</span><br><span class="line">      v = arr[_i];</span><br><span class="line">      sum += <span class="title class_">Math</span>.<span class="title function_">abs</span>(v);</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum / count;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从data-pace-options里读取配置信息</span></span><br><span class="line">  <span class="comment">// &lt;script data-pace-options=&#x27;&#123; &quot;ajax&quot;: false &#125;&#x27; src=&#x27;pace.js&#x27;&gt;&lt;/script&gt;</span></span><br><span class="line">  getFromDOM = <span class="keyword">function</span>(<span class="params">key, json</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> data, e, el;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">      key = <span class="string">&#x27;options&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (json == <span class="literal">null</span>) &#123;</span><br><span class="line">      json = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    el = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;[data-pace-&quot;</span> + key + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!el) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    data = el.<span class="title function_">getAttribute</span>(<span class="string">&quot;data-pace-&quot;</span> + key);</span><br><span class="line">    <span class="keyword">if</span> (!json) &#123;</span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (_error) &#123;</span><br><span class="line">      e = _error;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="variable language_">console</span> !== <span class="string">&quot;undefined&quot;</span> &amp;&amp; <span class="variable language_">console</span> !== <span class="literal">null</span> ? <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error parsing inline pace options&quot;</span>, e) : <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// on监听方法，trigger触发方法，Evented原型里的方法被添加到Pace里</span></span><br><span class="line">  <span class="title class_">Evented</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Evented</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// on方法保存同名事件在一个数组</span></span><br><span class="line">    <span class="comment">// Evented.bindings = &#123;</span></span><br><span class="line">    <span class="comment">//   events: [</span></span><br><span class="line">    <span class="comment">//     event1, events2...</span></span><br><span class="line">    <span class="comment">//   ]</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// trigger(event) =&gt;   handler.apply(ctx, args);</span></span><br><span class="line">    <span class="title class_">Evented</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">on</span> = <span class="keyword">function</span>(<span class="params">event, handler, ctx, once</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> _base;</span><br><span class="line">      <span class="keyword">if</span> (once == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 掉once方法时为true</span></span><br><span class="line">        once = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">bindings</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">bindings</span> = &#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((_base = <span class="variable language_">this</span>.<span class="property">bindings</span>)[event] == <span class="literal">null</span>) &#123;</span><br><span class="line">        _base[event] = [];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">bindings</span>[event].<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">handler</span>: handler,</span><br><span class="line">        <span class="attr">ctx</span>: ctx,</span><br><span class="line">        <span class="attr">once</span>: once</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Evented</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">once</span> = <span class="keyword">function</span>(<span class="params">event, handler, ctx</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">on</span>(event, handler, ctx, <span class="literal">true</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 若handler为空，则移空整个event数组，否则将this.bindings里存储的对应event移除</span></span><br><span class="line">    <span class="title class_">Evented</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">off</span> = <span class="keyword">function</span>(<span class="params">event, handler</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> i, _ref, _results;</span><br><span class="line">      <span class="keyword">if</span> (((_ref = <span class="variable language_">this</span>.<span class="property">bindings</span>) != <span class="literal">null</span> ? _ref[event] : <span class="keyword">void</span> <span class="number">0</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">bindings</span>[event];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        _results = [];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="variable language_">this</span>.<span class="property">bindings</span>[event].<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">bindings</span>[event][i].<span class="property">handler</span> === handler) &#123;</span><br><span class="line">            _results.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">bindings</span>[event].<span class="title function_">splice</span>(i, <span class="number">1</span>));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _results.<span class="title function_">push</span>(i++);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _results;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将this.bindings里存储的events拿出来，在传入的this环境一个一个执行</span></span><br><span class="line">    <span class="title class_">Evented</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">trigger</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> args, ctx, event, handler, i, once, _ref, _ref1, _results;</span><br><span class="line">      event = <span class="variable language_">arguments</span>[<span class="number">0</span>], args = <span class="number">2</span> &lt;= <span class="variable language_">arguments</span>.<span class="property">length</span> ? __slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>) : [];</span><br><span class="line">      <span class="keyword">if</span> ((_ref = <span class="variable language_">this</span>.<span class="property">bindings</span>) != <span class="literal">null</span> ? _ref[event] : <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        _results = [];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="variable language_">this</span>.<span class="property">bindings</span>[event].<span class="property">length</span>) &#123;</span><br><span class="line">          _ref1 = <span class="variable language_">this</span>.<span class="property">bindings</span>[event][i], handler = _ref1.<span class="property">handler</span>, ctx = _ref1.<span class="property">ctx</span>, once = _ref1.<span class="property">once</span>;</span><br><span class="line">          handler.<span class="title function_">apply</span>(ctx != <span class="literal">null</span> ? ctx : <span class="variable language_">this</span>, args);</span><br><span class="line">          <span class="keyword">if</span> (once) &#123;</span><br><span class="line">            _results.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">bindings</span>[event].<span class="title function_">splice</span>(i, <span class="number">1</span>));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _results.<span class="title function_">push</span>(i++);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _results;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Evented</span>;</span><br><span class="line"></span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Pace</span> = <span class="variable language_">window</span>.<span class="property">Pace</span> || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">Pace</span> = <span class="title class_">Pace</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">extend</span>(<span class="title class_">Pace</span>, <span class="title class_">Evented</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line">  options = <span class="title class_">Pace</span>.<span class="property">options</span> = <span class="title function_">extend</span>(&#123;&#125;, defaultOptions, <span class="variable language_">window</span>.<span class="property">paceOptions</span>, <span class="title function_">getFromDOM</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// window.paceOptions为true的属性，都使用defaultOptions的设置</span></span><br><span class="line">  _ref = [<span class="string">&#x27;ajax&#x27;</span>, <span class="string">&#x27;document&#x27;</span>, <span class="string">&#x27;eventLag&#x27;</span>, <span class="string">&#x27;elements&#x27;</span>];</span><br><span class="line">  <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref.<span class="property">length</span>; _i &lt; _len; _i++) &#123;</span><br><span class="line">    source = _ref[_i];</span><br><span class="line">    <span class="keyword">if</span> (options[source] === <span class="literal">true</span>) &#123;</span><br><span class="line">      options[source] = defaultOptions[source];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没细看，感觉是继承了Error对象，不知道为什么这样做</span></span><br><span class="line">  <span class="title class_">NoTargetError</span> = (<span class="keyword">function</span>(<span class="params">_super</span>) &#123;</span><br><span class="line">    <span class="title function_">__extends</span>(<span class="title class_">NoTargetError</span>, _super);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">NoTargetError</span>(<span class="params"></span>) &#123;</span><br><span class="line">      _ref1 = <span class="title class_">NoTargetError</span>.<span class="property">__super__</span>.<span class="property">constructor</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">      <span class="keyword">return</span> _ref1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">NoTargetError</span>;</span><br><span class="line"></span><br><span class="line">  &#125;)(<span class="title class_">Error</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Bar</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">progress</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Bar</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getElement</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> targetElement;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">el</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        targetElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">target</span>);</span><br><span class="line">        <span class="keyword">if</span> (!targetElement) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoTargetError</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 渲染成这样，插入body下第一个元素</span></span><br><span class="line">        <span class="comment">// &lt;div class=&quot;pace  pace-inactive&quot;&gt;</span></span><br><span class="line">        <span class="comment">//   &lt;div class=&quot;pace-progress&quot; data-progress-text=&quot;10%&quot;&gt;</span></span><br><span class="line">        <span class="comment">//     ::before</span></span><br><span class="line">        <span class="comment">//     &lt;div class=&quot;pace-progress-inner&quot;&gt;&lt;/div&gt;</span></span><br><span class="line">        <span class="comment">//   &lt;/div&gt;</span></span><br><span class="line">        <span class="comment">//   &lt;div class=&quot;pace-activity&quot;&gt;&lt;/div&gt;</span></span><br><span class="line">        <span class="comment">// &lt;/div&gt;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">el</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">el</span>.<span class="property">className</span> = <span class="string">&quot;pace pace-active&quot;</span>;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span>.<span class="title function_">replace</span>(<span class="regexp">/pace-done/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> += <span class="string">&#x27; pace-running&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">el</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;div class=&quot;pace-progress&quot;&gt;\n  &lt;div class=&quot;pace-progress-inner&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;div class=&quot;pace-activity&quot;&gt;&lt;/div&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (targetElement.<span class="property">firstChild</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">          targetElement.<span class="title function_">insertBefore</span>(<span class="variable language_">this</span>.<span class="property">el</span>, targetElement.<span class="property">firstChild</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          targetElement.<span class="title function_">appendChild</span>(<span class="variable language_">this</span>.<span class="property">el</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">el</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Bar</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">finish</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> el;</span><br><span class="line">      el = <span class="variable language_">this</span>.<span class="title function_">getElement</span>();</span><br><span class="line">      el.<span class="property">className</span> = el.<span class="property">className</span>.<span class="title function_">replace</span>(<span class="string">&#x27;pace-active&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">      el.<span class="property">className</span> += <span class="string">&#x27; pace-inactive&#x27;</span>;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span>.<span class="title function_">replace</span>(<span class="string">&#x27;pace-running&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> += <span class="string">&#x27; pace-done&#x27;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Bar</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">update</span> = <span class="keyword">function</span>(<span class="params">prog</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">progress</span> = prog;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">render</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Bar</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">destroy</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getElement</span>().<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(<span class="variable language_">this</span>.<span class="title function_">getElement</span>());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (_error) &#123;</span><br><span class="line">        <span class="title class_">NoTargetError</span> = _error;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">el</span> = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过更新data-progress-text、data-progress属性，来影响css</span></span><br><span class="line">    <span class="title class_">Bar</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">render</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> el, key, progressStr, transform, _j, _len1, _ref2;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">target</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      el = <span class="variable language_">this</span>.<span class="title function_">getElement</span>();</span><br><span class="line">      transform = <span class="string">&quot;translate3d(&quot;</span> + <span class="variable language_">this</span>.<span class="property">progress</span> + <span class="string">&quot;%, 0, 0)&quot;</span>;</span><br><span class="line">      _ref2 = [<span class="string">&#x27;webkitTransform&#x27;</span>, <span class="string">&#x27;msTransform&#x27;</span>, <span class="string">&#x27;transform&#x27;</span>];</span><br><span class="line">      <span class="keyword">for</span> (_j = <span class="number">0</span>, _len1 = _ref2.<span class="property">length</span>; _j &lt; _len1; _j++) &#123;</span><br><span class="line">        key = _ref2[_j];</span><br><span class="line">        el.<span class="property">children</span>[<span class="number">0</span>].<span class="property">style</span>[key] = transform;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">lastRenderedProgress</span> || <span class="variable language_">this</span>.<span class="property">lastRenderedProgress</span> | <span class="number">0</span> !== <span class="variable language_">this</span>.<span class="property">progress</span> | <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 进度文案更新</span></span><br><span class="line">        el.<span class="property">children</span>[<span class="number">0</span>].<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-progress-text&#x27;</span>, <span class="string">&quot;&quot;</span> + (<span class="variable language_">this</span>.<span class="property">progress</span> | <span class="number">0</span>) + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">progress</span> &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">          progressStr = <span class="string">&#x27;99&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          progressStr = <span class="variable language_">this</span>.<span class="property">progress</span> &lt; <span class="number">10</span> ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line">          progressStr += <span class="variable language_">this</span>.<span class="property">progress</span> | <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关联css rotate角度的样式</span></span><br><span class="line">        el.<span class="property">children</span>[<span class="number">0</span>].<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-progress&#x27;</span>, <span class="string">&quot;&quot;</span> + progressStr);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">lastRenderedProgress</span> = <span class="variable language_">this</span>.<span class="property">progress</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Bar</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">done</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">progress</span> &gt;= <span class="number">100</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Bar</span>;</span><br><span class="line"></span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// on方法和trigger方法</span></span><br><span class="line">  <span class="title class_">Events</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Events</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">bindings</span> = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Events</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">trigger</span> = <span class="keyword">function</span>(<span class="params">name, val</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> binding, _j, _len1, _ref2, _results;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">bindings</span>[name] != <span class="literal">null</span>) &#123;</span><br><span class="line">        _ref2 = <span class="variable language_">this</span>.<span class="property">bindings</span>[name];</span><br><span class="line">        _results = [];</span><br><span class="line">        <span class="keyword">for</span> (_j = <span class="number">0</span>, _len1 = _ref2.<span class="property">length</span>; _j &lt; _len1; _j++) &#123;</span><br><span class="line">          binding = _ref2[_j];</span><br><span class="line">          _results.<span class="title function_">push</span>(binding.<span class="title function_">call</span>(<span class="variable language_">this</span>, val));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _results;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Events</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">on</span> = <span class="keyword">function</span>(<span class="params">name, fn</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> _base;</span><br><span class="line">      <span class="keyword">if</span> ((_base = <span class="variable language_">this</span>.<span class="property">bindings</span>)[name] == <span class="literal">null</span>) &#123;</span><br><span class="line">        _base[name] = [];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">bindings</span>[name].<span class="title function_">push</span>(fn);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Events</span>;</span><br><span class="line"></span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  _XMLHttpRequest = <span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// IE8和IE9:XDomainRequest, IE10以上:XMLHttpRequest</span></span><br><span class="line">  _XDomainRequest = <span class="variable language_">window</span>.<span class="property">XDomainRequest</span>;</span><br><span class="line"></span><br><span class="line">  _WebSocket = <span class="variable language_">window</span>.<span class="property">WebSocket</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// to是模拟对象，from是原生对象，对于from对象里每个不是function的属性，to如果没有，就从form取</span></span><br><span class="line">  extendNative = <span class="keyword">function</span>(<span class="params">to, <span class="keyword">from</span></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> e, key, _results;</span><br><span class="line">    _results = [];</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> <span class="keyword">from</span>.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((to[key] == <span class="literal">null</span>) &amp;&amp; <span class="keyword">typeof</span> <span class="keyword">from</span>[key] !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Object</span>.<span class="property">defineProperty</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            _results.<span class="title function_">push</span>(<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(to, key, &#123;</span><br><span class="line">              <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">from</span>.<span class="property"><span class="keyword">prototype</span></span>[key];</span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">            &#125;));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _results.<span class="title function_">push</span>(to[key] = <span class="keyword">from</span>.<span class="property"><span class="keyword">prototype</span></span>[key]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          _results.<span class="title function_">push</span>(<span class="keyword">void</span> <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (_error) &#123;</span><br><span class="line">        e = _error;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _results;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  ignoreStack = [];</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Pace</span>.<span class="property">ignore</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> args, fn, ret;</span><br><span class="line">    fn = <span class="variable language_">arguments</span>[<span class="number">0</span>], args = <span class="number">2</span> &lt;= <span class="variable language_">arguments</span>.<span class="property">length</span> ? __slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>) : [];</span><br><span class="line">    ignoreStack.<span class="title function_">unshift</span>(<span class="string">&#x27;ignore&#x27;</span>);</span><br><span class="line">    ret = fn.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br><span class="line">    ignoreStack.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Pace</span>.<span class="property">track</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> args, fn, ret;</span><br><span class="line">    fn = <span class="variable language_">arguments</span>[<span class="number">0</span>], args = <span class="number">2</span> &lt;= <span class="variable language_">arguments</span>.<span class="property">length</span> ? __slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>) : [];</span><br><span class="line">    ignoreStack.<span class="title function_">unshift</span>(<span class="string">&#x27;track&#x27;</span>);</span><br><span class="line">    ret = fn.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br><span class="line">    ignoreStack.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  shouldTrack = <span class="keyword">function</span>(<span class="params">method</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> _ref2;</span><br><span class="line">    <span class="keyword">if</span> (method == <span class="literal">null</span>) &#123;</span><br><span class="line">      method = <span class="string">&#x27;GET&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ignoreStack[<span class="number">0</span>] === <span class="string">&#x27;track&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;force&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ignoreStack.<span class="property">length</span> &amp;&amp; options.<span class="property">ajax</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (method === <span class="string">&#x27;socket&#x27;</span> &amp;&amp; options.<span class="property">ajax</span>.<span class="property">trackWebSockets</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_ref2 = method.<span class="title function_">toUpperCase</span>(), __indexOf.<span class="title function_">call</span>(options.<span class="property">ajax</span>.<span class="property">trackMethods</span>, _ref2) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装发送ajax请求的XMLHttpRequest，XDomainRequest 的代理</span></span><br><span class="line">  <span class="title class_">RequestIntercept</span> = (<span class="keyword">function</span>(<span class="params">_super</span>) &#123;</span><br><span class="line">    <span class="comment">// RequestIntercept继承了Events里的on、trigger</span></span><br><span class="line">    <span class="title function_">__extends</span>(<span class="title class_">RequestIntercept</span>, _super);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">RequestIntercept</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> monitorXHR,</span><br><span class="line">        _this = <span class="variable language_">this</span>;</span><br><span class="line">      <span class="title class_">RequestIntercept</span>.<span class="property">__super__</span>.<span class="property">constructor</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">      <span class="comment">// 代理xhr的open方法</span></span><br><span class="line">      monitorXHR = <span class="keyword">function</span>(<span class="params">req</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> _open;</span><br><span class="line">        _open = req.<span class="property">open</span>;</span><br><span class="line">        <span class="keyword">return</span> req.<span class="property">open</span> = <span class="keyword">function</span>(<span class="params">type, url, <span class="keyword">async</span></span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">shouldTrack</span>(type)) &#123;</span><br><span class="line">            _this.<span class="title function_">trigger</span>(<span class="string">&#x27;request&#x27;</span>, &#123;</span><br><span class="line">              <span class="attr">type</span>: type,</span><br><span class="line">              <span class="attr">url</span>: url,</span><br><span class="line">              <span class="attr">request</span>: req</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> _open.<span class="title function_">apply</span>(req, <span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// new了一个原生xhr，返回一个代理后的xhr</span></span><br><span class="line">      <span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span> = <span class="keyword">function</span>(<span class="params">flags</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> req;</span><br><span class="line">        req = <span class="keyword">new</span> <span class="title function_">_XMLHttpRequest</span>(flags);</span><br><span class="line">        <span class="title function_">monitorXHR</span>(req);</span><br><span class="line">        <span class="keyword">return</span> req;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 进一步完善代理xhr，除open，其它方法从用原生中继承</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_">extendNative</span>(<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>, _XMLHttpRequest);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (_error) &#123;&#125;</span><br><span class="line">      <span class="comment">// 以下是 代理 IE8和IE9:XDomainRequest，可不看</span></span><br><span class="line">      <span class="keyword">if</span> (_XDomainRequest != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">XDomainRequest</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">var</span> req;</span><br><span class="line">          req = <span class="keyword">new</span> _XDomainRequest;</span><br><span class="line">          <span class="title function_">monitorXHR</span>(req);</span><br><span class="line">          <span class="keyword">return</span> req;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="title function_">extendNative</span>(<span class="variable language_">window</span>.<span class="property">XDomainRequest</span>, _XDomainRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (_error) &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((_WebSocket != <span class="literal">null</span>) &amp;&amp; options.<span class="property">ajax</span>.<span class="property">trackWebSockets</span>) &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">WebSocket</span> = <span class="keyword">function</span>(<span class="params">url, protocols</span>) &#123;</span><br><span class="line">          <span class="keyword">var</span> req;</span><br><span class="line">          <span class="keyword">if</span> (protocols != <span class="literal">null</span>) &#123;</span><br><span class="line">            req = <span class="keyword">new</span> <span class="title function_">_WebSocket</span>(url, protocols);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            req = <span class="keyword">new</span> <span class="title function_">_WebSocket</span>(url);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">shouldTrack</span>(<span class="string">&#x27;socket&#x27;</span>)) &#123;</span><br><span class="line">            _this.<span class="title function_">trigger</span>(<span class="string">&#x27;request&#x27;</span>, &#123;</span><br><span class="line">              <span class="attr">type</span>: <span class="string">&#x27;socket&#x27;</span>,</span><br><span class="line">              <span class="attr">url</span>: url,</span><br><span class="line">              <span class="attr">protocols</span>: protocols,</span><br><span class="line">              <span class="attr">request</span>: req</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> req;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="title function_">extendNative</span>(<span class="variable language_">window</span>.<span class="property">WebSocket</span>, _WebSocket);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (_error) &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">RequestIntercept</span>;</span><br><span class="line"></span><br><span class="line">  &#125;)(<span class="title class_">Events</span>);</span><br><span class="line"></span><br><span class="line">  _intercept = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  getIntercept = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_intercept == <span class="literal">null</span>) &#123;</span><br><span class="line">      _intercept = <span class="keyword">new</span> <span class="title class_">RequestIntercept</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _intercept;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对传入的url进行检测，若在ignoreURLs中，返回true，否则false</span></span><br><span class="line">  shouldIgnoreURL = <span class="keyword">function</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> pattern, _j, _len1, _ref2;</span><br><span class="line">    _ref2 = options.<span class="property">ajax</span>.<span class="property">ignoreURLs</span>;</span><br><span class="line">    <span class="keyword">for</span> (_j = <span class="number">0</span>, _len1 = _ref2.<span class="property">length</span>; _j &lt; _len1; _j++) &#123;</span><br><span class="line">      pattern = _ref2[_j];</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> pattern === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (url.<span class="title function_">indexOf</span>(pattern) !== -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern.<span class="title function_">test</span>(url)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// init()时，Pace.sources装了4个实例，找出AjaxMonitor的实例，若0 &lt; readyState &lt; 4，执行AjaxMonitor.watch()</span></span><br><span class="line">  <span class="title function_">getIntercept</span>().<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="keyword">function</span>(<span class="params">_arg</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> after, args, request, type, url;</span><br><span class="line">    type = _arg.<span class="property">type</span>, request = _arg.<span class="property">request</span>, url = _arg.<span class="property">url</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">shouldIgnoreURL</span>(url)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Pace</span>.<span class="property">running</span> &amp;&amp; (options.<span class="property">restartOnRequestAfter</span> !== <span class="literal">false</span> || <span class="title function_">shouldTrack</span>(type) === <span class="string">&#x27;force&#x27;</span>)) &#123;</span><br><span class="line">      args = <span class="variable language_">arguments</span>;</span><br><span class="line">      after = options.<span class="property">restartOnRequestAfter</span> || <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> after === <span class="string">&#x27;boolean&#x27;</span>) &#123;</span><br><span class="line">        after = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> stillActive, _j, _len1, _ref2, _ref3, _results;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">&#x27;socket&#x27;</span>) &#123;</span><br><span class="line">          stillActive = request.<span class="property">readyState</span> &lt; <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 0: 请求未初始化  ---- 代理被创建，但尚未调用 open() 方法</span></span><br><span class="line">          <span class="comment">// 1: 服务器连接已建立  ---- open() 方法已经被调用。</span></span><br><span class="line">          <span class="comment">// 2: 请求已接收  ---- send() 方法已经被调用，并且头部和状态已经可获得。</span></span><br><span class="line">          <span class="comment">// 3: 请求处理中</span></span><br><span class="line">          <span class="comment">// 4: 请求已完成，且响应已就绪</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 0 &lt; readyState &lt; 4，请求未完成</span></span><br><span class="line">          stillActive = (<span class="number">0</span> &lt; (_ref2 = request.<span class="property">readyState</span>) &amp;&amp; _ref2 &lt; <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stillActive) &#123;</span><br><span class="line">          <span class="title class_">Pace</span>.<span class="title function_">restart</span>();</span><br><span class="line">          <span class="comment">// ajax: AjaxMonitor,</span></span><br><span class="line">          <span class="comment">// elements: ElementMonitor,</span></span><br><span class="line">          <span class="comment">// document: DocumentMonitor,</span></span><br><span class="line">          <span class="comment">// eventLag: EventLagMonitor</span></span><br><span class="line">          <span class="comment">// Pace.sources里是上面4个的实例</span></span><br><span class="line">          _ref3 = <span class="title class_">Pace</span>.<span class="property">sources</span>;</span><br><span class="line">          _results = [];</span><br><span class="line">          <span class="comment">// 如果有AjaxMonitor的实例，执行watch方法</span></span><br><span class="line">          <span class="keyword">for</span> (_j = <span class="number">0</span>, _len1 = _ref3.<span class="property">length</span>; _j &lt; _len1; _j++) &#123;</span><br><span class="line">            source = _ref3[_j];</span><br><span class="line">            <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">AjaxMonitor</span>) &#123;</span><br><span class="line">              source.<span class="property">watch</span>.<span class="title function_">apply</span>(source, args);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              _results.<span class="title function_">push</span>(<span class="keyword">void</span> <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> _results;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, after);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// this.elements = []，里面保存有XHRRequestTracker实例，有progres属性</span></span><br><span class="line">  <span class="title class_">AjaxMonitor</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">AjaxMonitor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">elements</span> = [];</span><br><span class="line">      <span class="title function_">getIntercept</span>().<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _this.<span class="property">watch</span>.<span class="title function_">apply</span>(_this, <span class="variable language_">arguments</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AjaxMonitor.elements.push(tracker);</span></span><br><span class="line">    <span class="title class_">AjaxMonitor</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">watch</span> = <span class="keyword">function</span>(<span class="params">_arg</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> request, tracker, type, url;</span><br><span class="line">      type = _arg.<span class="property">type</span>, request = _arg.<span class="property">request</span>, url = _arg.<span class="property">url</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">shouldIgnoreURL</span>(url)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (type === <span class="string">&#x27;socket&#x27;</span>) &#123;</span><br><span class="line">        tracker = <span class="keyword">new</span> <span class="title class_">SocketRequestTracker</span>(request);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tracker = <span class="keyword">new</span> <span class="title class_">XHRRequestTracker</span>(request);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">elements</span>.<span class="title function_">push</span>(tracker);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">AjaxMonitor</span>;</span><br><span class="line"></span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听xhr，根据浏览器是否支持ProgressEvent，算出progress</span></span><br><span class="line">  <span class="title class_">XHRRequestTracker</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">XHRRequestTracker</span>(<span class="params">request</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> event, size, _j, _len1, _onreadystatechange, _ref2,</span><br><span class="line">        _this = <span class="variable language_">this</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">progress</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// ProgressEvent 接口是测量如 HTTP 请求（一个XMLHttpRequest，或者一个 &lt;img&gt;，&lt;audio&gt;，&lt;video&gt;，&lt;style&gt; 或 &lt;link&gt; 等底层资源的加载）等底层流程进度的事件。</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">ProgressEvent</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        size = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// https://developer.mozilla.org/zh-CN/docs/Web/API/ProgressEvent</span></span><br><span class="line">        <span class="comment">// progress事件会在浏览器接收新数据期间周期性地触发。</span></span><br><span class="line">        <span class="comment">// 而onprogress事件处理程序会接收到一个event对象，其target属性是XHR对象，</span></span><br><span class="line">        <span class="comment">// 但包含着三个额外的属性：lengthComputable、loaded和total。</span></span><br><span class="line">        <span class="comment">// 其中，lengthComputable告诉我们进度是否可以被测量，loaded表示已经接收的字节数，</span></span><br><span class="line">        <span class="comment">// loaded表示根据Content-Length响应头部确定的预期字节数</span></span><br><span class="line">        request.<span class="title function_">addEventListener</span>(<span class="string">&#x27;progress&#x27;</span>, <span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (evt.<span class="property">lengthComputable</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _this.<span class="property">progress</span> = <span class="number">100</span> * evt.<span class="property">loaded</span> / evt.<span class="property">total</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> _this.<span class="property">progress</span> = _this.<span class="property">progress</span> + (<span class="number">100</span> - _this.<span class="property">progress</span>) / <span class="number">2</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 若监听到以下请求错误事件，progress=100，如：&#x27;abort&#x27;、&#x27;timeout&#x27;、&#x27;error&#x27;</span></span><br><span class="line">        <span class="comment">// 若请求成功完成时触发load，progress=100</span></span><br><span class="line">        _ref2 = [<span class="string">&#x27;load&#x27;</span>, <span class="string">&#x27;abort&#x27;</span>, <span class="string">&#x27;timeout&#x27;</span>, <span class="string">&#x27;error&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (_j = <span class="number">0</span>, _len1 = _ref2.<span class="property">length</span>; _j &lt; _len1; _j++) &#123;</span><br><span class="line">          event = _ref2[_j];</span><br><span class="line">          request.<span class="title function_">addEventListener</span>(event, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _this.<span class="property">progress</span> = <span class="number">100</span>;</span><br><span class="line">          &#125;, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不支持ProgressEvent的浏览器，监听readyState，50 ，100</span></span><br><span class="line">        _onreadystatechange = request.<span class="property">onreadystatechange</span>;</span><br><span class="line">        request.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">var</span> _ref3;</span><br><span class="line">          <span class="keyword">if</span> ((_ref3 = request.<span class="property">readyState</span>) === <span class="number">0</span> || _ref3 === <span class="number">4</span>) &#123;</span><br><span class="line">            _this.<span class="property">progress</span> = <span class="number">100</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.<span class="property">readyState</span> === <span class="number">3</span>) &#123;</span><br><span class="line">            _this.<span class="property">progress</span> = <span class="number">50</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">typeof</span> _onreadystatechange === <span class="string">&quot;function&quot;</span> ? _onreadystatechange.<span class="title function_">apply</span>(<span class="literal">null</span>, <span class="variable language_">arguments</span>) : <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">XHRRequestTracker</span>;</span><br><span class="line"></span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  <span class="title class_">SocketRequestTracker</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">SocketRequestTracker</span>(<span class="params">request</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> event, _j, _len1, _ref2,</span><br><span class="line">        _this = <span class="variable language_">this</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">progress</span> = <span class="number">0</span>;</span><br><span class="line">      _ref2 = [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;open&#x27;</span>];</span><br><span class="line">      <span class="keyword">for</span> (_j = <span class="number">0</span>, _len1 = _ref2.<span class="property">length</span>; _j &lt; _len1; _j++) &#123;</span><br><span class="line">        event = _ref2[_j];</span><br><span class="line">        request.<span class="title function_">addEventListener</span>(event, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> _this.<span class="property">progress</span> = <span class="number">100</span>;</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">SocketRequestTracker</span>;</span><br><span class="line"></span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// options.selectors=[]里面存的是要跟踪的dom元素，dom加载成功，progress=100%</span></span><br><span class="line">  <span class="comment">// 该实例的this.elements里存着tracker（每个tracker映射着selectors里的dom），每个tracker都会每隔100ms，查询一次dom是否存在，若是则this.progress = 100</span></span><br><span class="line">  <span class="title class_">ElementMonitor</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">ElementMonitor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> selector, _j, _len1, _ref2;</span><br><span class="line">      <span class="keyword">if</span> (options == <span class="literal">null</span>) &#123;</span><br><span class="line">        options = &#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">elements</span> = [];</span><br><span class="line">      <span class="keyword">if</span> (options.<span class="property">selectors</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        options.<span class="property">selectors</span> = [];</span><br><span class="line">      &#125;</span><br><span class="line">      _ref2 = options.<span class="property">selectors</span>;</span><br><span class="line">      <span class="keyword">for</span> (_j = <span class="number">0</span>, _len1 = _ref2.<span class="property">length</span>; _j &lt; _len1; _j++) &#123;</span><br><span class="line">        selector = _ref2[_j];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">elements</span>.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">ElementTracker</span>(selector));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">ElementMonitor</span>;</span><br><span class="line"></span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每隔100ms，查询一次dom是否存在，若是则this.progress = 100</span></span><br><span class="line">  <span class="title class_">ElementTracker</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">ElementTracker</span>(<span class="params">selector</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">selector</span> = selector;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">progress</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">check</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">ElementTracker</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">check</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="variable language_">this</span>.<span class="property">selector</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">done</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setTimeout</span>((<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> _this.<span class="title function_">check</span>();</span><br><span class="line">        &#125;), options.<span class="property">elements</span>.<span class="property">checkInterval</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">ElementTracker</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">done</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">progress</span> = <span class="number">100</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">ElementTracker</span>;</span><br><span class="line"></span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Document.readyState 属性描述了document 的加载状态。</span></span><br><span class="line"><span class="comment">  *  1.loading:正在加载 </span></span><br><span class="line"><span class="comment">  *  2.interactive:可交互,文档已被解析，&quot;正在加载&quot;状态结束，但是诸如图像，样式表和框架之类的子资源仍在加载。</span></span><br><span class="line"><span class="comment">  *  3. complete（完成）,文档和所有子资源已完成加载。表示 load 状态的事件即将被触发。</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  *  这个三个状态分别对应的进度this.progresss = 0% 、50% 、100%</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="title class_">DocumentMonitor</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">DocumentMonitor</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">states</span> = &#123;</span><br><span class="line">      <span class="attr">loading</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">interactive</span>: <span class="number">50</span>,</span><br><span class="line">      <span class="attr">complete</span>: <span class="number">100</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">DocumentMonitor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> _onreadystatechange, _ref2,</span><br><span class="line">        _this = <span class="variable language_">this</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">progress</span> = (_ref2 = <span class="variable language_">this</span>.<span class="property">states</span>[<span class="variable language_">document</span>.<span class="property">readyState</span>]) != <span class="literal">null</span> ? _ref2 : <span class="number">100</span>;</span><br><span class="line">      _onreadystatechange = <span class="variable language_">document</span>.<span class="property">onreadystatechange</span>;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_this.<span class="property">states</span>[<span class="variable language_">document</span>.<span class="property">readyState</span>] != <span class="literal">null</span>) &#123;</span><br><span class="line">          _this.<span class="property">progress</span> = _this.<span class="property">states</span>[<span class="variable language_">document</span>.<span class="property">readyState</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> _onreadystatechange === <span class="string">&quot;function&quot;</span> ? _onreadystatechange.<span class="title function_">apply</span>(<span class="literal">null</span>, <span class="variable language_">arguments</span>) : <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">DocumentMonitor</span>;</span><br><span class="line"></span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//EventLagMonitor其实只是一个“假的”监视器。它就在那里安静匀速的更新进度，这一小小的措施却带来了不错的用户体验，让用户不会因为加载“卡住了”而慌张</span></span><br><span class="line">  <span class="comment">// 感觉怎么计算进度是一个数学问题，求一个数组绝对值的和的平均值，大于几小于几时，_this.progress = 100;</span></span><br><span class="line">  <span class="title class_">EventLagMonitor</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">EventLagMonitor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> avg, interval, last, points, samples,</span><br><span class="line">        _this = <span class="variable language_">this</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">progress</span> = <span class="number">0</span>;</span><br><span class="line">      avg = <span class="number">0</span>;</span><br><span class="line">      samples = [];</span><br><span class="line">      points = <span class="number">0</span>;</span><br><span class="line">      last = <span class="title function_">now</span>();</span><br><span class="line">      interval = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> diff;</span><br><span class="line">        diff = <span class="title function_">now</span>() - last - <span class="number">50</span>;</span><br><span class="line">        last = <span class="title function_">now</span>();</span><br><span class="line">        samples.<span class="title function_">push</span>(diff);</span><br><span class="line">        <span class="keyword">if</span> (samples.<span class="property">length</span> &gt; options.<span class="property">eventLag</span>.<span class="property">sampleCount</span>) &#123;</span><br><span class="line">          samples.<span class="title function_">shift</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求数组每一项绝对值的和的平均值，avgAmplitude([1, -1, 2, -2])  = 1.5</span></span><br><span class="line">        avg = <span class="title function_">avgAmplitude</span>(samples);</span><br><span class="line">        <span class="comment">// ++points &gt;= 10 &amp;&amp; avg &lt; 3</span></span><br><span class="line">        <span class="keyword">if</span> (++points &gt;= options.<span class="property">eventLag</span>.<span class="property">minSamples</span> &amp;&amp; avg &lt; options.<span class="property">eventLag</span>.<span class="property">lagThreshold</span>) &#123;</span><br><span class="line">          _this.<span class="property">progress</span> = <span class="number">100</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> _this.<span class="property">progress</span> = <span class="number">100</span> * (<span class="number">3</span> / (avg + <span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">EventLagMonitor</span>;</span><br><span class="line"></span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Scaler会取出实例的progress值，Scaler.tick()会将增加后的progress返回;</span></span><br><span class="line">  <span class="title class_">Scaler</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Scaler</span>(<span class="params">source</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">source</span> = source;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">last</span> = <span class="variable language_">this</span>.<span class="property">sinceLastUpdate</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">rate</span> = options.<span class="property">initialRate</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">catchup</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">progress</span> = <span class="variable language_">this</span>.<span class="property">lastProgress</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">source</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">progress</span> = <span class="title function_">result</span>(<span class="variable language_">this</span>.<span class="property">source</span>, <span class="string">&#x27;progress&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取到实例初始进度progress，以某种计算方式，使progress的值增大一点，再返回处理后的progress</span></span><br><span class="line">    <span class="title class_">Scaler</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">tick</span> = <span class="keyword">function</span>(<span class="params">frameTime, val</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> scaling;</span><br><span class="line">      <span class="comment">// 取到实例初始进度</span></span><br><span class="line">      <span class="keyword">if</span> (val == <span class="literal">null</span>) &#123;</span><br><span class="line">        val = <span class="title function_">result</span>(<span class="variable language_">this</span>.<span class="property">source</span>, <span class="string">&#x27;progress&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (val &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个属性很重要，for每个实例时，都会取对应的scaler.done，全部为true才bar.finish(),否则继续递归检测</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">done</span> = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (val === <span class="variable language_">this</span>.<span class="property">last</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sinceLastUpdate</span> += frameTime;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">sinceLastUpdate</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">rate</span> = (val - <span class="variable language_">this</span>.<span class="property">last</span>) / <span class="variable language_">this</span>.<span class="property">sinceLastUpdate</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">catchup</span> = (val - <span class="variable language_">this</span>.<span class="property">progress</span>) / options.<span class="property">catchupTime</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sinceLastUpdate</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">last</span> = val;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (val &gt; <span class="variable language_">this</span>.<span class="property">progress</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">progress</span> += <span class="variable language_">this</span>.<span class="property">catchup</span> * frameTime;</span><br><span class="line">      &#125;</span><br><span class="line">      scaling = <span class="number">1</span> - <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="variable language_">this</span>.<span class="property">progress</span> / <span class="number">100</span>, options.<span class="property">easeFactor</span>);</span><br><span class="line">      <span class="comment">// progress进度需要不停的增加，每次增加多少，通过上面的计算</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">progress</span> += scaling * <span class="variable language_">this</span>.<span class="property">rate</span> * frameTime;</span><br><span class="line">      <span class="comment">// 如果增量算的太多，不太合适，所以（初始progress + 20）和上面计算的progress取个最小值，也就是每次算的增量最大幅度是20（maxProgressPerFrame）</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">progress</span> = <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="variable language_">this</span>.<span class="property">lastProgress</span> + options.<span class="property">maxProgressPerFrame</span>, <span class="variable language_">this</span>.<span class="property">progress</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">progress</span> = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">progress</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">progress</span> = <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">100</span>, <span class="variable language_">this</span>.<span class="property">progress</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">lastProgress</span> = <span class="variable language_">this</span>.<span class="property">progress</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 返回增加一定进度的progress</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">progress</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Scaler</span>;</span><br><span class="line"></span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  sources = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  scalers = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  bar = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  uniScaler = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  animation = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  cancelAnimation = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Pace</span>.<span class="property">running</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  handlePushState = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">restartOnPushState</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Pace</span>.<span class="title function_">restart</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">history</span>.<span class="property">pushState</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    _pushState = <span class="variable language_">window</span>.<span class="property">history</span>.<span class="property">pushState</span>;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">history</span>.<span class="property">pushState</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">handlePushState</span>();</span><br><span class="line">      <span class="keyword">return</span> _pushState.<span class="title function_">apply</span>(<span class="variable language_">window</span>.<span class="property">history</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">history</span>.<span class="property">replaceState</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    _replaceState = <span class="variable language_">window</span>.<span class="property">history</span>.<span class="property">replaceState</span>;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">history</span>.<span class="property">replaceState</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">handlePushState</span>();</span><br><span class="line">      <span class="keyword">return</span> _replaceState.<span class="title function_">apply</span>(<span class="variable language_">window</span>.<span class="property">history</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable constant_">SOURCE_KEYS</span> = &#123;</span><br><span class="line">    <span class="attr">ajax</span>: <span class="title class_">AjaxMonitor</span>,</span><br><span class="line">    <span class="attr">elements</span>: <span class="title class_">ElementMonitor</span>,</span><br><span class="line">    <span class="attr">document</span>: <span class="title class_">DocumentMonitor</span>,</span><br><span class="line">    <span class="attr">eventLag</span>: <span class="title class_">EventLagMonitor</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明后，直接调用init(),后面还可以再调用init</span></span><br><span class="line">  (init = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> type, _j, _k, _len1, _len2, _ref2, _ref3, _ref4;</span><br><span class="line">    <span class="title class_">Pace</span>.<span class="property">sources</span> = sources = [];</span><br><span class="line">    _ref2 = [<span class="string">&#x27;ajax&#x27;</span>, <span class="string">&#x27;elements&#x27;</span>, <span class="string">&#x27;document&#x27;</span>, <span class="string">&#x27;eventLag&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span> (_j = <span class="number">0</span>, _len1 = _ref2.<span class="property">length</span>; _j &lt; _len1; _j++) &#123;</span><br><span class="line">      type = _ref2[_j];</span><br><span class="line">      <span class="keyword">if</span> (options[type] !== <span class="literal">false</span>) &#123;</span><br><span class="line">        sources.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="variable constant_">SOURCE_KEYS</span>[type](options[type]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没看见options.extraSources赋过值</span></span><br><span class="line">    _ref4 = (_ref3 = options.<span class="property">extraSources</span>) != <span class="literal">null</span> ? _ref3 : [];</span><br><span class="line">    <span class="keyword">for</span> (_k = <span class="number">0</span>, _len2 = _ref4.<span class="property">length</span>; _k &lt; _len2; _k++) &#123;</span><br><span class="line">      source = _ref4[_k];</span><br><span class="line">      sources.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title function_">source</span>(options));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Bar就是进度条dom实例，进度百分比关联着progress的值</span></span><br><span class="line">    <span class="title class_">Pace</span>.<span class="property">bar</span> = bar = <span class="keyword">new</span> <span class="title class_">Bar</span>;</span><br><span class="line">    scalers = [];</span><br><span class="line">    <span class="comment">// Scaler会取出实例的progress值，Scaler.tick()会将progress值增加一点后返回;</span></span><br><span class="line">    <span class="keyword">return</span> uniScaler = <span class="keyword">new</span> <span class="title class_">Scaler</span>;</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Pace</span>.<span class="property">stop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Pace</span>.<span class="title function_">trigger</span>(<span class="string">&#x27;stop&#x27;</span>);</span><br><span class="line">    <span class="title class_">Pace</span>.<span class="property">running</span> = <span class="literal">false</span>;</span><br><span class="line">    bar.<span class="title function_">destroy</span>();</span><br><span class="line">    cancelAnimation = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (animation != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> cancelAnimationFrame === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_">cancelAnimationFrame</span>(animation);</span><br><span class="line">      &#125;</span><br><span class="line">      animation = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">init</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Pace</span>.<span class="property">restart</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Pace</span>.<span class="title function_">trigger</span>(<span class="string">&#x27;restart&#x27;</span>);<span class="comment">// 未见监听</span></span><br><span class="line">    <span class="title class_">Pace</span>.<span class="title function_">stop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Pace</span>.<span class="title function_">start</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Pace</span>.<span class="property">go</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> start;</span><br><span class="line">    <span class="title class_">Pace</span>.<span class="property">running</span> = <span class="literal">true</span>;</span><br><span class="line">    bar.<span class="title function_">render</span>();</span><br><span class="line">    start = <span class="title function_">now</span>();</span><br><span class="line">    cancelAnimation = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 每间隔33ms检查所有实例是否都为done，否则下一帧继续间隔33ms的递归检测</span></span><br><span class="line">    <span class="keyword">return</span> animation = <span class="title function_">runAnimation</span>(<span class="keyword">function</span>(<span class="params">frameTime, enqueueNextFrame</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> avg, count, done, element, elements, i, j, remaining, scaler, scalerList, sum, _j, _k, _len1, _len2, _ref2;</span><br><span class="line">      remaining = <span class="number">100</span> - bar.<span class="property">progress</span>;</span><br><span class="line">      count = sum = <span class="number">0</span>;</span><br><span class="line">      done = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">for</span> (i = _j = <span class="number">0</span>, _len1 = sources.<span class="property">length</span>; _j &lt; _len1; i = ++_j) &#123;</span><br><span class="line">        source = sources[i];</span><br><span class="line">        scalerList = scalers[i] != <span class="literal">null</span> ? scalers[i] : scalers[i] = [];</span><br><span class="line">        elements = (_ref2 = source.<span class="property">elements</span>) != <span class="literal">null</span> ? _ref2 : [source];</span><br><span class="line">        <span class="keyword">for</span> (j = _k = <span class="number">0</span>, _len2 = elements.<span class="property">length</span>; _k &lt; _len2; j = ++_k) &#123;</span><br><span class="line">          element = elements[j];</span><br><span class="line">          scaler = scalerList[j] != <span class="literal">null</span> ? scalerList[j] : scalerList[j] = <span class="keyword">new</span> <span class="title class_">Scaler</span>(element);</span><br><span class="line">          <span class="comment">// a&amp;=b就是a=a&amp;b，有一个scaler.done不为true，done就不为true   逻辑语言运算符</span></span><br><span class="line">          done &amp;= scaler.<span class="property">done</span>;</span><br><span class="line">          <span class="keyword">if</span> (scaler.<span class="property">done</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// done不为true的element，求个数总和，scaler.tick会取出progress，再得到进度总和</span></span><br><span class="line">          count++;</span><br><span class="line">          sum += scaler.<span class="title function_">tick</span>(frameTime);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 得到平均进度progress</span></span><br><span class="line">      avg = sum / count;</span><br><span class="line">      bar.<span class="title function_">update</span>(uniScaler.<span class="title function_">tick</span>(frameTime, avg));</span><br><span class="line">      <span class="comment">// elements里实例的状态都是done了，进度100%，hide掉bar</span></span><br><span class="line">      <span class="keyword">if</span> (bar.<span class="title function_">done</span>() || done || cancelAnimation) &#123;</span><br><span class="line">        bar.<span class="title function_">update</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="title class_">Pace</span>.<span class="title function_">trigger</span>(<span class="string">&#x27;done&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">          bar.<span class="title function_">finish</span>();</span><br><span class="line">          <span class="title class_">Pace</span>.<span class="property">running</span> = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="title class_">Pace</span>.<span class="title function_">trigger</span>(<span class="string">&#x27;hide&#x27;</span>);</span><br><span class="line">        &#125;, <span class="title class_">Math</span>.<span class="title function_">max</span>(options.<span class="property">ghostTime</span>, <span class="title class_">Math</span>.<span class="title function_">max</span>(options.<span class="property">minTime</span> - (<span class="title function_">now</span>() - start), <span class="number">0</span>)));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">enqueueNextFrame</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Pace</span>.<span class="property">start</span> = <span class="keyword">function</span>(<span class="params">_options</span>) &#123;</span><br><span class="line">    <span class="title function_">extend</span>(options, _options);</span><br><span class="line">    <span class="title class_">Pace</span>.<span class="property">running</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      bar.<span class="title function_">render</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (_error) &#123;</span><br><span class="line">      <span class="title class_">NoTargetError</span> = _error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果找不到bar的话，说明bar.render失败，每隔50s 再render()一次</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.pace&#x27;</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">setTimeout</span>(<span class="title class_">Pace</span>.<span class="property">start</span>, <span class="number">50</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title class_">Pace</span>.<span class="title function_">trigger</span>(<span class="string">&#x27;start&#x27;</span>);<span class="comment">// 未找到Pace.on(&#x27;start&#x27;)方法监听trigger</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Pace</span>.<span class="title function_">go</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if (typeof define === &#x27;function&#x27; &amp;&amp; define.amd) &#123;</span></span><br><span class="line">  <span class="comment">// 	console.log(32323)</span></span><br><span class="line">  	</span><br><span class="line">  <span class="comment">//   define([&#x27;pace&#x27;], function() &#123;</span></span><br><span class="line">  <span class="comment">//     return Pace;</span></span><br><span class="line">  <span class="comment">//   &#125;);</span></span><br><span class="line">  <span class="comment">// &#125; else if (typeof exports === &#x27;object&#x27;) &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//   module.exports = Pace;</span></span><br><span class="line">  <span class="comment">// &#125; else &#123;</span></span><br><span class="line">  <span class="comment">//   if (options.startOnPageLoad) &#123;</span></span><br><span class="line">  <span class="comment">//     Pace.start();</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">	<span class="keyword">if</span> (options.<span class="property">startOnPageLoad</span>) &#123;</span><br><span class="line">    <span class="title class_">Pace</span>.<span class="title function_">start</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>quicklink原理解析(一)</title>
    <url>/2020/07/20/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/quicklink%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%901/</url>
    <content><![CDATA[<h2 id="quicklink是什么？"><a href="#quicklink是什么？" class="headerlink" title="quicklink是什么？"></a>quicklink是什么？</h2><p>quicklink 是一个通过预加载资源来提升访问速度的轻量级工具库（压缩后&lt; 1KB）,通过提前加载资源，使浏览器加载缓存资源，从而减少请求所消耗的时间，来达到快速打开页面的目的。</p>
<h2 id="How-it-works？"><a href="#How-it-works？" class="headerlink" title="How it works？"></a>How it works？</h2><ul>
<li><p>Waits until the browser is idle (using requestIdleCallback)</p>
</li>
<li><p>Detects links within the viewport (using Intersection Observer)</p>
</li>
<li><p>Checks if the user isn’t on a slow connection (using navigator.connection.effectiveType) or has data-saver enabled (using navigator.connection.saveData)</p>
</li>
<li><p>Prefetches URLs to the links (using <link rel=prefetch> or XHR). Provides some control over the request priority (can switch to fetch() if supported).</p>
</li>
</ul>
<h2 id="如何确定浏览器是否空闲？"><a href="#如何确定浏览器是否空闲？" class="headerlink" title="如何确定浏览器是否空闲？"></a>如何确定浏览器是否空闲？</h2><p>如果浏览器支持requestIdleCallback，则使用原生的函数，如果不支持，则使用setTimeout函数做ployfill。</p>
<p>requestIdleCallback：它指定只有当一帧的末尾有空闲时间，才会执行回调函数。一般浏览器的刷新频率是60HZ，也就是说，只有当前帧的运行时间小于16.66ms时，函数fn才会执行。否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推。<br><code>requestIdleCallback(callback[, timeout])</code></p>
<ol>
<li><p>callback<br>callback会接收到一个名为callback deadline 的参数，它具有如下属性 :<br>timeRemaining() 方法返回当前帧还剩余的毫秒。这个方法只能读，不能写，而且会动态更新。因此可以不断检查这个属性，如果还有剩余时间的话，就不断执行某些任务。一旦这个属性等于0，就把任务分配到下一轮requestIdleCallback。<br>deadline对象的 didTimeout 属性会返回一个布尔值，表示指定的时间是否过期。这意味着，如果回调函数由于指定时间过期而触发</p>
</li>
<li><p>timeout<br>如果在指定 的这段时间之内，每一帧都没有空闲时间，那么函数fn将会强制执行。</p>
</li>
</ol>
<h2 id="requestIdleCallback-兼容处理"><a href="#requestIdleCallback-兼容处理" class="headerlink" title="requestIdleCallback 兼容处理"></a>requestIdleCallback 兼容处理</h2><p>如果浏览器支持requestIdleCallback，则使用原生的函数，如果不支持，则使用setTimeout函数做ployfill。<br><img data-src="/2020/07/20/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/quicklink%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%901/01.png"></p>
<h2 id="如何预加载指定资源？"><a href="#如何预加载指定资源？" class="headerlink" title="如何预加载指定资源？"></a>如何预加载指定资源？</h2><p>常见的是通过一些技术手段来实现资源的预加载，例如使用XMLHttpRequest来获取资源并进行缓存。然而，这些技术都是应用层面的，并非Web标准，某些需求也无法准确实现，同时，在性能方面也存在着问题。好在目前已有相关的Web标准——Resource Hint，通过它，可以在浏览器原生层面实现这些功能，同时提供性能保证。</p>
<p>Resource Hint有5种：</p>
<ul>
<li>DNS Prefetch</li>
<li>Preconnect</li>
<li>Preload</li>
<li>Prefetch</li>
<li>Prerender</li>
</ul>
<h2 id="DNS-Prefetch"><a href="#DNS-Prefetch" class="headerlink" title="DNS Prefetch"></a>DNS Prefetch</h2><p>DNS解析：查找域名对应的ip，会耗费大量的时间，所以可以利用DNS预解析。</p>
<p>Resource Hint主要通过使用link标签。rel属性确定类型，href属性则指定相应的源或资源URL 。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//yourwebsite.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Preconnect"><a href="#Preconnect" class="headerlink" title="Preconnect"></a>Preconnect</h2><p>建立连接不仅需要DNS查询，还需要进行TCP协议握手，有些还会有TLS&#x2F;SSL协议，这些都会导致连接的耗时。因此，使用Preconnect可以帮助你告诉浏览器：“我有一些资源会用到某个源，可以帮我预先建立连接。”</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preconnect&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//yourwebsite.com&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<h2 id="Prefetch"><a href="#Prefetch" class="headerlink" title="Prefetch"></a>Prefetch</h2><p>你可以把Prefetch理解为资源预获取。一般来说，可以用Prefetch来指定在紧接着之后的操作或浏览中需要使用到的资源，让浏览器提前获取。由于仅仅是提前获取资源，因此浏览器不会对资源进行预处理，并且像CSS样式表、JavaScript脚本这样的资源是不会自动执行并应用于当前文档的。<br>在 Chrome 中，如果用户从一个页面跳转到另一个页面，prefetch 发起的请求仍会进行不会中断。<br>另外，prefetch 的资源在网络堆栈中至少缓存 5 分钟，无论它是不是可以缓存的。</p>
<h2 id="Preload"><a href="#Preload" class="headerlink" title="Preload"></a>Preload</h2><p>preload 提供了一种声明式的命令，让浏览器提前加载指定资源(加载后并不执行)，需要执行时再执行<br>这样做的好处在于：<br>1、将加载和执行分离开，不阻塞渲染和document的onload事件<br>2、提前加载指定资源，不再出现依赖的font字体隔了一段时间才刷出的情况</p>
<p>此外，preload 不会阻塞 windows 的 onload 事件</p>
<p>Preload的使用注意：<br>对跨域的文件进行preload时，必须加上 crossorigin 属性<br>没有用到的 preload 资源在 Chrome 的 console 里会在 onload 事件 3s 后发生警告<br><img data-src="/2020/07/20/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/quicklink%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%901/02.png"></p>
<p>需要注意的是，和DNS Prefetch、Preconnect使用不太一样的地方是，Prefetch有一个as的可选属性，用来指定获取资源的类型。由于不同的资源类型会具有不同的优先级、CSP、请求头等，因此该属性很重要。</p>
<h2 id="浏览器资源的优先级"><a href="#浏览器资源的优先级" class="headerlink" title="浏览器资源的优先级"></a>浏览器资源的优先级</h2><p>在Chrome浏览器中，不同的资源在浏览器渲染的不同阶段进行加载的优先级不同</p>
<p>一共分成五个级别</p>
<p>Highest 最高<br>Hight 高<br>Medium 中等<br>Low 低<br>Lowest 最低</p>
<p>其中主资源HTML和CSS的优先级最高，其他资源根据情况的不同优先级不一，JS脚本根据它们在文件中的位置是否异步、延迟或阻塞获得不同的优先级：<br>1、网络在第一个图片资源之前阻塞的脚本在网络优先级中是中级<br>2、网络在第一个图片资源之后阻塞的脚本在网络优先级中是低级<br>3、异步／延迟／插入的脚本（无论在什么位置）在网络优先级中是很低级</p>
<p>图片（视口可见）将会获得相对于视口不可见图片（低级）的更高的优先级（中级），所以某些程度上 Chrome 将会尽量懒加载这些图片。低优先级的图片在布局完成被视口发现时，将会获得优先级提升</p>
<p>预加载 使用 “as” 属性加载的资源将会获得与资源 “type” 属性所拥有的相同的优先级。比如说，preload as&#x3D;”style” 将会获得比 as&#x3D;“script” 更高的优先级</p>
<p>不带 “as” 属性的 预加载 的优先级将会等同于异步请求，如果忽略 as 属性，或者错误的 as 属性会使 预加载 等同于 XHR 请求，浏览器不知道加载的是什么，因此会赋予此类资源非常低的加载优先级</p>
]]></content>
      <categories>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>quicklink原理解析(二)</title>
    <url>/2020/07/29/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/quicklink%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%902/</url>
    <content><![CDATA[<h2 id="preload和prefetch的区别"><a href="#preload和prefetch的区别" class="headerlink" title="preload和prefetch的区别"></a>preload和prefetch的区别</h2><ol>
<li>preload 是告诉浏览器页面必定需要的资源，浏览器一定会加载这些资源，prefetch 是告诉浏览器页面可能需要的资源，浏览器不一定会加载这些资源</li>
<li>Prefetch加载优先级非常低，也就是说该方式的作用是加速下一个页面的加载速度</li>
<li>Preload 的与众不同还体现在 onload 事件上。也就是说可以定义资源加载完毕后的回调函数 <link rel="preload" href="..." as="..." onload="preloadFinished()"></li>
<li>preload 和 prefetch 混用的话，并不会复用资源，而是会重复加载，使用 preload 和 prefetch 的逻辑可能不是写到一起，但一旦发生对用一资源 preload 或 prefetch 的话，会带来双倍的网络请求</li>
<li><code>&lt;link rel=&quot;preload&quot;&gt;</code> 大约有 50% 的支持度，<code>&lt;link rel=&quot;prefetch&quot;&gt;</code> 大约有 70% 的支持度。</li>
</ol>
<h2 id="as资源类型"><a href="#as资源类型" class="headerlink" title="as资源类型"></a>as资源类型</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/my.little.script.js&quot;</span> <span class="attr">as</span>=<span class="string">&quot;script&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>as：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span>&gt;</span>、 <span class="tag">&lt;<span class="name">video</span>&gt;</span>、 <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml">、 <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">stylesheet</span>&gt;</span>、 <span class="tag">&lt;<span class="name">img</span>&gt;</span>、 SVG、 XHR, fetch、 <span class="tag">&lt;<span class="name">iframe</span>&gt;</span>、	HTML</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到，Prefetch的可选资源类型非常丰富，除了我们常用的script和style，甚至还包括iframe 、video、img等，基本涵盖了Web中的各类资源。</p>
<h2 id="Prerender"><a href="#Prerender" class="headerlink" title="Prerender"></a>Prerender</h2><p>prerender则是prefetch的更进一步。可以粗略地理解为“预处理”（预执行）。<br>通过Prerender“预处理”的资源，浏览器都会作为HTML进行处理。浏览器除了会去获取资源，还可能会预处理（MAY preprocess）该资源，而该HTML页面依赖的其他资源，像<code>&lt;script&gt;</code>、<code>&lt;style&gt;</code>等页面所需资源也可能会被处理。但是预处理会由于浏览器或当前机器、网络情况的不同而被不同程度地推迟。例如，会根据CPU、GPU和内存的使用情况选择不同的策略或阻止该操作。</p>
<p>注意，由于这些预处理操作的不可控性，当你只是需要能够预先获取部分资源来加速后续可能出现的网络请求时，建议使用Prefetch。
</p>
<h2 id="Quicklink的预加载"><a href="#Quicklink的预加载" class="headerlink" title="Quicklink的预加载"></a>Quicklink的预加载</h2><p>quicklink通过动态的创建link标签，再为其指定url<br>要预加载一个资源可以通过下面四行代码：<br><img data-src="/2020/07/29/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/quicklink%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%902/01.png"></p>
<h2 id="Resource-Hints的兼容处理"><a href="#Resource-Hints的兼容处理" class="headerlink" title="Resource Hints的兼容处理"></a>Resource Hints的兼容处理</h2><p>quicklink会判断是否支持 Resource Hints 中的 prefetch：link.relList.supports(feature)，<link> dom对象有一个relList属性，它的supports方法可以检测是否支持prefetch</p>
<p>在不支持 Resource Hints 的浏览器中，使用其他方式来预加载资源，所以，quicklink利用浏览器自身的缓存策略，回退使用 XHR 加载，“实实在在”预先请求这个资源<br><img data-src="/2020/07/29/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/quicklink%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%902/02.png"></p>
<h2 id="预加载策略"><a href="#预加载策略" class="headerlink" title="预加载策略"></a>预加载策略</h2><p>预加载方式：<br>第一种：如果传入的options参数中有urls属性，则直接执行预加载urls数组内的资源<br>第二种：通过document.querySelectorAll方法获取所有a标签元素的NodeList，然后遍历该元素节点列表，并监视该元素节点</p>
<p>有了资源预加载的方式，那么接下来就需要一个预加载的策略了。<br>这其实是个见仁见智的问题。例如直接给你一个链接 <a href="https://my.test.com/somelink%EF%BC%8C%E5%9C%A8%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E8%83%8C%E6%99%AF%E4%BF%A1%E6%81%AF%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E6%81%90%E6%80%95%E4%BD%A0%E5%AE%8C%E5%85%A8%E4%B8%8D%E7%9F%A5%E9%81%93%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%AE%83%E3%80%82%E9%82%A3%E5%AF%B9%E4%BA%8E%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%8Cquicklink">https://my.test.com/somelink，在没有任何背景信息的情况下，恐怕你完全不知道是否需要预加载它。那对于这个问题，quicklink</a> 是怎么解决的呢？或者说，quicklink 是通过什么策略来进行预加载的呢？<br>quicklink 用了一个比较直观的策略：只对处于视口内的资源进行预加载。这一点也比较好理解，网络上大多的资源加载、页面跳转都伴随着用户点击这类行为，而它要是不在你的视野内，你也就无从点击了。这一定程度上算是个必要条件。<br>这么一来，我们所要解决的问题就是，如何判断一个链接是否处于可视区域内？</p>
<h2 id="intersectionobserver"><a href="#intersectionobserver" class="headerlink" title="intersectionobserver"></a>intersectionobserver</h2><p><img data-src="/2020/07/29/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/quicklink%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%902/03.png"><br>IntersectionObserver支持两个参数：</p>
<ol>
<li>callback是当被监听元素的可见性变化时，触发的回调函数</li>
<li>options是一个配置参数，可选，有默认的属性值</li>
</ol>
<h2 id="intersectionobserver的兼容处理"><a href="#intersectionobserver的兼容处理" class="headerlink" title="intersectionobserver的兼容处理"></a>intersectionobserver的兼容处理</h2><p><a href="https://polyfill.io/v3/url-builder/">Polyfill</a>是一个js库，主要抚平不同浏览器之间对js实现的差异。比如window.XMLHttpRequest , 大多数浏览器支持，但IE不支持。Polyfill的典型做法是在IE浏览器中增加XHR对象，其内部实现还是使用 ActiveXObject，帮助将这些差异化抹平，不支持的变得支持了。<br>Polyfill.io 读取每个请求的 User-Agent(UA) 头，并生成适合于该浏览器的 polyfill ，基于你的应用所使用的特性发回必要的代码，polyfill的使用：<br>1.Features<br>该参数指定需要 polyfill 的浏览器特性。多个特性名之间用逗号分隔。允许使用的特性明在 浏览器和特性 页中列出。<br>2.Flags<br>always - Polyfill 将始终被包含，不管 UA 中指出的浏览器是否已经支持该特性。<br>gated - 通过特性检测来判断 Polyfill，只有在浏览器原生 API 不支持这些特性的情况下才返回并执行 Polyfill。<br><img data-src="/2020/07/29/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/quicklink%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%902/04.png"></p>
<h2 id="网络状态的获取"><a href="#网络状态的获取" class="headerlink" title="网络状态的获取"></a>网络状态的获取</h2><p>Navigator.connection 是只读的，提供一个NetworkInformation 对象来获取设备的网络连接信息。<br><img data-src="/2020/07/29/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/quicklink%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%902/05.png"><br>1、downlink： 估算的下行速度&#x2F;带宽</p>
<p>2、effectiveType： 当前的网络连接类型，其中effectiveType的取值可能是’slow-2g’、’2g’、’3g’或者’4g’。</p>
<p>3、onchange： 回调函数，在网络状态发生改变后执行</p>
<p>4、rtt ：估算的往返时间</p>
<p>5、saveData ：打开&#x2F;请求数据保护模式</p>
<p>(conn.effectiveType || ‘’).includes(‘2g’) || conn.saveData<br>effectiveType的取值可能是’slow-2g’、’2g’、’3g’或者’4g’</p>
<h2 id="quicklink的实现总结"><a href="#quicklink的实现总结" class="headerlink" title="quicklink的实现总结"></a>quicklink的实现总结</h2><ol>
<li><p>new 一个IntersectionObserver对象(提前引入polyfill做兼容)， 检测网页中的链接是否出现在视口中，等待链接出现在视口，执行步骤2。</p>
</li>
<li><p>使用requestIdleCallback等待浏览器空闲后（兼容则是自己模拟的一个setTimeOut），执行3。</p>
</li>
<li><p>判断当前的网络连接是否是2G或者数据保护模式，如果是则停止执行，直接return，如果不是，执行步骤4。</p>
</li>
<li><p>通过resource hint的prefetch或者XHR预加载链接指向的资源。<br><img data-src="/2020/07/29/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/quicklink%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%902/06.png"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2018/06/07/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>二分查找的前提为：数组、有序。</p>
<p>逻辑为：优先和数组的中间元素比较，如果等于中间元素，则直接返回。如果不等于则取半继续查找。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">binarySearch</span> = (<span class="params">arr, target</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = arr.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">let</span> middle = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(target === arr[middle]) <span class="keyword">return</span> middle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(target &gt; arr[middle]) &#123;</span><br><span class="line">      left = middle;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      right = middle;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">binarySearch</span>(arr, <span class="number">10</span>))  <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2018/06/05/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<blockquote>
<p>转载自阮一峰老师的 <a href="https://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html">《快速排序（Quicksort）的 Javascript 实现》</a></p>
</blockquote>
<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>“快速排序”的思想很简单，整个排序过程只需要三步：</p>
<ol>
<li>在数据集之中，选择一个元素作为 “基准”（pivot）。</li>
<li>所有小于 “基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到 “基准”的右边。</li>
<li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</li>
</ol>
<p>举例来说，现在有一个数据集{85, 24, 63, 45, 17, 31, 96, 50}，怎么对其排序呢？</p>
<p>第一步，选择中间的元素 45 作为”基准”。（基准值可以任意选择，但是选择中间的值比较容易理解。）</p>
<p><img data-src="https://www.ruanyifeng.com/blogimg/asset/201104/bg2011040403.png"></p>
<p>第二步，按照顺序，将每个元素与”基准”进行比较，形成两个子集，一个”小于 45”，另一个”大于等于 45”。</p>
<p><img data-src="https://www.ruanyifeng.com/blogimg/asset/201104/bg2011040404.png"></p>
<p>第三步，对两个子集不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</p>
<p><img data-src="https://www.ruanyifeng.com/blogimg/asset/201104/bg2011040405.png"></p>
<p><img data-src="https://www.ruanyifeng.com/blogimg/asset/201104/bg2011040406.png"></p>
<p><img data-src="https://www.ruanyifeng.com/blogimg/asset/201104/bg2011040407.png"></p>
<p><img data-src="https://www.ruanyifeng.com/blogimg/asset/201104/bg2011040408.png"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>检查数组的元素个数，如果小于等于 1，就返回</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">var quickSort = function(arr) &#123;</span><br><span class="line">  if(arr.length &lt;= 1) return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，选择”基准”（pivot），并将其与原数组分离，再定义两个空数组，用来存放一左一右的两个子集。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">var quickSort = function(arr) &#123;</span><br><span class="line">  if(arr.length &lt;= 1) return arr;</span><br><span class="line"></span><br><span class="line"><span class="addition">+  const centerIndex = Math.floor(arr.length / 2);</span></span><br><span class="line"><span class="addition">+  const center = arr.splice(centerIndex, 1)[0];</span></span><br><span class="line"><span class="addition">+  const left = []; </span></span><br><span class="line"><span class="addition">+  const right = [];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，开始遍历数组，小于”基准”的元素放入左边的子集，大于基准的元素放入右边的子集。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">var quickSort = function(arr) &#123;</span><br><span class="line">  if(arr.length &lt;= 1) return arr;</span><br><span class="line"></span><br><span class="line">  const centerIndex = Math.floor(arr.length / 2);</span><br><span class="line">  const center = arr.splice(centerIndex, 1)[0];</span><br><span class="line">  const left = []; </span><br><span class="line">  const right = [];</span><br><span class="line"><span class="addition">+  for(let i = 0; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="addition">+    arr[i] &lt; center ? left.push(arr[i]) : right.push(arr[i]);</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后，使用递归不断重复这个过程，就可以得到排序后的数组。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">var quickSort = function(arr) &#123;</span><br><span class="line">  if(arr.length &lt;= 1) return arr;</span><br><span class="line"></span><br><span class="line">  const centerIndex = Math.floor(arr.length / 2);</span><br><span class="line">  const center = arr.splice(centerIndex, 1)[0];</span><br><span class="line">  const left = []; </span><br><span class="line">  const right = [];</span><br><span class="line">  for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] &lt; center ? left.push(arr[i]) : right.push(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+  return [...quickSort(left), center, ...quickSort(right)];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = <span class="keyword">function</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(arr.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> centerIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> center = arr.<span class="title function_">splice</span>(centerIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> left = []; </span><br><span class="line">  <span class="keyword">const</span> right = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    arr[i] &lt; center ? left.<span class="title function_">push</span>(arr[i]) : right.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [...<span class="title function_">quickSort</span>(left), center, ...<span class="title function_">quickSort</span>(right)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">quickSort</span>(arr));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器缓存机制</title>
    <url>/2018/05/10/%E7%BC%93%E5%AD%98/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><img data-src="/2018/05/10/%E7%BC%93%E5%AD%98/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/1.png"></p>
<h2 id="HTTP缓存机制"><a href="#HTTP缓存机制" class="headerlink" title="HTTP缓存机制"></a>HTTP缓存机制</h2><blockquote>
<p>当一个用户发起一个静态资源请求的时候，浏览器会通过以下几步来获取资源：</p>
</blockquote>
<ol>
<li><code>200 from memory cache</code><br>不访问服务器，直接读缓存，从<code>内存</code>中读取缓存,此时的数据时缓存到内存中的，当<code>页面</code>被关闭以后，数据将不存在。</li>
<li><code>200 from disk cache</code><br>不访问服务器，直接读缓存，从<code>磁盘</code>中读取缓存，当页面或浏览器关闭后，数据还是存在。</li>
<li><code>304 (Not Modified)</code></li>
</ol>
<ul>
<li>缓存过期，但<code>Last-Modified</code>、<code>Etag</code>验证资源有效，服务器返回<code>304</code></li>
<li>缓存需要强制验证，确定资源有效后，服务器返回<code>304</code>，如：Cache-Control：no-cach（这个设置规定缓存前必须先确定有效性）</li>
</ul>
<p><img data-src="/2018/05/10/%E7%BC%93%E5%AD%98/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/3.png"></p>
<blockquote>
<p>具体描述：</p>
</blockquote>
<ol>
<li><code>本地缓存</code>阶段：先在本地查找该资源，如果有发现该资源，而且该资源还没有过期，就使用这一个资源，完全不会发送http请求到服务器；</li>
<li><code>协商缓存</code>阶段：如果在本地缓存找到对应的资源，但是不知道该资源是否过期或者已经过期，则发一个http请求到服务器,然后服务器判断这个请求，如果请求的资源在服务器上没有改动过，则返回304，让浏览器使用本地找到的那个资源；</li>
<li><code>缓存失败</code>阶段：当服务器发现请求的资源已经修改过，或者这是一个新的请求(在本地缓存中没有找到资源)，服务器则返回该资源的数据，并且返回200</li>
</ol>
<h3 id="协商缓存阶段"><a href="#协商缓存阶段" class="headerlink" title="协商缓存阶段"></a>协商缓存阶段</h3><h4 id="Last-Modified-amp-if-modified-since"><a href="#Last-Modified-amp-if-modified-since" class="headerlink" title="Last-Modified &amp; if-modified-since"></a>Last-Modified &amp; if-modified-since</h4><blockquote>
<p><code>Last-Modified</code>与<code>If-Modified-Since</code>是一对报文头，属于<code>http 1.0</code>。<br><code>last-modified</code>是WEB服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间。</p>
</blockquote>
<h4 id="ETag-amp-If-None-Match"><a href="#ETag-amp-If-None-Match" class="headerlink" title="ETag &amp; If-None-Match"></a>ETag &amp; If-None-Match</h4><blockquote>
<p><code>ETag</code>与<code>If-None-Match</code>是一对报文，属于<code>http 1.1</code>。<br><code>ETag</code>是一个文件的唯一标志符,就像一个哈希或者指纹，每个文件都有一个单独的标志，只要这个文件发生了改变，这个标志就会发生变化,如果请求资源的<code>ETag</code>与服务器的不一致，则表示该资源已经被修改过来，需要发最新的内容给浏览器。</p>
</blockquote>
<p><code>Etag</code>&#x2F;<code>lastModified</code>过程如下：</p>
<ol>
<li>客户端请求一个页面（A）。</li>
<li>服务器返回页面A，并在给A加上一个Last-Modified&#x2F;ETag。</li>
<li>客户端展现该页面，并将页面连同Last-Modified&#x2F;ETag一起缓存。</li>
<li>客户再次请求页面A，并将上次请求时服务器返回的Last-Modified&#x2F;ETag一起传递给服务器。</li>
<li>服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。</li>
</ol>
<blockquote>
<p>注意：通过<code>If-Modified-Since</code>和<code>If-Match</code>判断资源是否修改，如未修改则返回304，发生了一次请求，但请求内容长度为0，节省了带宽，如果有多台负载均衡的服务器，不同服务器计算出的Etag可能不同，这样就会造成资源的重复加载。</p>
</blockquote>
<p><code>Etag</code>主要为了解决<code>Last-Modified</code>无法解决的一些问题：</p>
<ol>
<li>一些文件如果改变后，又改回来了，<code>Last-Modified</code>会认为文件修改过，但其实它是没有变化的，<code>Etag</code>就不会判定它变化了</li>
<li><code>If-Modified-Since</code>能检查到文件的变化是秒级别的，但如果一个文件1秒内变化了好几次，<code>If-Modified-Since</code>就检测不出来，这时需要<code>Etag</code>检测</li>
<li>某些服务器不能精确的得到文件的最后修改时间</li>
</ol>
<h3 id="本地缓存阶段"><a href="#本地缓存阶段" class="headerlink" title="本地缓存阶段"></a>本地缓存阶段</h3><p><code>Expires</code>和<code>Cache-Control</code>是需要在服务器端配置的</p>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><blockquote>
<p>指定缓存到期GMT的绝对时间，如果设了max-age，max-age就会覆盖expires。如果expires到期需要重新请求。</p>
</blockquote>
<p>缺陷：<code>Expires</code>受限于本地时间，如果修改了本地时间，可能会造成缓存失效</p>
<h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><blockquote>
<p>Cache-Control:这个是http 1.1中为了弥补 Expires 缺陷新加入的，下面是常用的值：</p>
</blockquote>
<ul>
<li><code>no-cache</code>：强制浏览器在使用cache之前，先提交一个http请求到源服务器进行确认资源是否有效，防止从缓存中获取的是无效的资源。虽然http请求并未减少，但返回的是一个空的请求体，这样相当于减少了一个响应体。</li>
<li><code>no-store</code>：<code>no-store</code>规定了浏览器不缓存任何缓存，而<code>no-cache</code>只是不缓存无效（这里是<code>无效</code>不是<code>过期</code>）的资源。<br>如下图：资源<code>Expires</code>已失效，也设置了<code>no-cach</code>,但浏览器还是缓存了过期的资源(<code>304</code>可以证明已缓存)，因为服务器判断了<code>If-Modified-Since</code>，资源是没有改动过的，所以返回了<code>304</code>。<br><img data-src="/2018/05/10/%E7%BC%93%E5%AD%98/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/2.png"></li>
<li><code>max-age:</code>指定多少秒后缓存过期，如Cache-Control: max-age&#x3D;3600, must-revalidate（3600秒后过期）</li>
<li><code>must-revalidate</code>: 强制浏览器严格遵守你设置的cache规则。</li>
<li><code>proxy-revalidate</code>: 强制proxy严格遵守你设置的cache规则。</li>
</ul>
<p>参考：</p>
<ol>
<li><a href="http://imweb.io/topic/55c6f9bac222e3af6ce235b9">缓存策略</a></li>
<li><a href="https://www.cnblogs.com/sustudy/p/4874490.html">详解浏览器缓存机制与Apache设置缓存</a></li>
<li><a href="https://segmentfault.com/a/1190000011286027">由memoryCache和diskCache产生的浏览器缓存机制的思考</a></li>
</ol>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
</search>
